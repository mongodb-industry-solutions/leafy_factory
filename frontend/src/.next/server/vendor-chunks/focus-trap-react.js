"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/focus-trap-react";
exports.ids = ["vendor-chunks/focus-trap-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js":
/*!****************************************************************!*\
  !*** ./node_modules/focus-trap-react/dist/focus-trap-react.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\nvar PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\nvar _require = __webpack_require__(/*! focus-trap */ \"(ssr)/./node_modules/focus-trap/dist/focus-trap.esm.js\"),\n    createFocusTrap = _require.createFocusTrap;\n\nvar _require2 = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\"),\n    isFocusable = _require2.isFocusable;\n\nvar FocusTrap = /*#__PURE__*/function (_React$Component) {\n  _inherits(FocusTrap, _React$Component);\n\n  var _super = _createSuper(FocusTrap);\n\n  function FocusTrap(props) {\n    var _this;\n\n    _classCallCheck(this, FocusTrap);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"getNodeForOption\", function (optionName) {\n      var _this$internalOptions;\n\n      // use internal options first, falling back to original options\n      var optionValue = (_this$internalOptions = this.internalOptions[optionName]) !== null && _this$internalOptions !== void 0 ? _this$internalOptions : this.originalOptions[optionName];\n\n      if (typeof optionValue === 'function') {\n        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          params[_key - 1] = arguments[_key];\n        }\n\n        optionValue = optionValue.apply(void 0, params);\n      }\n\n      if (optionValue === true) {\n        optionValue = undefined; // use default value\n      }\n\n      if (!optionValue) {\n        if (optionValue === undefined || optionValue === false) {\n          return optionValue;\n        } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n        throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n      }\n\n      var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n      if (typeof optionValue === 'string') {\n        var _this$getDocument;\n\n        node = (_this$getDocument = this.getDocument()) === null || _this$getDocument === void 0 ? void 0 : _this$getDocument.querySelector(optionValue); // resolve to node, or null if fails\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n        }\n      }\n\n      return node;\n    });\n\n    _this.handleDeactivate = _this.handleDeactivate.bind(_assertThisInitialized(_this));\n    _this.handlePostDeactivate = _this.handlePostDeactivate.bind(_assertThisInitialized(_this));\n    _this.handleClickOutsideDeactivates = _this.handleClickOutsideDeactivates.bind(_assertThisInitialized(_this)); // focus-trap options used internally when creating the trap\n\n    _this.internalOptions = {\n      // We need to hijack the returnFocusOnDeactivate option,\n      // because React can move focus into the element before we arrived at\n      // this lifecycle hook (e.g. with autoFocus inputs). So the component\n      // captures the previouslyFocusedElement in componentWillMount,\n      // then (optionally) returns focus to it in componentWillUnmount.\n      returnFocusOnDeactivate: false,\n      // the rest of these are also related to deactivation of the trap, and we\n      //  need to use them and control them as well\n      checkCanReturnFocus: null,\n      onDeactivate: _this.handleDeactivate,\n      onPostDeactivate: _this.handlePostDeactivate,\n      // we need to special-case this setting as well so that we can know if we should\n      //  NOT return focus if the trap gets auto-deactivated as the result of an\n      //  outside click (otherwise, we'll always think we should return focus because\n      //  of how we manage that flag internally here)\n      clickOutsideDeactivates: _this.handleClickOutsideDeactivates\n    }; // original options provided by the consumer\n\n    _this.originalOptions = {\n      // because of the above `internalOptions`, we maintain our own flag for\n      //  this option, and default it to `true` because that's focus-trap's default\n      returnFocusOnDeactivate: true,\n      // because of the above `internalOptions`, we keep these separate since\n      //  they're part of the deactivation process which we configure (internally) to\n      //  be shared between focus-trap and focus-trap-react\n      onDeactivate: null,\n      onPostDeactivate: null,\n      checkCanReturnFocus: null,\n      // the user's setting, defaulted to false since focus-trap defaults this to false\n      clickOutsideDeactivates: false\n    };\n    var focusTrapOptions = props.focusTrapOptions;\n\n    for (var optionName in focusTrapOptions) {\n      if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n        continue;\n      }\n\n      if (optionName === 'returnFocusOnDeactivate' || optionName === 'onDeactivate' || optionName === 'onPostDeactivate' || optionName === 'checkCanReturnFocus' || optionName === 'clickOutsideDeactivates') {\n        _this.originalOptions[optionName] = focusTrapOptions[optionName];\n        continue; // exclude from internalOptions\n      }\n\n      _this.internalOptions[optionName] = focusTrapOptions[optionName];\n    } // if set, `{ target: Node, allowDeactivation: boolean }` where `target` is the outside\n    //  node that was clicked, and `allowDeactivation` is the result of the consumer's\n    //  option (stored in `this.originalOptions.clickOutsideDeactivates`, which may be a\n    //  function) whether to allow or deny auto-deactivation on click on this outside node\n\n\n    _this.outsideClick = null; // elements from which to create the focus trap on mount; if a child is used\n    //  instead of the `containerElements` prop, we'll get the child's related\n    //  element when the trap renders and then is declared 'mounted'\n\n    _this.focusTrapElements = props.containerElements || []; // now we remember what the currently focused element is, not relying on focus-trap\n\n    _this.updatePreviousElement();\n\n    return _this;\n  }\n  /**\n   * Gets the configured document.\n   * @returns {Document|undefined} Configured document, falling back to the main\n   *  document, if it exists. During SSR, `undefined` is returned since the\n   *  document doesn't exist.\n   */\n\n\n  _createClass(FocusTrap, [{\n    key: \"getDocument\",\n    value: function getDocument() {\n      // SSR: careful to check if `document` exists before accessing it as a variable\n      return this.props.focusTrapOptions.document || (typeof document !== 'undefined' ? document : undefined);\n    }\n    /**\n     * Gets the node for the given option, which is expected to be an option that\n     *  can be either a DOM node, a string that is a selector to get a node, `false`\n     *  (if a node is explicitly NOT given), or a function that returns any of these\n     *  values.\n     * @param {string} optionName\n     * @returns {undefined | false | HTMLElement | SVGElement} Returns\n     *  `undefined` if the option is not specified; `false` if the option\n     *  resolved to `false` (node explicitly not given); otherwise, the resolved\n     *  DOM node.\n     * @throws {Error} If the option is set, not `false`, and is not, or does not\n     *  resolve to a node.\n     */\n\n  }, {\n    key: \"getReturnFocusNode\",\n    value: function getReturnFocusNode() {\n      var node = this.getNodeForOption('setReturnFocus', this.previouslyFocusedElement);\n      return node ? node : node === false ? false : this.previouslyFocusedElement;\n    }\n    /** Update the previously focused element with the currently focused element. */\n\n  }, {\n    key: \"updatePreviousElement\",\n    value: function updatePreviousElement() {\n      var currentDocument = this.getDocument();\n\n      if (currentDocument) {\n        this.previouslyFocusedElement = currentDocument.activeElement;\n      }\n    }\n  }, {\n    key: \"deactivateTrap\",\n    value: function deactivateTrap() {\n      // NOTE: it's possible the focus trap has already been deactivated without our knowing it,\n      //  especially if the user set the `clickOutsideDeactivates: true` option on the trap,\n      //  and the mouse was clicked on some element outside the trap; at that point, focus-trap\n      //  will initiate its auto-deactivation process, which will call our own\n      //  handleDeactivate(), which will call into this method\n      if (!this.focusTrap || !this.focusTrap.active) {\n        return;\n      }\n\n      this.focusTrap.deactivate({\n        // NOTE: we never let the trap return the focus since we do that ourselves\n        returnFocus: false,\n        // we'll call this in our own post deactivate handler so make sure the trap doesn't\n        //  do it prematurely\n        checkCanReturnFocus: null,\n        // let it call the user's original deactivate handler, if any, instead of\n        //  our own which calls back into this function\n        onDeactivate: this.originalOptions.onDeactivate // NOTE: for post deactivate, don't specify anything so that it calls the\n        //  onPostDeactivate handler specified on `this.internalOptions`\n        //  which will always be our own `handlePostDeactivate()` handler, which\n        //  will finish things off by calling the user's provided onPostDeactivate\n        //  handler, if any, at the right time\n        // onPostDeactivate: NOTHING\n\n      });\n    }\n  }, {\n    key: \"handleClickOutsideDeactivates\",\n    value: function handleClickOutsideDeactivates(event) {\n      // use consumer's option (or call their handler) as the permission or denial\n      var allowDeactivation = typeof this.originalOptions.clickOutsideDeactivates === 'function' ? this.originalOptions.clickOutsideDeactivates.call(null, event) // call out of context\n      : this.originalOptions.clickOutsideDeactivates; // boolean\n\n      if (allowDeactivation) {\n        // capture the outside target that was clicked so we can use it in the deactivation\n        //  process since the consumer allowed it to cause auto-deactivation\n        this.outsideClick = {\n          target: event.target,\n          allowDeactivation: allowDeactivation\n        };\n      }\n\n      return allowDeactivation;\n    }\n  }, {\n    key: \"handleDeactivate\",\n    value: function handleDeactivate() {\n      if (this.originalOptions.onDeactivate) {\n        this.originalOptions.onDeactivate.call(null); // call user's handler out of context\n      }\n\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"handlePostDeactivate\",\n    value: function handlePostDeactivate() {\n      var _this2 = this;\n\n      var finishDeactivation = function finishDeactivation() {\n        var returnFocusNode = _this2.getReturnFocusNode();\n\n        var canReturnFocus = !!( // did the consumer allow it?\n        _this2.originalOptions.returnFocusOnDeactivate && // can we actually focus the node?\n        returnFocusNode !== null && returnFocusNode !== void 0 && returnFocusNode.focus && ( // was there an outside click that allowed deactivation?\n        !_this2.outsideClick || // did the consumer allow deactivation when the outside node was clicked?\n        _this2.outsideClick.allowDeactivation && // is the outside node NOT focusable (implying that it did NOT receive focus\n        //  as a result of the click-through) -- in which case do NOT restore focus\n        //  to `returnFocusNode` because focus should remain on the outside node\n        !isFocusable(_this2.outsideClick.target, _this2.internalOptions.tabbableOptions)) // if no, the restore focus to `returnFocusNode` at this point\n        );\n        var _this2$internalOption = _this2.internalOptions.preventScroll,\n            preventScroll = _this2$internalOption === void 0 ? false : _this2$internalOption;\n\n        if (canReturnFocus) {\n          // return focus to the element that had focus when the trap was activated\n          returnFocusNode.focus({\n            preventScroll: preventScroll\n          });\n        }\n\n        if (_this2.originalOptions.onPostDeactivate) {\n          _this2.originalOptions.onPostDeactivate.call(null); // don't call it in context of \"this\"\n\n        }\n\n        _this2.outsideClick = null; // reset: no longer needed\n      };\n\n      if (this.originalOptions.checkCanReturnFocus) {\n        this.originalOptions.checkCanReturnFocus.call(null, this.getReturnFocusNode()) // call out of context\n        .then(finishDeactivation, finishDeactivation);\n      } else {\n        finishDeactivation();\n      }\n    }\n  }, {\n    key: \"setupFocusTrap\",\n    value: function setupFocusTrap() {\n      if (this.focusTrap) {\n        // trap already exists: it's possible we're in StrictMode and we're being remounted,\n        //  in which case, we will have deactivated the trap when we got unmounted (remember,\n        //  StrictMode, in development, purposely unmounts and remounts components after\n        //  mounting them the first time to make sure they have reusable state,\n        //  @see https://reactjs.org/docs/strict-mode.html#ensuring-reusable-state) so now\n        //  we need to restore the state of the trap according to our component state\n        // NOTE: Strict mode __violates__ assumptions about the `componentWillUnmount()` API\n        //  which clearly states -- even for React 18 -- that, \"Once a component instance is\n        //  unmounted, __it will never be mounted again.__\" (emphasis ours). So when we get\n        //  unmounted, we assume we're gone forever and we deactivate the trap. But then\n        //  we get remounted and we're supposed to restore state. But if you had paused,\n        //  we've now deactivated (we don't know we're amount to get remounted again)\n        //  which means we need to reactivate and then pause. Otherwise, do nothing.\n        if (this.props.active && !this.focusTrap.active) {\n          this.focusTrap.activate();\n\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      } else {\n        var nodesExist = this.focusTrapElements.some(Boolean);\n\n        if (nodesExist) {\n          // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n          this.focusTrap = this.props._createFocusTrap(this.focusTrapElements, this.internalOptions);\n\n          if (this.props.active) {\n            this.focusTrap.activate();\n          }\n\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.active) {\n        this.setupFocusTrap();\n      } // else, wait for later activation in case the `focusTrapOptions` will be updated\n      //  again before the trap is activated (e.g. if waiting to know what the document\n      //  object will be, so the Trap must be rendered, but the consumer is waiting to\n      //  activate until they have obtained the document from a ref)\n      //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.focusTrap) {\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrap.updateContainerElements(this.props.containerElements);\n        }\n\n        var hasActivated = !prevProps.active && this.props.active;\n        var hasDeactivated = prevProps.active && !this.props.active;\n        var hasPaused = !prevProps.paused && this.props.paused;\n        var hasUnpaused = prevProps.paused && !this.props.paused;\n\n        if (hasActivated) {\n          this.updatePreviousElement();\n          this.focusTrap.activate();\n        }\n\n        if (hasDeactivated) {\n          this.deactivateTrap();\n          return; // un/pause does nothing on an inactive trap\n        }\n\n        if (hasPaused) {\n          this.focusTrap.pause();\n        }\n\n        if (hasUnpaused) {\n          this.focusTrap.unpause();\n        }\n      } else {\n        // NOTE: if we're in `componentDidUpdate` and we don't have a trap yet,\n        //  it either means it shouldn't be active, or it should be but none of\n        //  of given `containerElements` were present in the DOM the last time\n        //  we tried to create the trap\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrapElements = this.props.containerElements;\n        } // don't create the trap unless it should be active in case the consumer\n        //  is still updating `focusTrapOptions`\n        //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n\n\n        if (this.props.active) {\n          this.updatePreviousElement();\n          this.setupFocusTrap();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n\n      if (child) {\n        if (child.type && child.type === React.Fragment) {\n          throw new Error('A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.');\n        }\n\n        var callbackRef = function callbackRef(element) {\n          var containerElements = _this3.props.containerElements;\n\n          if (child) {\n            if (typeof child.ref === 'function') {\n              child.ref(element);\n            } else if (child.ref) {\n              child.ref.current = element;\n            }\n          }\n\n          _this3.focusTrapElements = containerElements ? containerElements : [element];\n        };\n\n        var childWithRef = React.cloneElement(child, {\n          ref: callbackRef\n        });\n        return childWithRef;\n      }\n\n      return null;\n    }\n  }]);\n\n  return FocusTrap;\n}(React.Component); // support server-side rendering where `Element` will not be defined\n\n\nvar ElementType = typeof Element === 'undefined' ? Function : Element;\nFocusTrap.propTypes = {\n  active: PropTypes.bool,\n  paused: PropTypes.bool,\n  focusTrapOptions: PropTypes.shape({\n    document: PropTypes.object,\n    onActivate: PropTypes.func,\n    onPostActivate: PropTypes.func,\n    checkCanFocusTrap: PropTypes.func,\n    onDeactivate: PropTypes.func,\n    onPostDeactivate: PropTypes.func,\n    checkCanReturnFocus: PropTypes.func,\n    initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.bool, PropTypes.func]),\n    fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, // NOTE: does not support `false` as value (or return value from function)\n    PropTypes.func]),\n    escapeDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    clickOutsideDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    returnFocusOnDeactivate: PropTypes.bool,\n    setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.bool, PropTypes.func]),\n    allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    preventScroll: PropTypes.bool,\n    tabbableOptions: PropTypes.shape({\n      displayCheck: PropTypes.oneOf(['full', 'non-zero-area', 'none']),\n      getShadowRoot: PropTypes.oneOfType([PropTypes.bool, PropTypes.func])\n    })\n  }),\n  containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n  // DOM element ONLY\n  children: PropTypes.oneOfType([PropTypes.element, // React element\n  PropTypes.instanceOf(ElementType) // DOM element\n  ]) // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't\n  //  specify it here. It's expected to be set to the function returned from\n  //  require('focus-trap'), or one with a compatible interface.\n\n};\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC1yZWFjdC9kaXN0L2ZvY3VzLXRyYXAtcmVhY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLDJCQUEyQixzR0FBc0cscUJBQXFCLG1CQUFtQiw4SEFBOEg7O0FBRS9ULGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7O0FBRXhRLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHLCtDQUErQyxpQkFBaUIsR0FBRzs7QUFFNVksaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7QUFFekssaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWUsNEJBQTRCLG1GQUFtRjs7QUFFMVAsd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsOEJBQThCLHVHQUF1RyxtREFBbUQ7O0FBRXhMLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUVwTSxZQUFZLG1CQUFPLENBQUMsaUdBQU87O0FBRTNCLGdCQUFnQixtQkFBTyxDQUFDLDREQUFZOztBQUVwQyxlQUFlLG1CQUFPLENBQUMsMEVBQVk7QUFDbkM7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVU7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlHQUFpRyxhQUFhO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQSwwSkFBMEo7O0FBRTFKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUhBQW1IOztBQUVuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQSxNQUFNLGNBQWMsMENBQTBDO0FBQzlEO0FBQ0E7QUFDQTs7O0FBR0EsK0JBQStCLDBEQUEwRDtBQUN6RjtBQUNBOztBQUVBLDZEQUE2RDs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLDhDQUE4QztBQUMvRCxvREFBb0Q7QUFDcEQseURBQXlEO0FBQ3pEO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSw4REFBOEQ7O0FBRTlEOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsbUJBQW1COzs7QUFHcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy90ZXN0L0RvY3VtZW50cy9HaXRIdWIvbGVhZnlfZmFjdG9yeS9mcm9udGVuZC9zcmMvbm9kZV9tb2R1bGVzL2ZvY3VzLXRyYXAtcmVhY3QvZGlzdC9mb2N1cy10cmFwLXJlYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZm9jdXMtdHJhcCcpLFxuICAgIGNyZWF0ZUZvY3VzVHJhcCA9IF9yZXF1aXJlLmNyZWF0ZUZvY3VzVHJhcDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3RhYmJhYmxlJyksXG4gICAgaXNGb2N1c2FibGUgPSBfcmVxdWlyZTIuaXNGb2N1c2FibGU7XG5cbnZhciBGb2N1c1RyYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEZvY3VzVHJhcCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihGb2N1c1RyYXApO1xuXG4gIGZ1bmN0aW9uIEZvY3VzVHJhcChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb2N1c1RyYXApO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZ2V0Tm9kZUZvck9wdGlvblwiLCBmdW5jdGlvbiAob3B0aW9uTmFtZSkge1xuICAgICAgdmFyIF90aGlzJGludGVybmFsT3B0aW9ucztcblxuICAgICAgLy8gdXNlIGludGVybmFsIG9wdGlvbnMgZmlyc3QsIGZhbGxpbmcgYmFjayB0byBvcmlnaW5hbCBvcHRpb25zXG4gICAgICB2YXIgb3B0aW9uVmFsdWUgPSAoX3RoaXMkaW50ZXJuYWxPcHRpb25zID0gdGhpcy5pbnRlcm5hbE9wdGlvbnNbb3B0aW9uTmFtZV0pICE9PSBudWxsICYmIF90aGlzJGludGVybmFsT3B0aW9ucyAhPT0gdm9pZCAwID8gX3RoaXMkaW50ZXJuYWxPcHRpb25zIDogdGhpcy5vcmlnaW5hbE9wdGlvbnNbb3B0aW9uTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvblZhbHVlID0gb3B0aW9uVmFsdWUuYXBwbHkodm9pZCAwLCBwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9uVmFsdWUgPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHZhbHVlXG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgb3B0aW9uVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvblZhbHVlO1xuICAgICAgICB9IC8vIGVsc2UsIGVtcHR5IHN0cmluZyAoaW52YWxpZCksIG51bGwgKGludmFsaWQpLCAwIChpbnZhbGlkKVxuXG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYFwiLmNvbmNhdChvcHRpb25OYW1lLCBcImAgd2FzIHNwZWNpZmllZCBidXQgd2FzIG5vdCBhIG5vZGUsIG9yIGRpZCBub3QgcmV0dXJuIGEgbm9kZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gb3B0aW9uVmFsdWU7IC8vIGNvdWxkIGJlIEhUTUxFbGVtZW50LCBTVkdFbGVtZW50LCBvciBub24tZW1wdHkgc3RyaW5nIGF0IHRoaXMgcG9pbnRcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldERvY3VtZW50O1xuXG4gICAgICAgIG5vZGUgPSAoX3RoaXMkZ2V0RG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KCkpID09PSBudWxsIHx8IF90aGlzJGdldERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXREb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTsgLy8gcmVzb2x2ZSB0byBub2RlLCBvciBudWxsIGlmIGZhaWxzXG5cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYFwiLmNvbmNhdChvcHRpb25OYW1lLCBcImAgYXMgc2VsZWN0b3IgcmVmZXJzIHRvIG5vIGtub3duIG5vZGVcIikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuaGFuZGxlRGVhY3RpdmF0ZSA9IF90aGlzLmhhbmRsZURlYWN0aXZhdGUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlUG9zdERlYWN0aXZhdGUgPSBfdGhpcy5oYW5kbGVQb3N0RGVhY3RpdmF0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlcyA9IF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZURlYWN0aXZhdGVzLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOyAvLyBmb2N1cy10cmFwIG9wdGlvbnMgdXNlZCBpbnRlcm5hbGx5IHdoZW4gY3JlYXRpbmcgdGhlIHRyYXBcblxuICAgIF90aGlzLmludGVybmFsT3B0aW9ucyA9IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gaGlqYWNrIHRoZSByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSBvcHRpb24sXG4gICAgICAvLyBiZWNhdXNlIFJlYWN0IGNhbiBtb3ZlIGZvY3VzIGludG8gdGhlIGVsZW1lbnQgYmVmb3JlIHdlIGFycml2ZWQgYXRcbiAgICAgIC8vIHRoaXMgbGlmZWN5Y2xlIGhvb2sgKGUuZy4gd2l0aCBhdXRvRm9jdXMgaW5wdXRzKS4gU28gdGhlIGNvbXBvbmVudFxuICAgICAgLy8gY2FwdHVyZXMgdGhlIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCBpbiBjb21wb25lbnRXaWxsTW91bnQsXG4gICAgICAvLyB0aGVuIChvcHRpb25hbGx5KSByZXR1cm5zIGZvY3VzIHRvIGl0IGluIGNvbXBvbmVudFdpbGxVbm1vdW50LlxuICAgICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IGZhbHNlLFxuICAgICAgLy8gdGhlIHJlc3Qgb2YgdGhlc2UgYXJlIGFsc28gcmVsYXRlZCB0byBkZWFjdGl2YXRpb24gb2YgdGhlIHRyYXAsIGFuZCB3ZVxuICAgICAgLy8gIG5lZWQgdG8gdXNlIHRoZW0gYW5kIGNvbnRyb2wgdGhlbSBhcyB3ZWxsXG4gICAgICBjaGVja0NhblJldHVybkZvY3VzOiBudWxsLFxuICAgICAgb25EZWFjdGl2YXRlOiBfdGhpcy5oYW5kbGVEZWFjdGl2YXRlLFxuICAgICAgb25Qb3N0RGVhY3RpdmF0ZTogX3RoaXMuaGFuZGxlUG9zdERlYWN0aXZhdGUsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNwZWNpYWwtY2FzZSB0aGlzIHNldHRpbmcgYXMgd2VsbCBzbyB0aGF0IHdlIGNhbiBrbm93IGlmIHdlIHNob3VsZFxuICAgICAgLy8gIE5PVCByZXR1cm4gZm9jdXMgaWYgdGhlIHRyYXAgZ2V0cyBhdXRvLWRlYWN0aXZhdGVkIGFzIHRoZSByZXN1bHQgb2YgYW5cbiAgICAgIC8vICBvdXRzaWRlIGNsaWNrIChvdGhlcndpc2UsIHdlJ2xsIGFsd2F5cyB0aGluayB3ZSBzaG91bGQgcmV0dXJuIGZvY3VzIGJlY2F1c2VcbiAgICAgIC8vICBvZiBob3cgd2UgbWFuYWdlIHRoYXQgZmxhZyBpbnRlcm5hbGx5IGhlcmUpXG4gICAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogX3RoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXNcbiAgICB9OyAvLyBvcmlnaW5hbCBvcHRpb25zIHByb3ZpZGVkIGJ5IHRoZSBjb25zdW1lclxuXG4gICAgX3RoaXMub3JpZ2luYWxPcHRpb25zID0ge1xuICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgYWJvdmUgYGludGVybmFsT3B0aW9uc2AsIHdlIG1haW50YWluIG91ciBvd24gZmxhZyBmb3JcbiAgICAgIC8vICB0aGlzIG9wdGlvbiwgYW5kIGRlZmF1bHQgaXQgdG8gYHRydWVgIGJlY2F1c2UgdGhhdCdzIGZvY3VzLXRyYXAncyBkZWZhdWx0XG4gICAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogdHJ1ZSxcbiAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIGFib3ZlIGBpbnRlcm5hbE9wdGlvbnNgLCB3ZSBrZWVwIHRoZXNlIHNlcGFyYXRlIHNpbmNlXG4gICAgICAvLyAgdGhleSdyZSBwYXJ0IG9mIHRoZSBkZWFjdGl2YXRpb24gcHJvY2VzcyB3aGljaCB3ZSBjb25maWd1cmUgKGludGVybmFsbHkpIHRvXG4gICAgICAvLyAgYmUgc2hhcmVkIGJldHdlZW4gZm9jdXMtdHJhcCBhbmQgZm9jdXMtdHJhcC1yZWFjdFxuICAgICAgb25EZWFjdGl2YXRlOiBudWxsLFxuICAgICAgb25Qb3N0RGVhY3RpdmF0ZTogbnVsbCxcbiAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXM6IG51bGwsXG4gICAgICAvLyB0aGUgdXNlcidzIHNldHRpbmcsIGRlZmF1bHRlZCB0byBmYWxzZSBzaW5jZSBmb2N1cy10cmFwIGRlZmF1bHRzIHRoaXMgdG8gZmFsc2VcbiAgICAgIGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGZvY3VzVHJhcE9wdGlvbnMgPSBwcm9wcy5mb2N1c1RyYXBPcHRpb25zO1xuXG4gICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBmb2N1c1RyYXBPcHRpb25zKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb2N1c1RyYXBPcHRpb25zLCBvcHRpb25OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbk5hbWUgPT09ICdyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZScgfHwgb3B0aW9uTmFtZSA9PT0gJ29uRGVhY3RpdmF0ZScgfHwgb3B0aW9uTmFtZSA9PT0gJ29uUG9zdERlYWN0aXZhdGUnIHx8IG9wdGlvbk5hbWUgPT09ICdjaGVja0NhblJldHVybkZvY3VzJyB8fCBvcHRpb25OYW1lID09PSAnY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMnKSB7XG4gICAgICAgIF90aGlzLm9yaWdpbmFsT3B0aW9uc1tvcHRpb25OYW1lXSA9IGZvY3VzVHJhcE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIGNvbnRpbnVlOyAvLyBleGNsdWRlIGZyb20gaW50ZXJuYWxPcHRpb25zXG4gICAgICB9XG5cbiAgICAgIF90aGlzLmludGVybmFsT3B0aW9uc1tvcHRpb25OYW1lXSA9IGZvY3VzVHJhcE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgfSAvLyBpZiBzZXQsIGB7IHRhcmdldDogTm9kZSwgYWxsb3dEZWFjdGl2YXRpb246IGJvb2xlYW4gfWAgd2hlcmUgYHRhcmdldGAgaXMgdGhlIG91dHNpZGVcbiAgICAvLyAgbm9kZSB0aGF0IHdhcyBjbGlja2VkLCBhbmQgYGFsbG93RGVhY3RpdmF0aW9uYCBpcyB0aGUgcmVzdWx0IG9mIHRoZSBjb25zdW1lcidzXG4gICAgLy8gIG9wdGlvbiAoc3RvcmVkIGluIGB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jbGlja091dHNpZGVEZWFjdGl2YXRlc2AsIHdoaWNoIG1heSBiZSBhXG4gICAgLy8gIGZ1bmN0aW9uKSB3aGV0aGVyIHRvIGFsbG93IG9yIGRlbnkgYXV0by1kZWFjdGl2YXRpb24gb24gY2xpY2sgb24gdGhpcyBvdXRzaWRlIG5vZGVcblxuXG4gICAgX3RoaXMub3V0c2lkZUNsaWNrID0gbnVsbDsgLy8gZWxlbWVudHMgZnJvbSB3aGljaCB0byBjcmVhdGUgdGhlIGZvY3VzIHRyYXAgb24gbW91bnQ7IGlmIGEgY2hpbGQgaXMgdXNlZFxuICAgIC8vICBpbnN0ZWFkIG9mIHRoZSBgY29udGFpbmVyRWxlbWVudHNgIHByb3AsIHdlJ2xsIGdldCB0aGUgY2hpbGQncyByZWxhdGVkXG4gICAgLy8gIGVsZW1lbnQgd2hlbiB0aGUgdHJhcCByZW5kZXJzIGFuZCB0aGVuIGlzIGRlY2xhcmVkICdtb3VudGVkJ1xuXG4gICAgX3RoaXMuZm9jdXNUcmFwRWxlbWVudHMgPSBwcm9wcy5jb250YWluZXJFbGVtZW50cyB8fCBbXTsgLy8gbm93IHdlIHJlbWVtYmVyIHdoYXQgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgaXMsIG5vdCByZWx5aW5nIG9uIGZvY3VzLXRyYXBcblxuICAgIF90aGlzLnVwZGF0ZVByZXZpb3VzRWxlbWVudCgpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb25maWd1cmVkIGRvY3VtZW50LlxuICAgKiBAcmV0dXJucyB7RG9jdW1lbnR8dW5kZWZpbmVkfSBDb25maWd1cmVkIGRvY3VtZW50LCBmYWxsaW5nIGJhY2sgdG8gdGhlIG1haW5cbiAgICogIGRvY3VtZW50LCBpZiBpdCBleGlzdHMuIER1cmluZyBTU1IsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHNpbmNlIHRoZVxuICAgKiAgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRm9jdXNUcmFwLCBbe1xuICAgIGtleTogXCJnZXREb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICAgIC8vIFNTUjogY2FyZWZ1bCB0byBjaGVjayBpZiBgZG9jdW1lbnRgIGV4aXN0cyBiZWZvcmUgYWNjZXNzaW5nIGl0IGFzIGEgdmFyaWFibGVcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmZvY3VzVHJhcE9wdGlvbnMuZG9jdW1lbnQgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBvcHRpb24sIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9wdGlvbiB0aGF0XG4gICAgICogIGNhbiBiZSBlaXRoZXIgYSBET00gbm9kZSwgYSBzdHJpbmcgdGhhdCBpcyBhIHNlbGVjdG9yIHRvIGdldCBhIG5vZGUsIGBmYWxzZWBcbiAgICAgKiAgKGlmIGEgbm9kZSBpcyBleHBsaWNpdGx5IE5PVCBnaXZlbiksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFueSBvZiB0aGVzZVxuICAgICAqICB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbk5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgZmFsc2UgfCBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IFJldHVybnNcbiAgICAgKiAgYHVuZGVmaW5lZGAgaWYgdGhlIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkOyBgZmFsc2VgIGlmIHRoZSBvcHRpb25cbiAgICAgKiAgcmVzb2x2ZWQgdG8gYGZhbHNlYCAobm9kZSBleHBsaWNpdGx5IG5vdCBnaXZlbik7IG90aGVyd2lzZSwgdGhlIHJlc29sdmVkXG4gICAgICogIERPTSBub2RlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgb3B0aW9uIGlzIHNldCwgbm90IGBmYWxzZWAsIGFuZCBpcyBub3QsIG9yIGRvZXMgbm90XG4gICAgICogIHJlc29sdmUgdG8gYSBub2RlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmV0dXJuRm9jdXNOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJldHVybkZvY3VzTm9kZSgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5nZXROb2RlRm9yT3B0aW9uKCdzZXRSZXR1cm5Gb2N1cycsIHRoaXMucHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcbiAgICAgIHJldHVybiBub2RlID8gbm9kZSA6IG5vZGUgPT09IGZhbHNlID8gZmFsc2UgOiB0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDtcbiAgICB9XG4gICAgLyoqIFVwZGF0ZSB0aGUgcHJldmlvdXNseSBmb2N1c2VkIGVsZW1lbnQgd2l0aCB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudC4gKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVByZXZpb3VzRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQcmV2aW91c0VsZW1lbnQoKSB7XG4gICAgICB2YXIgY3VycmVudERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCgpO1xuXG4gICAgICBpZiAoY3VycmVudERvY3VtZW50KSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gY3VycmVudERvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlYWN0aXZhdGVUcmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYWN0aXZhdGVUcmFwKCkge1xuICAgICAgLy8gTk9URTogaXQncyBwb3NzaWJsZSB0aGUgZm9jdXMgdHJhcCBoYXMgYWxyZWFkeSBiZWVuIGRlYWN0aXZhdGVkIHdpdGhvdXQgb3VyIGtub3dpbmcgaXQsXG4gICAgICAvLyAgZXNwZWNpYWxseSBpZiB0aGUgdXNlciBzZXQgdGhlIGBjbGlja091dHNpZGVEZWFjdGl2YXRlczogdHJ1ZWAgb3B0aW9uIG9uIHRoZSB0cmFwLFxuICAgICAgLy8gIGFuZCB0aGUgbW91c2Ugd2FzIGNsaWNrZWQgb24gc29tZSBlbGVtZW50IG91dHNpZGUgdGhlIHRyYXA7IGF0IHRoYXQgcG9pbnQsIGZvY3VzLXRyYXBcbiAgICAgIC8vICB3aWxsIGluaXRpYXRlIGl0cyBhdXRvLWRlYWN0aXZhdGlvbiBwcm9jZXNzLCB3aGljaCB3aWxsIGNhbGwgb3VyIG93blxuICAgICAgLy8gIGhhbmRsZURlYWN0aXZhdGUoKSwgd2hpY2ggd2lsbCBjYWxsIGludG8gdGhpcyBtZXRob2RcbiAgICAgIGlmICghdGhpcy5mb2N1c1RyYXAgfHwgIXRoaXMuZm9jdXNUcmFwLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZm9jdXNUcmFwLmRlYWN0aXZhdGUoe1xuICAgICAgICAvLyBOT1RFOiB3ZSBuZXZlciBsZXQgdGhlIHRyYXAgcmV0dXJuIHRoZSBmb2N1cyBzaW5jZSB3ZSBkbyB0aGF0IG91cnNlbHZlc1xuICAgICAgICByZXR1cm5Gb2N1czogZmFsc2UsXG4gICAgICAgIC8vIHdlJ2xsIGNhbGwgdGhpcyBpbiBvdXIgb3duIHBvc3QgZGVhY3RpdmF0ZSBoYW5kbGVyIHNvIG1ha2Ugc3VyZSB0aGUgdHJhcCBkb2Vzbid0XG4gICAgICAgIC8vICBkbyBpdCBwcmVtYXR1cmVseVxuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzOiBudWxsLFxuICAgICAgICAvLyBsZXQgaXQgY2FsbCB0aGUgdXNlcidzIG9yaWdpbmFsIGRlYWN0aXZhdGUgaGFuZGxlciwgaWYgYW55LCBpbnN0ZWFkIG9mXG4gICAgICAgIC8vICBvdXIgb3duIHdoaWNoIGNhbGxzIGJhY2sgaW50byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIG9uRGVhY3RpdmF0ZTogdGhpcy5vcmlnaW5hbE9wdGlvbnMub25EZWFjdGl2YXRlIC8vIE5PVEU6IGZvciBwb3N0IGRlYWN0aXZhdGUsIGRvbid0IHNwZWNpZnkgYW55dGhpbmcgc28gdGhhdCBpdCBjYWxscyB0aGVcbiAgICAgICAgLy8gIG9uUG9zdERlYWN0aXZhdGUgaGFuZGxlciBzcGVjaWZpZWQgb24gYHRoaXMuaW50ZXJuYWxPcHRpb25zYFxuICAgICAgICAvLyAgd2hpY2ggd2lsbCBhbHdheXMgYmUgb3VyIG93biBgaGFuZGxlUG9zdERlYWN0aXZhdGUoKWAgaGFuZGxlciwgd2hpY2hcbiAgICAgICAgLy8gIHdpbGwgZmluaXNoIHRoaW5ncyBvZmYgYnkgY2FsbGluZyB0aGUgdXNlcidzIHByb3ZpZGVkIG9uUG9zdERlYWN0aXZhdGVcbiAgICAgICAgLy8gIGhhbmRsZXIsIGlmIGFueSwgYXQgdGhlIHJpZ2h0IHRpbWVcbiAgICAgICAgLy8gb25Qb3N0RGVhY3RpdmF0ZTogTk9USElOR1xuXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMoZXZlbnQpIHtcbiAgICAgIC8vIHVzZSBjb25zdW1lcidzIG9wdGlvbiAob3IgY2FsbCB0aGVpciBoYW5kbGVyKSBhcyB0aGUgcGVybWlzc2lvbiBvciBkZW5pYWxcbiAgICAgIHZhciBhbGxvd0RlYWN0aXZhdGlvbiA9IHR5cGVvZiB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jbGlja091dHNpZGVEZWFjdGl2YXRlcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMub3JpZ2luYWxPcHRpb25zLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzLmNhbGwobnVsbCwgZXZlbnQpIC8vIGNhbGwgb3V0IG9mIGNvbnRleHRcbiAgICAgIDogdGhpcy5vcmlnaW5hbE9wdGlvbnMuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXM7IC8vIGJvb2xlYW5cblxuICAgICAgaWYgKGFsbG93RGVhY3RpdmF0aW9uKSB7XG4gICAgICAgIC8vIGNhcHR1cmUgdGhlIG91dHNpZGUgdGFyZ2V0IHRoYXQgd2FzIGNsaWNrZWQgc28gd2UgY2FuIHVzZSBpdCBpbiB0aGUgZGVhY3RpdmF0aW9uXG4gICAgICAgIC8vICBwcm9jZXNzIHNpbmNlIHRoZSBjb25zdW1lciBhbGxvd2VkIGl0IHRvIGNhdXNlIGF1dG8tZGVhY3RpdmF0aW9uXG4gICAgICAgIHRoaXMub3V0c2lkZUNsaWNrID0ge1xuICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgIGFsbG93RGVhY3RpdmF0aW9uOiBhbGxvd0RlYWN0aXZhdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsb3dEZWFjdGl2YXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURlYWN0aXZhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRGVhY3RpdmF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9yaWdpbmFsT3B0aW9ucy5vbkRlYWN0aXZhdGUpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE9wdGlvbnMub25EZWFjdGl2YXRlLmNhbGwobnVsbCk7IC8vIGNhbGwgdXNlcidzIGhhbmRsZXIgb3V0IG9mIGNvbnRleHRcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZWFjdGl2YXRlVHJhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVQb3N0RGVhY3RpdmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVQb3N0RGVhY3RpdmF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZmluaXNoRGVhY3RpdmF0aW9uID0gZnVuY3Rpb24gZmluaXNoRGVhY3RpdmF0aW9uKCkge1xuICAgICAgICB2YXIgcmV0dXJuRm9jdXNOb2RlID0gX3RoaXMyLmdldFJldHVybkZvY3VzTm9kZSgpO1xuXG4gICAgICAgIHZhciBjYW5SZXR1cm5Gb2N1cyA9ICEhKCAvLyBkaWQgdGhlIGNvbnN1bWVyIGFsbG93IGl0P1xuICAgICAgICBfdGhpczIub3JpZ2luYWxPcHRpb25zLnJldHVybkZvY3VzT25EZWFjdGl2YXRlICYmIC8vIGNhbiB3ZSBhY3R1YWxseSBmb2N1cyB0aGUgbm9kZT9cbiAgICAgICAgcmV0dXJuRm9jdXNOb2RlICE9PSBudWxsICYmIHJldHVybkZvY3VzTm9kZSAhPT0gdm9pZCAwICYmIHJldHVybkZvY3VzTm9kZS5mb2N1cyAmJiAoIC8vIHdhcyB0aGVyZSBhbiBvdXRzaWRlIGNsaWNrIHRoYXQgYWxsb3dlZCBkZWFjdGl2YXRpb24/XG4gICAgICAgICFfdGhpczIub3V0c2lkZUNsaWNrIHx8IC8vIGRpZCB0aGUgY29uc3VtZXIgYWxsb3cgZGVhY3RpdmF0aW9uIHdoZW4gdGhlIG91dHNpZGUgbm9kZSB3YXMgY2xpY2tlZD9cbiAgICAgICAgX3RoaXMyLm91dHNpZGVDbGljay5hbGxvd0RlYWN0aXZhdGlvbiAmJiAvLyBpcyB0aGUgb3V0c2lkZSBub2RlIE5PVCBmb2N1c2FibGUgKGltcGx5aW5nIHRoYXQgaXQgZGlkIE5PVCByZWNlaXZlIGZvY3VzXG4gICAgICAgIC8vICBhcyBhIHJlc3VsdCBvZiB0aGUgY2xpY2stdGhyb3VnaCkgLS0gaW4gd2hpY2ggY2FzZSBkbyBOT1QgcmVzdG9yZSBmb2N1c1xuICAgICAgICAvLyAgdG8gYHJldHVybkZvY3VzTm9kZWAgYmVjYXVzZSBmb2N1cyBzaG91bGQgcmVtYWluIG9uIHRoZSBvdXRzaWRlIG5vZGVcbiAgICAgICAgIWlzRm9jdXNhYmxlKF90aGlzMi5vdXRzaWRlQ2xpY2sudGFyZ2V0LCBfdGhpczIuaW50ZXJuYWxPcHRpb25zLnRhYmJhYmxlT3B0aW9ucykpIC8vIGlmIG5vLCB0aGUgcmVzdG9yZSBmb2N1cyB0byBgcmV0dXJuRm9jdXNOb2RlYCBhdCB0aGlzIHBvaW50XG4gICAgICAgICk7XG4gICAgICAgIHZhciBfdGhpczIkaW50ZXJuYWxPcHRpb24gPSBfdGhpczIuaW50ZXJuYWxPcHRpb25zLnByZXZlbnRTY3JvbGwsXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsID0gX3RoaXMyJGludGVybmFsT3B0aW9uID09PSB2b2lkIDAgPyBmYWxzZSA6IF90aGlzMiRpbnRlcm5hbE9wdGlvbjtcblxuICAgICAgICBpZiAoY2FuUmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAvLyByZXR1cm4gZm9jdXMgdG8gdGhlIGVsZW1lbnQgdGhhdCBoYWQgZm9jdXMgd2hlbiB0aGUgdHJhcCB3YXMgYWN0aXZhdGVkXG4gICAgICAgICAgcmV0dXJuRm9jdXNOb2RlLmZvY3VzKHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHByZXZlbnRTY3JvbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczIub3JpZ2luYWxPcHRpb25zLm9uUG9zdERlYWN0aXZhdGUpIHtcbiAgICAgICAgICBfdGhpczIub3JpZ2luYWxPcHRpb25zLm9uUG9zdERlYWN0aXZhdGUuY2FsbChudWxsKTsgLy8gZG9uJ3QgY2FsbCBpdCBpbiBjb250ZXh0IG9mIFwidGhpc1wiXG5cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5vdXRzaWRlQ2xpY2sgPSBudWxsOyAvLyByZXNldDogbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3JpZ2luYWxPcHRpb25zLmNoZWNrQ2FuUmV0dXJuRm9jdXMpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE9wdGlvbnMuY2hlY2tDYW5SZXR1cm5Gb2N1cy5jYWxsKG51bGwsIHRoaXMuZ2V0UmV0dXJuRm9jdXNOb2RlKCkpIC8vIGNhbGwgb3V0IG9mIGNvbnRleHRcbiAgICAgICAgLnRoZW4oZmluaXNoRGVhY3RpdmF0aW9uLCBmaW5pc2hEZWFjdGl2YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoRGVhY3RpdmF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwRm9jdXNUcmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwRm9jdXNUcmFwKCkge1xuICAgICAgaWYgKHRoaXMuZm9jdXNUcmFwKSB7XG4gICAgICAgIC8vIHRyYXAgYWxyZWFkeSBleGlzdHM6IGl0J3MgcG9zc2libGUgd2UncmUgaW4gU3RyaWN0TW9kZSBhbmQgd2UncmUgYmVpbmcgcmVtb3VudGVkLFxuICAgICAgICAvLyAgaW4gd2hpY2ggY2FzZSwgd2Ugd2lsbCBoYXZlIGRlYWN0aXZhdGVkIHRoZSB0cmFwIHdoZW4gd2UgZ290IHVubW91bnRlZCAocmVtZW1iZXIsXG4gICAgICAgIC8vICBTdHJpY3RNb2RlLCBpbiBkZXZlbG9wbWVudCwgcHVycG9zZWx5IHVubW91bnRzIGFuZCByZW1vdW50cyBjb21wb25lbnRzIGFmdGVyXG4gICAgICAgIC8vICBtb3VudGluZyB0aGVtIHRoZSBmaXJzdCB0aW1lIHRvIG1ha2Ugc3VyZSB0aGV5IGhhdmUgcmV1c2FibGUgc3RhdGUsXG4gICAgICAgIC8vICBAc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9zdHJpY3QtbW9kZS5odG1sI2Vuc3VyaW5nLXJldXNhYmxlLXN0YXRlKSBzbyBub3dcbiAgICAgICAgLy8gIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgdGhlIHRyYXAgYWNjb3JkaW5nIHRvIG91ciBjb21wb25lbnQgc3RhdGVcbiAgICAgICAgLy8gTk9URTogU3RyaWN0IG1vZGUgX192aW9sYXRlc19fIGFzc3VtcHRpb25zIGFib3V0IHRoZSBgY29tcG9uZW50V2lsbFVubW91bnQoKWAgQVBJXG4gICAgICAgIC8vICB3aGljaCBjbGVhcmx5IHN0YXRlcyAtLSBldmVuIGZvciBSZWFjdCAxOCAtLSB0aGF0LCBcIk9uY2UgYSBjb21wb25lbnQgaW5zdGFuY2UgaXNcbiAgICAgICAgLy8gIHVubW91bnRlZCwgX19pdCB3aWxsIG5ldmVyIGJlIG1vdW50ZWQgYWdhaW4uX19cIiAoZW1waGFzaXMgb3VycykuIFNvIHdoZW4gd2UgZ2V0XG4gICAgICAgIC8vICB1bm1vdW50ZWQsIHdlIGFzc3VtZSB3ZSdyZSBnb25lIGZvcmV2ZXIgYW5kIHdlIGRlYWN0aXZhdGUgdGhlIHRyYXAuIEJ1dCB0aGVuXG4gICAgICAgIC8vICB3ZSBnZXQgcmVtb3VudGVkIGFuZCB3ZSdyZSBzdXBwb3NlZCB0byByZXN0b3JlIHN0YXRlLiBCdXQgaWYgeW91IGhhZCBwYXVzZWQsXG4gICAgICAgIC8vICB3ZSd2ZSBub3cgZGVhY3RpdmF0ZWQgKHdlIGRvbid0IGtub3cgd2UncmUgYW1vdW50IHRvIGdldCByZW1vdW50ZWQgYWdhaW4pXG4gICAgICAgIC8vICB3aGljaCBtZWFucyB3ZSBuZWVkIHRvIHJlYWN0aXZhdGUgYW5kIHRoZW4gcGF1c2UuIE90aGVyd2lzZSwgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlICYmICF0aGlzLmZvY3VzVHJhcC5hY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5wYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGVzRXhpc3QgPSB0aGlzLmZvY3VzVHJhcEVsZW1lbnRzLnNvbWUoQm9vbGVhbik7XG5cbiAgICAgICAgaWYgKG5vZGVzRXhpc3QpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJvcC10eXBlcyAtLSBfY3JlYXRlRm9jdXNUcmFwIGlzIGFuIGludGVybmFsIHByb3BcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcCA9IHRoaXMucHJvcHMuX2NyZWF0ZUZvY3VzVHJhcCh0aGlzLmZvY3VzVHJhcEVsZW1lbnRzLCB0aGlzLmludGVybmFsT3B0aW9ucyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5wYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLnNldHVwRm9jdXNUcmFwKCk7XG4gICAgICB9IC8vIGVsc2UsIHdhaXQgZm9yIGxhdGVyIGFjdGl2YXRpb24gaW4gY2FzZSB0aGUgYGZvY3VzVHJhcE9wdGlvbnNgIHdpbGwgYmUgdXBkYXRlZFxuICAgICAgLy8gIGFnYWluIGJlZm9yZSB0aGUgdHJhcCBpcyBhY3RpdmF0ZWQgKGUuZy4gaWYgd2FpdGluZyB0byBrbm93IHdoYXQgdGhlIGRvY3VtZW50XG4gICAgICAvLyAgb2JqZWN0IHdpbGwgYmUsIHNvIHRoZSBUcmFwIG11c3QgYmUgcmVuZGVyZWQsIGJ1dCB0aGUgY29uc3VtZXIgaXMgd2FpdGluZyB0b1xuICAgICAgLy8gIGFjdGl2YXRlIHVudGlsIHRoZXkgaGF2ZSBvYnRhaW5lZCB0aGUgZG9jdW1lbnQgZnJvbSBhIHJlZilcbiAgICAgIC8vICBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAtcmVhY3QvaXNzdWVzLzUzOVxuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5mb2N1c1RyYXApIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5jb250YWluZXJFbGVtZW50cyAhPT0gdGhpcy5wcm9wcy5jb250YWluZXJFbGVtZW50cykge1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzKHRoaXMucHJvcHMuY29udGFpbmVyRWxlbWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhc0FjdGl2YXRlZCA9ICFwcmV2UHJvcHMuYWN0aXZlICYmIHRoaXMucHJvcHMuYWN0aXZlO1xuICAgICAgICB2YXIgaGFzRGVhY3RpdmF0ZWQgPSBwcmV2UHJvcHMuYWN0aXZlICYmICF0aGlzLnByb3BzLmFjdGl2ZTtcbiAgICAgICAgdmFyIGhhc1BhdXNlZCA9ICFwcmV2UHJvcHMucGF1c2VkICYmIHRoaXMucHJvcHMucGF1c2VkO1xuICAgICAgICB2YXIgaGFzVW5wYXVzZWQgPSBwcmV2UHJvcHMucGF1c2VkICYmICF0aGlzLnByb3BzLnBhdXNlZDtcblxuICAgICAgICBpZiAoaGFzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQcmV2aW91c0VsZW1lbnQoKTtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgICAgdGhpcy5kZWFjdGl2YXRlVHJhcCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gdW4vcGF1c2UgZG9lcyBub3RoaW5nIG9uIGFuIGluYWN0aXZlIHRyYXBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNQYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5wYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1VucGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAudW5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOT1RFOiBpZiB3ZSdyZSBpbiBgY29tcG9uZW50RGlkVXBkYXRlYCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIHRyYXAgeWV0LFxuICAgICAgICAvLyAgaXQgZWl0aGVyIG1lYW5zIGl0IHNob3VsZG4ndCBiZSBhY3RpdmUsIG9yIGl0IHNob3VsZCBiZSBidXQgbm9uZSBvZlxuICAgICAgICAvLyAgb2YgZ2l2ZW4gYGNvbnRhaW5lckVsZW1lbnRzYCB3ZXJlIHByZXNlbnQgaW4gdGhlIERPTSB0aGUgbGFzdCB0aW1lXG4gICAgICAgIC8vICB3ZSB0cmllZCB0byBjcmVhdGUgdGhlIHRyYXBcbiAgICAgICAgaWYgKHByZXZQcm9wcy5jb250YWluZXJFbGVtZW50cyAhPT0gdGhpcy5wcm9wcy5jb250YWluZXJFbGVtZW50cykge1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwRWxlbWVudHMgPSB0aGlzLnByb3BzLmNvbnRhaW5lckVsZW1lbnRzO1xuICAgICAgICB9IC8vIGRvbid0IGNyZWF0ZSB0aGUgdHJhcCB1bmxlc3MgaXQgc2hvdWxkIGJlIGFjdGl2ZSBpbiBjYXNlIHRoZSBjb25zdW1lclxuICAgICAgICAvLyAgaXMgc3RpbGwgdXBkYXRpbmcgYGZvY3VzVHJhcE9wdGlvbnNgXG4gICAgICAgIC8vICBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAtcmVhY3QvaXNzdWVzLzUzOVxuXG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQcmV2aW91c0VsZW1lbnQoKTtcbiAgICAgICAgICB0aGlzLnNldHVwRm9jdXNUcmFwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGVUcmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5wcm9wcy5jaGlsZHJlbiA/IFJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbikgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBmb2N1cy10cmFwIGNhbm5vdCB1c2UgYSBGcmFnbWVudCBhcyBpdHMgY2hpbGQgY29udGFpbmVyLiBUcnkgcmVwbGFjaW5nIGl0IHdpdGggYSA8ZGl2PiBlbGVtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrUmVmID0gZnVuY3Rpb24gY2FsbGJhY2tSZWYoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBjb250YWluZXJFbGVtZW50cyA9IF90aGlzMy5wcm9wcy5jb250YWluZXJFbGVtZW50cztcblxuICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY2hpbGQucmVmKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5yZWYpIHtcbiAgICAgICAgICAgICAgY2hpbGQucmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMy5mb2N1c1RyYXBFbGVtZW50cyA9IGNvbnRhaW5lckVsZW1lbnRzID8gY29udGFpbmVyRWxlbWVudHMgOiBbZWxlbWVudF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNoaWxkV2l0aFJlZiA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgIHJlZjogY2FsbGJhY2tSZWZcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGlsZFdpdGhSZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb2N1c1RyYXA7XG59KFJlYWN0LkNvbXBvbmVudCk7IC8vIHN1cHBvcnQgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdoZXJlIGBFbGVtZW50YCB3aWxsIG5vdCBiZSBkZWZpbmVkXG5cblxudmFyIEVsZW1lbnRUeXBlID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gRnVuY3Rpb24gOiBFbGVtZW50O1xuRm9jdXNUcmFwLnByb3BUeXBlcyA9IHtcbiAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgcGF1c2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgZm9jdXNUcmFwT3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBkb2N1bWVudDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvbkFjdGl2YXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBvc3RBY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hlY2tDYW5Gb2N1c1RyYXA6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVhY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Qb3N0RGVhY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hlY2tDYW5SZXR1cm5Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaW5pdGlhbEZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGZhbGxiYWNrRm9jdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5pbnN0YW5jZU9mKEVsZW1lbnRUeXBlKSwgUHJvcFR5cGVzLnN0cmluZywgLy8gTk9URTogZG9lcyBub3Qgc3VwcG9ydCBgZmFsc2VgIGFzIHZhbHVlIChvciByZXR1cm4gdmFsdWUgZnJvbSBmdW5jdGlvbilcbiAgICBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVzY2FwZURlYWN0aXZhdGVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IFByb3BUeXBlcy5ib29sLFxuICAgIHNldFJldHVybkZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGFsbG93T3V0c2lkZUNsaWNrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBwcmV2ZW50U2Nyb2xsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB0YWJiYWJsZU9wdGlvbnM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBkaXNwbGF5Q2hlY2s6IFByb3BUeXBlcy5vbmVPZihbJ2Z1bGwnLCAnbm9uLXplcm8tYXJlYScsICdub25lJ10pLFxuICAgICAgZ2V0U2hhZG93Um9vdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSlcbiAgICB9KVxuICB9KSxcbiAgY29udGFpbmVyRWxlbWVudHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKEVsZW1lbnRUeXBlKSksXG4gIC8vIERPTSBlbGVtZW50IE9OTFlcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50LCAvLyBSZWFjdCBlbGVtZW50XG4gIFByb3BUeXBlcy5pbnN0YW5jZU9mKEVsZW1lbnRUeXBlKSAvLyBET00gZWxlbWVudFxuICBdKSAvLyBOT1RFOiBfY3JlYXRlRm9jdXNUcmFwIGlzIGludGVybmFsLCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LCBzbyB3ZSBkb24ndFxuICAvLyAgc3BlY2lmeSBpdCBoZXJlLiBJdCdzIGV4cGVjdGVkIHRvIGJlIHNldCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbVxuICAvLyAgcmVxdWlyZSgnZm9jdXMtdHJhcCcpLCBvciBvbmUgd2l0aCBhIGNvbXBhdGlibGUgaW50ZXJmYWNlLlxuXG59O1xuRm9jdXNUcmFwLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWN0aXZlOiB0cnVlLFxuICBwYXVzZWQ6IGZhbHNlLFxuICBmb2N1c1RyYXBPcHRpb25zOiB7fSxcbiAgX2NyZWF0ZUZvY3VzVHJhcDogY3JlYXRlRm9jdXNUcmFwXG59O1xubW9kdWxlLmV4cG9ydHMgPSBGb2N1c1RyYXA7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js\n");

/***/ })

};
;