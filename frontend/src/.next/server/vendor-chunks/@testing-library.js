"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@testing-library";
exports.ids = ["vendor-chunks/@testing-library"];
exports.modules = {

/***/ "(ssr)/./node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildQueries: () => (/* binding */ buildQueries),\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   createEvent: () => (/* binding */ createEvent),\n/* harmony export */   findAllByAltText: () => (/* binding */ findAllByAltText),\n/* harmony export */   findAllByDisplayValue: () => (/* binding */ findAllByDisplayValue),\n/* harmony export */   findAllByLabelText: () => (/* binding */ findAllByLabelText),\n/* harmony export */   findAllByPlaceholderText: () => (/* binding */ findAllByPlaceholderText),\n/* harmony export */   findAllByRole: () => (/* binding */ findAllByRole),\n/* harmony export */   findAllByTestId: () => (/* binding */ findAllByTestId),\n/* harmony export */   findAllByText: () => (/* binding */ findAllByText),\n/* harmony export */   findAllByTitle: () => (/* binding */ findAllByTitle),\n/* harmony export */   findByAltText: () => (/* binding */ findByAltText),\n/* harmony export */   findByDisplayValue: () => (/* binding */ findByDisplayValue),\n/* harmony export */   findByLabelText: () => (/* binding */ findByLabelText),\n/* harmony export */   findByPlaceholderText: () => (/* binding */ findByPlaceholderText),\n/* harmony export */   findByRole: () => (/* binding */ findByRole),\n/* harmony export */   findByTestId: () => (/* binding */ findByTestId),\n/* harmony export */   findByText: () => (/* binding */ findByText),\n/* harmony export */   findByTitle: () => (/* binding */ findByTitle),\n/* harmony export */   fireEvent: () => (/* binding */ fireEvent),\n/* harmony export */   getAllByAltText: () => (/* binding */ getAllByAltText),\n/* harmony export */   getAllByDisplayValue: () => (/* binding */ getAllByDisplayValue),\n/* harmony export */   getAllByLabelText: () => (/* binding */ getAllByLabelTextWithSuggestions),\n/* harmony export */   getAllByPlaceholderText: () => (/* binding */ getAllByPlaceholderText),\n/* harmony export */   getAllByRole: () => (/* binding */ getAllByRole),\n/* harmony export */   getAllByTestId: () => (/* binding */ getAllByTestId),\n/* harmony export */   getAllByText: () => (/* binding */ getAllByText),\n/* harmony export */   getAllByTitle: () => (/* binding */ getAllByTitle),\n/* harmony export */   getByAltText: () => (/* binding */ getByAltText),\n/* harmony export */   getByDisplayValue: () => (/* binding */ getByDisplayValue),\n/* harmony export */   getByLabelText: () => (/* binding */ getByLabelTextWithSuggestions),\n/* harmony export */   getByPlaceholderText: () => (/* binding */ getByPlaceholderText),\n/* harmony export */   getByRole: () => (/* binding */ getByRole),\n/* harmony export */   getByTestId: () => (/* binding */ getByTestId),\n/* harmony export */   getByText: () => (/* binding */ getByText),\n/* harmony export */   getByTitle: () => (/* binding */ getByTitle),\n/* harmony export */   getConfig: () => (/* binding */ getConfig),\n/* harmony export */   getDefaultNormalizer: () => (/* binding */ getDefaultNormalizer),\n/* harmony export */   getElementError: () => (/* binding */ getElementError),\n/* harmony export */   getMultipleElementsFoundError: () => (/* binding */ getMultipleElementsFoundError),\n/* harmony export */   getNodeText: () => (/* binding */ getNodeText),\n/* harmony export */   getQueriesForElement: () => (/* binding */ getQueriesForElement),\n/* harmony export */   getRoles: () => (/* binding */ getRoles),\n/* harmony export */   getSuggestedQuery: () => (/* binding */ getSuggestedQuery),\n/* harmony export */   isInaccessible: () => (/* binding */ isInaccessible),\n/* harmony export */   logDOM: () => (/* binding */ logDOM),\n/* harmony export */   logRoles: () => (/* binding */ logRoles),\n/* harmony export */   makeFindQuery: () => (/* binding */ makeFindQuery),\n/* harmony export */   makeGetAllQuery: () => (/* binding */ makeGetAllQuery),\n/* harmony export */   makeSingleQuery: () => (/* binding */ makeSingleQuery),\n/* harmony export */   prettyDOM: () => (/* binding */ prettyDOM),\n/* harmony export */   prettyFormat: () => (/* reexport module object */ pretty_format__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   queries: () => (/* binding */ queries),\n/* harmony export */   queryAllByAltText: () => (/* binding */ queryAllByAltTextWithSuggestions),\n/* harmony export */   queryAllByAttribute: () => (/* binding */ queryAllByAttribute),\n/* harmony export */   queryAllByDisplayValue: () => (/* binding */ queryAllByDisplayValueWithSuggestions),\n/* harmony export */   queryAllByLabelText: () => (/* binding */ queryAllByLabelTextWithSuggestions),\n/* harmony export */   queryAllByPlaceholderText: () => (/* binding */ queryAllByPlaceholderTextWithSuggestions),\n/* harmony export */   queryAllByRole: () => (/* binding */ queryAllByRoleWithSuggestions),\n/* harmony export */   queryAllByTestId: () => (/* binding */ queryAllByTestIdWithSuggestions),\n/* harmony export */   queryAllByText: () => (/* binding */ queryAllByTextWithSuggestions),\n/* harmony export */   queryAllByTitle: () => (/* binding */ queryAllByTitleWithSuggestions),\n/* harmony export */   queryByAltText: () => (/* binding */ queryByAltText),\n/* harmony export */   queryByAttribute: () => (/* binding */ queryByAttribute),\n/* harmony export */   queryByDisplayValue: () => (/* binding */ queryByDisplayValue),\n/* harmony export */   queryByLabelText: () => (/* binding */ queryByLabelText),\n/* harmony export */   queryByPlaceholderText: () => (/* binding */ queryByPlaceholderText),\n/* harmony export */   queryByRole: () => (/* binding */ queryByRole),\n/* harmony export */   queryByTestId: () => (/* binding */ queryByTestId),\n/* harmony export */   queryByText: () => (/* binding */ queryByText),\n/* harmony export */   queryByTitle: () => (/* binding */ queryByTitle),\n/* harmony export */   queryHelpers: () => (/* binding */ queryHelpers),\n/* harmony export */   screen: () => (/* binding */ screen),\n/* harmony export */   waitFor: () => (/* binding */ waitForWrapper),\n/* harmony export */   waitForElementToBeRemoved: () => (/* binding */ waitForElementToBeRemoved),\n/* harmony export */   within: () => (/* binding */ getQueriesForElement),\n/* harmony export */   wrapAllByQueryWithSuggestion: () => (/* binding */ wrapAllByQueryWithSuggestion),\n/* harmony export */   wrapSingleQueryWithSuggestion: () => (/* binding */ wrapSingleQueryWithSuggestion)\n/* harmony export */ });\n/* harmony import */ var pretty_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pretty-format */ \"(ssr)/./node_modules/pretty-format/build/index.js\");\n/* harmony import */ var dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dom-accessibility-api */ \"(ssr)/./node_modules/dom-accessibility-api/dist/index.mjs\");\n/* harmony import */ var aria_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aria-query */ \"(ssr)/./node_modules/aria-query/lib/index.js\");\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lz-string */ \"(ssr)/./node_modules/lz-string/libs/lz-string.js\");\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lz_string__WEBPACK_IMPORTED_MODULE_3__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\n\n/**\n * Source: https://github.com/facebook/jest/blob/e7bb6a1e26ffab90611b2593912df15b69315611/packages/pretty-format/src/plugins/DOMElement.ts\n */\n/* eslint-disable -- trying to stay as close to the original as possible */\n/* istanbul ignore file */\n\nfunction escapeHTML(str) {\n  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n// Return empty string if keys is empty.\nconst printProps = (keys, props, config, indentation, depth, refs, printer) => {\n  const indentationNext = indentation + config.indent;\n  const colors = config.colors;\n  return keys.map(key => {\n    const value = props[key];\n    let printed = printer(value, config, indentationNext, depth, refs);\n    if (typeof value !== 'string') {\n      if (printed.indexOf('\\n') !== -1) {\n        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;\n      }\n      printed = '{' + printed + '}';\n    }\n    return config.spacingInner + indentation + colors.prop.open + key + colors.prop.close + '=' + colors.value.open + printed + colors.value.close;\n  }).join('');\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node_type_constants\nconst NodeTypeTextNode = 3;\n\n// Return empty string if children is empty.\nconst printChildren = (children, config, indentation, depth, refs, printer) => children.map(child => {\n  const printedChild = typeof child === 'string' ? printText(child, config) : printer(child, config, indentation, depth, refs);\n  if (printedChild === '' && typeof child === 'object' && child !== null && child.nodeType !== NodeTypeTextNode) {\n    // A plugin serialized this Node to '' meaning we should ignore it.\n    return '';\n  }\n  return config.spacingOuter + indentation + printedChild;\n}).join('');\nconst printText = (text, config) => {\n  const contentColor = config.colors.content;\n  return contentColor.open + escapeHTML(text) + contentColor.close;\n};\nconst printComment = (comment, config) => {\n  const commentColor = config.colors.comment;\n  return commentColor.open + '<!--' + escapeHTML(comment) + '-->' + commentColor.close;\n};\n\n// Separate the functions to format props, children, and element,\n// so a plugin could override a particular function, if needed.\n// Too bad, so sad: the traditional (but unnecessary) space\n// in a self-closing tagColor requires a second test of printedProps.\nconst printElement = (type, printedProps, printedChildren, config, indentation) => {\n  const tagColor = config.colors.tag;\n  return tagColor.open + '<' + type + (printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open) + (printedChildren ? '>' + tagColor.close + printedChildren + config.spacingOuter + indentation + tagColor.open + '</' + type : (printedProps && !config.min ? '' : ' ') + '/') + '>' + tagColor.close;\n};\nconst printElementAsLeaf = (type, config) => {\n  const tagColor = config.colors.tag;\n  return tagColor.open + '<' + type + tagColor.close + ' …' + tagColor.open + ' />' + tagColor.close;\n};\nconst ELEMENT_NODE$1 = 1;\nconst TEXT_NODE$1 = 3;\nconst COMMENT_NODE$1 = 8;\nconst FRAGMENT_NODE = 11;\nconst ELEMENT_REGEXP = /^((HTML|SVG)\\w*)?Element$/;\nconst testNode = val => {\n  const constructorName = val.constructor.name;\n  const {\n    nodeType,\n    tagName\n  } = val;\n  const isCustomElement = typeof tagName === 'string' && tagName.includes('-') || typeof val.hasAttribute === 'function' && val.hasAttribute('is');\n  return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE$1 && constructorName === 'Text' || nodeType === COMMENT_NODE$1 && constructorName === 'Comment' || nodeType === FRAGMENT_NODE && constructorName === 'DocumentFragment';\n};\nfunction nodeIsText(node) {\n  return node.nodeType === TEXT_NODE$1;\n}\nfunction nodeIsComment(node) {\n  return node.nodeType === COMMENT_NODE$1;\n}\nfunction nodeIsFragment(node) {\n  return node.nodeType === FRAGMENT_NODE;\n}\nfunction createDOMElementFilter(filterNode) {\n  return {\n    test: val => {\n      var _val$constructor2;\n      return (val == null ? void 0 : (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) && testNode(val);\n    },\n    serialize: (node, config, indentation, depth, refs, printer) => {\n      if (nodeIsText(node)) {\n        return printText(node.data, config);\n      }\n      if (nodeIsComment(node)) {\n        return printComment(node.data, config);\n      }\n      const type = nodeIsFragment(node) ? \"DocumentFragment\" : node.tagName.toLowerCase();\n      if (++depth > config.maxDepth) {\n        return printElementAsLeaf(type, config);\n      }\n      return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes).map(attr => attr.name).sort(), nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {\n        props[attribute.name] = attribute.value;\n        return props;\n      }, {}), config, indentation + config.indent, depth, refs, printer), printChildren(Array.prototype.slice.call(node.childNodes || node.children).filter(filterNode), config, indentation + config.indent, depth, refs, printer), config, indentation);\n    }\n  };\n}\n\n// We try to load node dependencies\nlet chalk = null;\nlet readFileSync = null;\nlet codeFrameColumns = null;\ntry {\n  const nodeRequire = module && module.require;\n  readFileSync = nodeRequire.call(module, 'fs').readFileSync;\n  codeFrameColumns = nodeRequire.call(module, '@babel/code-frame').codeFrameColumns;\n  chalk = nodeRequire.call(module, 'chalk');\n} catch {\n  // We're in a browser environment\n}\n\n// frame has the form \"at myMethod (location/to/my/file.js:10:2)\"\nfunction getCodeFrame(frame) {\n  const locationStart = frame.indexOf('(') + 1;\n  const locationEnd = frame.indexOf(')');\n  const frameLocation = frame.slice(locationStart, locationEnd);\n  const frameLocationElements = frameLocation.split(':');\n  const [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];\n  let rawFileContents = '';\n  try {\n    rawFileContents = readFileSync(filename, 'utf-8');\n  } catch {\n    return '';\n  }\n  const codeFrame = codeFrameColumns(rawFileContents, {\n    start: {\n      line,\n      column\n    }\n  }, {\n    highlightCode: true,\n    linesBelow: 0\n  });\n  return chalk.dim(frameLocation) + \"\\n\" + codeFrame + \"\\n\";\n}\nfunction getUserCodeFrame() {\n  // If we couldn't load dependencies, we can't generate the user trace\n  /* istanbul ignore next */\n  if (!readFileSync || !codeFrameColumns) {\n    return '';\n  }\n  const err = new Error();\n  const firstClientCodeFrame = err.stack.split('\\n').slice(1) // Remove first line which has the form \"Error: TypeError\"\n  .find(frame => !frame.includes('node_modules/')); // Ignore frames from 3rd party libraries\n\n  return getCodeFrame(firstClientCodeFrame);\n}\n\n// Constant node.nodeType for text nodes, see:\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#Node_type_constants\nconst TEXT_NODE = 3;\nfunction jestFakeTimersAreEnabled() {\n  /* istanbul ignore else */\n  // eslint-disable-next-line\n  if (typeof jest !== 'undefined' && jest !== null) {\n    return (\n      // legacy timers\n      setTimeout._isMockFunction === true ||\n      // modern timers\n      // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix\n      Object.prototype.hasOwnProperty.call(setTimeout, 'clock')\n    );\n  }\n  // istanbul ignore next\n  return false;\n}\nfunction getDocument() {\n  /* istanbul ignore if */\n  if (typeof window === 'undefined') {\n    throw new Error('Could not find default container');\n  }\n  return window.document;\n}\nfunction getWindowFromNode(node) {\n  if (node.defaultView) {\n    // node is document\n    return node.defaultView;\n  } else if (node.ownerDocument && node.ownerDocument.defaultView) {\n    // node is a DOM node\n    return node.ownerDocument.defaultView;\n  } else if (node.window) {\n    // node is window\n    return node.window;\n  } else if (node.ownerDocument && node.ownerDocument.defaultView === null) {\n    throw new Error(\"It looks like the window object is not available for the provided node.\");\n  } else if (node.then instanceof Function) {\n    throw new Error(\"It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?\");\n  } else if (Array.isArray(node)) {\n    throw new Error(\"It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?\");\n  } else if (typeof node.debug === 'function' && typeof node.logTestingPlaygroundURL === 'function') {\n    throw new Error(\"It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?\");\n  } else {\n    // The user passed something unusual to a calling function\n    throw new Error(\"The given node is not an Element, the node type is: \" + typeof node + \".\");\n  }\n}\nfunction checkContainerType(container) {\n  if (!container || !(typeof container.querySelector === 'function') || !(typeof container.querySelectorAll === 'function')) {\n    throw new TypeError(\"Expected container to be an Element, a Document or a DocumentFragment but got \" + getTypeName(container) + \".\");\n  }\n  function getTypeName(object) {\n    if (typeof object === 'object') {\n      return object === null ? 'null' : object.constructor.name;\n    }\n    return typeof object;\n  }\n}\n\nconst shouldHighlight = () => {\n  let colors;\n  try {\n    var _process, _process$env;\n    colors = JSON.parse((_process = process) == null ? void 0 : (_process$env = _process.env) == null ? void 0 : _process$env.COLORS);\n  } catch (e) {\n    // If this throws, process?.env?.COLORS wasn't parsable. Since we only\n    // care about `true` or `false`, we can safely ignore the error.\n  }\n  if (typeof colors === 'boolean') {\n    // If `colors` is set explicitly (both `true` and `false`), use that value.\n    return colors;\n  } else {\n    // If `colors` is not set, colorize if we're in node.\n    return typeof process !== 'undefined' && process.versions !== undefined && process.versions.node !== undefined;\n  }\n};\nconst {\n  DOMCollection\n} = pretty_format__WEBPACK_IMPORTED_MODULE_0__.plugins;\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node_type_constants\nconst ELEMENT_NODE = 1;\nconst COMMENT_NODE = 8;\n\n// https://github.com/facebook/jest/blob/615084195ae1ae61ddd56162c62bbdda17587569/packages/pretty-format/src/plugins/DOMElement.ts#L50\nfunction filterCommentsAndDefaultIgnoreTagsTags(value) {\n  return value.nodeType !== COMMENT_NODE && (value.nodeType !== ELEMENT_NODE || !value.matches(getConfig().defaultIgnore));\n}\nfunction prettyDOM(dom, maxLength, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (!dom) {\n    dom = getDocument().body;\n  }\n  if (typeof maxLength !== 'number') {\n    maxLength = typeof process !== 'undefined' && process.env.DEBUG_PRINT_LIMIT || 7000;\n  }\n  if (maxLength === 0) {\n    return '';\n  }\n  if (dom.documentElement) {\n    dom = dom.documentElement;\n  }\n  let domTypeName = typeof dom;\n  if (domTypeName === 'object') {\n    domTypeName = dom.constructor.name;\n  } else {\n    // To don't fall with `in` operator\n    dom = {};\n  }\n  if (!('outerHTML' in dom)) {\n    throw new TypeError(\"Expected an element or document but got \" + domTypeName);\n  }\n  const {\n    filterNode = filterCommentsAndDefaultIgnoreTagsTags,\n    ...prettyFormatOptions\n  } = options;\n  const debugContent = pretty_format__WEBPACK_IMPORTED_MODULE_0__.format(dom, {\n    plugins: [createDOMElementFilter(filterNode), DOMCollection],\n    printFunctionName: false,\n    highlight: shouldHighlight(),\n    ...prettyFormatOptions\n  });\n  return maxLength !== undefined && dom.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + \"...\" : debugContent;\n}\nconst logDOM = function () {\n  const userCodeFrame = getUserCodeFrame();\n  if (userCodeFrame) {\n    console.log(prettyDOM(...arguments) + \"\\n\\n\" + userCodeFrame);\n  } else {\n    console.log(prettyDOM(...arguments));\n  }\n};\n\n// It would be cleaner for this to live inside './queries', but\n// other parts of the code assume that all exports from\n// './queries' are query functions.\nlet config = {\n  testIdAttribute: 'data-testid',\n  asyncUtilTimeout: 1000,\n  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.\n  // forcing react-testing-library to wrap all async functions would've been\n  // a total nightmare (consider wrapping every findBy* query and then also\n  // updating `within` so those would be wrapped too. Total nightmare).\n  // so we have this config option that's really only intended for\n  // react-testing-library to use. For that reason, this feature will remain\n  // undocumented.\n  asyncWrapper: cb => cb(),\n  unstable_advanceTimersWrapper: cb => cb(),\n  eventWrapper: cb => cb(),\n  // default value for the `hidden` option in `ByRole` queries\n  defaultHidden: false,\n  // default value for the `ignore` option in `ByText` queries\n  defaultIgnore: 'script, style',\n  // showOriginalStackTrace flag to show the full error stack traces for async errors\n  showOriginalStackTrace: false,\n  // throw errors w/ suggestions for better queries. Opt in so off by default.\n  throwSuggestions: false,\n  // called when getBy* queries fail. (message, container) => Error\n  getElementError(message, container) {\n    const prettifiedDOM = prettyDOM(container);\n    const error = new Error([message, \"Ignored nodes: comments, \" + config.defaultIgnore + \"\\n\" + prettifiedDOM].filter(Boolean).join('\\n\\n'));\n    error.name = 'TestingLibraryElementError';\n    return error;\n  },\n  _disableExpensiveErrorDiagnostics: false,\n  computedStyleSupportsPseudoElements: false\n};\nfunction runWithExpensiveErrorDiagnosticsDisabled(callback) {\n  try {\n    config._disableExpensiveErrorDiagnostics = true;\n    return callback();\n  } finally {\n    config._disableExpensiveErrorDiagnostics = false;\n  }\n}\nfunction configure(newConfig) {\n  if (typeof newConfig === 'function') {\n    // Pass the existing config out to the provided function\n    // and accept a delta in return\n    newConfig = newConfig(config);\n  }\n\n  // Merge the incoming config delta\n  config = {\n    ...config,\n    ...newConfig\n  };\n}\nfunction getConfig() {\n  return config;\n}\n\nconst labelledNodeNames = ['button', 'meter', 'output', 'progress', 'select', 'textarea', 'input'];\nfunction getTextContent(node) {\n  if (labelledNodeNames.includes(node.nodeName.toLowerCase())) {\n    return '';\n  }\n  if (node.nodeType === TEXT_NODE) return node.textContent;\n  return Array.from(node.childNodes).map(childNode => getTextContent(childNode)).join('');\n}\nfunction getLabelContent(element) {\n  let textContent;\n  if (element.tagName.toLowerCase() === 'label') {\n    textContent = getTextContent(element);\n  } else {\n    textContent = element.value || element.textContent;\n  }\n  return textContent;\n}\n\n// Based on https://github.com/eps1lon/dom-accessibility-api/pull/352\nfunction getRealLabels(element) {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- types are not aware of older browsers that don't implement `labels`\n  if (element.labels !== undefined) {\n    var _labels;\n    return (_labels = element.labels) != null ? _labels : [];\n  }\n  if (!isLabelable(element)) return [];\n  const labels = element.ownerDocument.querySelectorAll('label');\n  return Array.from(labels).filter(label => label.control === element);\n}\nfunction isLabelable(element) {\n  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === 'INPUT' && element.getAttribute('type') !== 'hidden';\n}\nfunction getLabels(container, element, _temp) {\n  let {\n    selector = '*'\n  } = _temp === void 0 ? {} : _temp;\n  const ariaLabelledBy = element.getAttribute('aria-labelledby');\n  const labelsId = ariaLabelledBy ? ariaLabelledBy.split(' ') : [];\n  return labelsId.length ? labelsId.map(labelId => {\n    const labellingElement = container.querySelector(\"[id=\\\"\" + labelId + \"\\\"]\");\n    return labellingElement ? {\n      content: getLabelContent(labellingElement),\n      formControl: null\n    } : {\n      content: '',\n      formControl: null\n    };\n  }) : Array.from(getRealLabels(element)).map(label => {\n    const textToMatch = getLabelContent(label);\n    const formControlSelector = 'button, input, meter, output, progress, select, textarea';\n    const labelledFormControl = Array.from(label.querySelectorAll(formControlSelector)).filter(formControlElement => formControlElement.matches(selector))[0];\n    return {\n      content: textToMatch,\n      formControl: labelledFormControl\n    };\n  });\n}\n\nfunction assertNotNullOrUndefined(matcher) {\n  if (matcher === null || matcher === undefined) {\n    throw new Error( // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`\n    \"It looks like \" + matcher + \" was passed instead of a matcher. Did you do something like getByText(\" + matcher + \")?\");\n  }\n}\nfunction fuzzyMatches(textToMatch, node, matcher, normalizer) {\n  if (typeof textToMatch !== 'string') {\n    return false;\n  }\n  assertNotNullOrUndefined(matcher);\n  const normalizedText = normalizer(textToMatch);\n  if (typeof matcher === 'string' || typeof matcher === 'number') {\n    return normalizedText.toLowerCase().includes(matcher.toString().toLowerCase());\n  } else if (typeof matcher === 'function') {\n    return matcher(normalizedText, node);\n  } else {\n    return matchRegExp(matcher, normalizedText);\n  }\n}\nfunction matches(textToMatch, node, matcher, normalizer) {\n  if (typeof textToMatch !== 'string') {\n    return false;\n  }\n  assertNotNullOrUndefined(matcher);\n  const normalizedText = normalizer(textToMatch);\n  if (matcher instanceof Function) {\n    return matcher(normalizedText, node);\n  } else if (matcher instanceof RegExp) {\n    return matchRegExp(matcher, normalizedText);\n  } else {\n    return normalizedText === String(matcher);\n  }\n}\nfunction getDefaultNormalizer(_temp) {\n  let {\n    trim = true,\n    collapseWhitespace = true\n  } = _temp === void 0 ? {} : _temp;\n  return text => {\n    let normalizedText = text;\n    normalizedText = trim ? normalizedText.trim() : normalizedText;\n    normalizedText = collapseWhitespace ? normalizedText.replace(/\\s+/g, ' ') : normalizedText;\n    return normalizedText;\n  };\n}\n\n/**\n * Constructs a normalizer to pass to functions in matches.js\n * @param {boolean|undefined} trim The user-specified value for `trim`, without\n * any defaulting having been applied\n * @param {boolean|undefined} collapseWhitespace The user-specified value for\n * `collapseWhitespace`, without any defaulting having been applied\n * @param {Function|undefined} normalizer The user-specified normalizer\n * @returns {Function} A normalizer\n */\n\nfunction makeNormalizer(_ref) {\n  let {\n    trim,\n    collapseWhitespace,\n    normalizer\n  } = _ref;\n  if (!normalizer) {\n    // No custom normalizer specified. Just use default.\n    return getDefaultNormalizer({\n      trim,\n      collapseWhitespace\n    });\n  }\n  if (typeof trim !== 'undefined' || typeof collapseWhitespace !== 'undefined') {\n    // They've also specified a value for trim or collapseWhitespace\n    throw new Error('trim and collapseWhitespace are not supported with a normalizer. ' + 'If you want to use the default trim and collapseWhitespace logic in your normalizer, ' + 'use \"getDefaultNormalizer({trim, collapseWhitespace})\" and compose that into your normalizer');\n  }\n  return normalizer;\n}\nfunction matchRegExp(matcher, text) {\n  const match = matcher.test(text);\n  if (matcher.global && matcher.lastIndex !== 0) {\n    console.warn(\"To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.\");\n    matcher.lastIndex = 0;\n  }\n  return match;\n}\n\nfunction getNodeText(node) {\n  if (node.matches('input[type=submit], input[type=button], input[type=reset]')) {\n    return node.value;\n  }\n  return Array.from(node.childNodes).filter(child => child.nodeType === TEXT_NODE && Boolean(child.textContent)).map(c => c.textContent).join('');\n}\n\nconst elementRoleList = buildElementRoleList(aria_query__WEBPACK_IMPORTED_MODULE_2__.elementRoles);\n\n/**\n * @param {Element} element -\n * @returns {boolean} - `true` if `element` and its subtree are inaccessible\n */\nfunction isSubtreeInaccessible(element) {\n  if (element.hidden === true) {\n    return true;\n  }\n  if (element.getAttribute('aria-hidden') === 'true') {\n    return true;\n  }\n  const window = element.ownerDocument.defaultView;\n  if (window.getComputedStyle(element).display === 'none') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Partial implementation https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion\n * which should only be used for elements with a non-presentational role i.e.\n * `role=\"none\"` and `role=\"presentation\"` will not be excluded.\n *\n * Implements aria-hidden semantics (i.e. parent overrides child)\n * Ignores \"Child Presentational: True\" characteristics\n *\n * @param {Element} element -\n * @param {object} [options] -\n * @param {function (element: Element): boolean} options.isSubtreeInaccessible -\n * can be used to return cached results from previous isSubtreeInaccessible calls\n * @returns {boolean} true if excluded, otherwise false\n */\nfunction isInaccessible(element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible\n  } = options;\n  const window = element.ownerDocument.defaultView;\n  // since visibility is inherited we can exit early\n  if (window.getComputedStyle(element).visibility === 'hidden') {\n    return true;\n  }\n  let currentElement = element;\n  while (currentElement) {\n    if (isSubtreeInaccessibleImpl(currentElement)) {\n      return true;\n    }\n    currentElement = currentElement.parentElement;\n  }\n  return false;\n}\nfunction getImplicitAriaRoles(currentNode) {\n  // eslint bug here:\n  // eslint-disable-next-line no-unused-vars\n  for (const {\n    match,\n    roles\n  } of elementRoleList) {\n    if (match(currentNode)) {\n      return [...roles];\n    }\n  }\n  return [];\n}\nfunction buildElementRoleList(elementRolesMap) {\n  function makeElementSelector(_ref) {\n    let {\n      name,\n      attributes\n    } = _ref;\n    return \"\" + name + attributes.map(_ref2 => {\n      let {\n        name: attributeName,\n        value,\n        constraints = []\n      } = _ref2;\n      const shouldNotExist = constraints.indexOf('undefined') !== -1;\n      if (shouldNotExist) {\n        return \":not([\" + attributeName + \"])\";\n      } else if (value) {\n        return \"[\" + attributeName + \"=\\\"\" + value + \"\\\"]\";\n      } else {\n        return \"[\" + attributeName + \"]\";\n      }\n    }).join('');\n  }\n  function getSelectorSpecificity(_ref3) {\n    let {\n      attributes = []\n    } = _ref3;\n    return attributes.length;\n  }\n  function bySelectorSpecificity(_ref4, _ref5) {\n    let {\n      specificity: leftSpecificity\n    } = _ref4;\n    let {\n      specificity: rightSpecificity\n    } = _ref5;\n    return rightSpecificity - leftSpecificity;\n  }\n  function match(element) {\n    let {\n      attributes = []\n    } = element;\n\n    // https://github.com/testing-library/dom-testing-library/issues/814\n    const typeTextIndex = attributes.findIndex(attribute => attribute.value && attribute.name === 'type' && attribute.value === 'text');\n    if (typeTextIndex >= 0) {\n      // not using splice to not mutate the attributes array\n      attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)];\n    }\n    const selector = makeElementSelector({\n      ...element,\n      attributes\n    });\n    return node => {\n      if (typeTextIndex >= 0 && node.type !== 'text') {\n        return false;\n      }\n      return node.matches(selector);\n    };\n  }\n  let result = [];\n\n  // eslint bug here:\n  // eslint-disable-next-line no-unused-vars\n  for (const [element, roles] of elementRolesMap.entries()) {\n    result = [...result, {\n      match: match(element),\n      roles: Array.from(roles),\n      specificity: getSelectorSpecificity(element)\n    }];\n  }\n  return result.sort(bySelectorSpecificity);\n}\nfunction getRoles(container, _temp) {\n  let {\n    hidden = false\n  } = _temp === void 0 ? {} : _temp;\n  function flattenDOM(node) {\n    return [node, ...Array.from(node.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];\n  }\n  return flattenDOM(container).filter(element => {\n    return hidden === false ? isInaccessible(element) === false : true;\n  }).reduce((acc, node) => {\n    let roles = [];\n    // TODO: This violates html-aria which does not allow any role on every element\n    if (node.hasAttribute('role')) {\n      roles = node.getAttribute('role').split(' ').slice(0, 1);\n    } else {\n      roles = getImplicitAriaRoles(node);\n    }\n    return roles.reduce((rolesAcc, role) => Array.isArray(rolesAcc[role]) ? {\n      ...rolesAcc,\n      [role]: [...rolesAcc[role], node]\n    } : {\n      ...rolesAcc,\n      [role]: [node]\n    }, acc);\n  }, {});\n}\nfunction prettyRoles(dom, _ref6) {\n  let {\n    hidden,\n    includeDescription\n  } = _ref6;\n  const roles = getRoles(dom, {\n    hidden\n  });\n  // We prefer to skip generic role, we don't recommend it\n  return Object.entries(roles).filter(_ref7 => {\n    let [role] = _ref7;\n    return role !== 'generic';\n  }).map(_ref8 => {\n    let [role, elements] = _ref8;\n    const delimiterBar = '-'.repeat(50);\n    const elementsString = elements.map(el => {\n      const nameString = \"Name \\\"\" + (0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__.computeAccessibleName)(el, {\n        computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n      }) + \"\\\":\\n\";\n      const domString = prettyDOM(el.cloneNode(false));\n      if (includeDescription) {\n        const descriptionString = \"Description \\\"\" + (0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__.computeAccessibleDescription)(el, {\n          computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n        }) + \"\\\":\\n\";\n        return \"\" + nameString + descriptionString + domString;\n      }\n      return \"\" + nameString + domString;\n    }).join('\\n\\n');\n    return role + \":\\n\\n\" + elementsString + \"\\n\\n\" + delimiterBar;\n  }).join('\\n');\n}\nconst logRoles = function (dom, _temp2) {\n  let {\n    hidden = false\n  } = _temp2 === void 0 ? {} : _temp2;\n  return console.log(prettyRoles(dom, {\n    hidden\n  }));\n};\n\n/**\n * @param {Element} element -\n * @returns {boolean | undefined} - false/true if (not)selected, undefined if not selectable\n */\nfunction computeAriaSelected(element) {\n  // implicit value from html-aam mappings: https://www.w3.org/TR/html-aam-1.0/#html-attribute-state-and-property-mappings\n  // https://www.w3.org/TR/html-aam-1.0/#details-id-97\n  if (element.tagName === 'OPTION') {\n    return element.selected;\n  }\n\n  // explicit value\n  return checkBooleanAttribute(element, 'aria-selected');\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean} -\n */\nfunction computeAriaBusy(element) {\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-busy\n  return element.getAttribute('aria-busy') === 'true';\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean | undefined} - false/true if (not)checked, undefined if not checked-able\n */\nfunction computeAriaChecked(element) {\n  // implicit value from html-aam mappings: https://www.w3.org/TR/html-aam-1.0/#html-attribute-state-and-property-mappings\n  // https://www.w3.org/TR/html-aam-1.0/#details-id-56\n  // https://www.w3.org/TR/html-aam-1.0/#details-id-67\n  if ('indeterminate' in element && element.indeterminate) {\n    return undefined;\n  }\n  if ('checked' in element) {\n    return element.checked;\n  }\n\n  // explicit value\n  return checkBooleanAttribute(element, 'aria-checked');\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean | undefined} - false/true if (not)pressed, undefined if not press-able\n */\nfunction computeAriaPressed(element) {\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-pressed\n  return checkBooleanAttribute(element, 'aria-pressed');\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean | string | null} -\n */\nfunction computeAriaCurrent(element) {\n  var _ref9, _checkBooleanAttribut;\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-current\n  return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, 'aria-current')) != null ? _checkBooleanAttribut : element.getAttribute('aria-current')) != null ? _ref9 : false;\n}\n\n/**\n * @param {Element} element -\n * @returns {boolean | undefined} - false/true if (not)expanded, undefined if not expand-able\n */\nfunction computeAriaExpanded(element) {\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-expanded\n  return checkBooleanAttribute(element, 'aria-expanded');\n}\nfunction checkBooleanAttribute(element, attribute) {\n  const attributeValue = element.getAttribute(attribute);\n  if (attributeValue === 'true') {\n    return true;\n  }\n  if (attributeValue === 'false') {\n    return false;\n  }\n  return undefined;\n}\n\n/**\n * @param {Element} element -\n * @returns {number | undefined} - number if implicit heading or aria-level present, otherwise undefined\n */\nfunction computeHeadingLevel(element) {\n  // https://w3c.github.io/html-aam/#el-h1-h6\n  // https://w3c.github.io/html-aam/#el-h1-h6\n  const implicitHeadingLevels = {\n    H1: 1,\n    H2: 2,\n    H3: 3,\n    H4: 4,\n    H5: 5,\n    H6: 6\n  };\n  // explicit aria-level value\n  // https://www.w3.org/TR/wai-aria-1.2/#aria-level\n  const ariaLevelAttribute = element.getAttribute('aria-level') && Number(element.getAttribute('aria-level'));\n  return ariaLevelAttribute || implicitHeadingLevels[element.tagName];\n}\n\n/**\n * @param {Element} element -\n * @returns {number | undefined} -\n */\nfunction computeAriaValueNow(element) {\n  const valueNow = element.getAttribute('aria-valuenow');\n  return valueNow === null ? undefined : +valueNow;\n}\n\n/**\n * @param {Element} element -\n * @returns {number | undefined} -\n */\nfunction computeAriaValueMax(element) {\n  const valueMax = element.getAttribute('aria-valuemax');\n  return valueMax === null ? undefined : +valueMax;\n}\n\n/**\n * @param {Element} element -\n * @returns {number | undefined} -\n */\nfunction computeAriaValueMin(element) {\n  const valueMin = element.getAttribute('aria-valuemin');\n  return valueMin === null ? undefined : +valueMin;\n}\n\n/**\n * @param {Element} element -\n * @returns {string | undefined} -\n */\nfunction computeAriaValueText(element) {\n  const valueText = element.getAttribute('aria-valuetext');\n  return valueText === null ? undefined : valueText;\n}\n\nconst normalize = getDefaultNormalizer();\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction getRegExpMatcher(string) {\n  return new RegExp(escapeRegExp(string.toLowerCase()), 'i');\n}\nfunction makeSuggestion(queryName, element, content, _ref) {\n  let {\n    variant,\n    name\n  } = _ref;\n  let warning = '';\n  const queryOptions = {};\n  const queryArgs = [['Role', 'TestId'].includes(queryName) ? content : getRegExpMatcher(content)];\n  if (name) {\n    queryOptions.name = getRegExpMatcher(name);\n  }\n  if (queryName === 'Role' && isInaccessible(element)) {\n    queryOptions.hidden = true;\n    warning = \"Element is inaccessible. This means that the element and all its children are invisible to screen readers.\\n    If you are using the aria-hidden prop, make sure this is the right choice for your case.\\n    \";\n  }\n  if (Object.keys(queryOptions).length > 0) {\n    queryArgs.push(queryOptions);\n  }\n  const queryMethod = variant + \"By\" + queryName;\n  return {\n    queryName,\n    queryMethod,\n    queryArgs,\n    variant,\n    warning,\n    toString() {\n      if (warning) {\n        console.warn(warning);\n      }\n      let [text, options] = queryArgs;\n      text = typeof text === 'string' ? \"'\" + text + \"'\" : text;\n      options = options ? \", { \" + Object.entries(options).map(_ref2 => {\n        let [k, v] = _ref2;\n        return k + \": \" + v;\n      }).join(', ') + \" }\" : '';\n      return queryMethod + \"(\" + text + options + \")\";\n    }\n  };\n}\nfunction canSuggest(currentMethod, requestedMethod, data) {\n  return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());\n}\nfunction getSuggestedQuery(element, variant, method) {\n  var _element$getAttribute, _getImplicitAriaRoles;\n  if (variant === void 0) {\n    variant = 'get';\n  }\n  // don't create suggestions for script and style elements\n  if (element.matches(getConfig().defaultIgnore)) {\n    return undefined;\n  }\n\n  //We prefer to suggest something else if the role is generic\n  const role = (_element$getAttribute = element.getAttribute('role')) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles(element)) == null ? void 0 : _getImplicitAriaRoles[0];\n  if (role !== 'generic' && canSuggest('Role', method, role)) {\n    return makeSuggestion('Role', element, role, {\n      variant,\n      name: (0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__.computeAccessibleName)(element, {\n        computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n      })\n    });\n  }\n  const labelText = getLabels(document, element).map(label => label.content).join(' ');\n  if (canSuggest('LabelText', method, labelText)) {\n    return makeSuggestion('LabelText', element, labelText, {\n      variant\n    });\n  }\n  const placeholderText = element.getAttribute('placeholder');\n  if (canSuggest('PlaceholderText', method, placeholderText)) {\n    return makeSuggestion('PlaceholderText', element, placeholderText, {\n      variant\n    });\n  }\n  const textContent = normalize(getNodeText(element));\n  if (canSuggest('Text', method, textContent)) {\n    return makeSuggestion('Text', element, textContent, {\n      variant\n    });\n  }\n  if (canSuggest('DisplayValue', method, element.value)) {\n    return makeSuggestion('DisplayValue', element, normalize(element.value), {\n      variant\n    });\n  }\n  const alt = element.getAttribute('alt');\n  if (canSuggest('AltText', method, alt)) {\n    return makeSuggestion('AltText', element, alt, {\n      variant\n    });\n  }\n  const title = element.getAttribute('title');\n  if (canSuggest('Title', method, title)) {\n    return makeSuggestion('Title', element, title, {\n      variant\n    });\n  }\n  const testId = element.getAttribute(getConfig().testIdAttribute);\n  if (canSuggest('TestId', method, testId)) {\n    return makeSuggestion('TestId', element, testId, {\n      variant\n    });\n  }\n  return undefined;\n}\n\n// This is so the stack trace the developer sees is one that's\n// closer to their code (because async stack traces are hard to follow).\nfunction copyStackTrace(target, source) {\n  target.stack = source.stack.replace(source.message, target.message);\n}\nfunction waitFor(callback, _ref) {\n  let {\n    container = getDocument(),\n    timeout = getConfig().asyncUtilTimeout,\n    showOriginalStackTrace = getConfig().showOriginalStackTrace,\n    stackTraceError,\n    interval = 50,\n    onTimeout = error => {\n      error.message = getConfig().getElementError(error.message, container).message;\n      return error;\n    },\n    mutationObserverOptions = {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      characterData: true\n    }\n  } = _ref;\n  if (typeof callback !== 'function') {\n    throw new TypeError('Received `callback` arg must be a function');\n  }\n  return new Promise(async (resolve, reject) => {\n    let lastError, intervalId, observer;\n    let finished = false;\n    let promiseStatus = 'idle';\n    const overallTimeoutTimer = setTimeout(handleTimeout, timeout);\n    const usingJestFakeTimers = jestFakeTimersAreEnabled();\n    if (usingJestFakeTimers) {\n      const {\n        unstable_advanceTimersWrapper: advanceTimersWrapper\n      } = getConfig();\n      checkCallback();\n      // this is a dangerous rule to disable because it could lead to an\n      // infinite loop. However, eslint isn't smart enough to know that we're\n      // setting finished inside `onDone` which will be called when we're done\n      // waiting or when we've timed out.\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (!finished) {\n        if (!jestFakeTimersAreEnabled()) {\n          const error = new Error(\"Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830\");\n          if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);\n          reject(error);\n          return;\n        }\n\n        // In this rare case, we *need* to wait for in-flight promises\n        // to resolve before continuing. We don't need to take advantage\n        // of parallelization so we're fine.\n        // https://stackoverflow.com/a/59243586/971592\n        // eslint-disable-next-line no-await-in-loop\n        await advanceTimersWrapper(async () => {\n          // we *could* (maybe should?) use `advanceTimersToNextTimer` but it's\n          // possible that could make this loop go on forever if someone is using\n          // third party code that's setting up recursive timers so rapidly that\n          // the user's timer's don't get a chance to resolve. So we'll advance\n          // by an interval instead. (We have a test for this case).\n          jest.advanceTimersByTime(interval);\n        });\n\n        // It's really important that checkCallback is run *before* we flush\n        // in-flight promises. To be honest, I'm not sure why, and I can't quite\n        // think of a way to reproduce the problem in a test, but I spent\n        // an entire day banging my head against a wall on this.\n        checkCallback();\n        if (finished) {\n          break;\n        }\n      }\n    } else {\n      try {\n        checkContainerType(container);\n      } catch (e) {\n        reject(e);\n        return;\n      }\n      intervalId = setInterval(checkRealTimersCallback, interval);\n      const {\n        MutationObserver\n      } = getWindowFromNode(container);\n      observer = new MutationObserver(checkRealTimersCallback);\n      observer.observe(container, mutationObserverOptions);\n      checkCallback();\n    }\n    function onDone(error, result) {\n      finished = true;\n      clearTimeout(overallTimeoutTimer);\n      if (!usingJestFakeTimers) {\n        clearInterval(intervalId);\n        observer.disconnect();\n      }\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    }\n    function checkRealTimersCallback() {\n      if (jestFakeTimersAreEnabled()) {\n        const error = new Error(\"Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830\");\n        if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);\n        return reject(error);\n      } else {\n        return checkCallback();\n      }\n    }\n    function checkCallback() {\n      if (promiseStatus === 'pending') return;\n      try {\n        const result = runWithExpensiveErrorDiagnosticsDisabled(callback);\n        if (typeof (result == null ? void 0 : result.then) === 'function') {\n          promiseStatus = 'pending';\n          result.then(resolvedValue => {\n            promiseStatus = 'resolved';\n            onDone(null, resolvedValue);\n          }, rejectedValue => {\n            promiseStatus = 'rejected';\n            lastError = rejectedValue;\n          });\n        } else {\n          onDone(null, result);\n        }\n        // If `callback` throws, wait for the next mutation, interval, or timeout.\n      } catch (error) {\n        // Save the most recent callback error to reject the promise with it in the event of a timeout\n        lastError = error;\n      }\n    }\n    function handleTimeout() {\n      let error;\n      if (lastError) {\n        error = lastError;\n        if (!showOriginalStackTrace && error.name === 'TestingLibraryElementError') {\n          copyStackTrace(error, stackTraceError);\n        }\n      } else {\n        error = new Error('Timed out in waitFor.');\n        if (!showOriginalStackTrace) {\n          copyStackTrace(error, stackTraceError);\n        }\n      }\n      onDone(onTimeout(error), null);\n    }\n  });\n}\nfunction waitForWrapper(callback, options) {\n  // create the error here so its stack trace is as close to the\n  // calling code as possible\n  const stackTraceError = new Error('STACK_TRACE_MESSAGE');\n  return getConfig().asyncWrapper(() => waitFor(callback, {\n    stackTraceError,\n    ...options\n  }));\n}\n\n/*\neslint\n  max-lines-per-function: [\"error\", {\"max\": 200}],\n*/\n\nfunction getElementError(message, container) {\n  return getConfig().getElementError(message, container);\n}\nfunction getMultipleElementsFoundError(message, container) {\n  return getElementError(message + \"\\n\\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).\", container);\n}\nfunction queryAllByAttribute(attribute, container, text, _temp) {\n  let {\n    exact = true,\n    collapseWhitespace,\n    trim,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  return Array.from(container.querySelectorAll(\"[\" + attribute + \"]\")).filter(node => matcher(node.getAttribute(attribute), node, text, matchNormalizer));\n}\nfunction queryByAttribute(attribute, container, text, options) {\n  const els = queryAllByAttribute(attribute, container, text, options);\n  if (els.length > 1) {\n    throw getMultipleElementsFoundError(\"Found multiple elements by [\" + attribute + \"=\" + text + \"]\", container);\n  }\n  return els[0] || null;\n}\n\n// this accepts a query function and returns a function which throws an error\n// if more than one elements is returned, otherwise it returns the first\n// element or null\nfunction makeSingleQuery(allQuery, getMultipleError) {\n  return function (container) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const els = allQuery(container, ...args);\n    if (els.length > 1) {\n      const elementStrings = els.map(element => getElementError(null, element).message).join('\\n\\n');\n      throw getMultipleElementsFoundError(getMultipleError(container, ...args) + \"\\n\\nHere are the matching elements:\\n\\n\" + elementStrings, container);\n    }\n    return els[0] || null;\n  };\n}\nfunction getSuggestionError(suggestion, container) {\n  return getConfig().getElementError(\"A better query is available, try this:\\n\" + suggestion.toString() + \"\\n\", container);\n}\n\n// this accepts a query function and returns a function which throws an error\n// if an empty list of elements is returned\nfunction makeGetAllQuery(allQuery, getMissingError) {\n  return function (container) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    const els = allQuery(container, ...args);\n    if (!els.length) {\n      throw getConfig().getElementError(getMissingError(container, ...args), container);\n    }\n    return els;\n  };\n}\n\n// this accepts a getter query function and returns a function which calls\n// waitFor and passing a function which invokes the getter.\nfunction makeFindQuery(getter) {\n  return (container, text, options, waitForOptions) => {\n    return waitForWrapper(() => {\n      return getter(container, text, options);\n    }, {\n      container,\n      ...waitForOptions\n    });\n  };\n}\nconst wrapSingleQueryWithSuggestion = (query, queryAllByName, variant) => function (container) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  const element = query(container, ...args);\n  const [{\n    suggest = getConfig().throwSuggestions\n  } = {}] = args.slice(-1);\n  if (element && suggest) {\n    const suggestion = getSuggestedQuery(element, variant);\n    if (suggestion && !queryAllByName.endsWith(suggestion.queryName)) {\n      throw getSuggestionError(suggestion.toString(), container);\n    }\n  }\n  return element;\n};\nconst wrapAllByQueryWithSuggestion = (query, queryAllByName, variant) => function (container) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  const els = query(container, ...args);\n  const [{\n    suggest = getConfig().throwSuggestions\n  } = {}] = args.slice(-1);\n  if (els.length && suggest) {\n    // get a unique list of all suggestion messages.  We are only going to make a suggestion if\n    // all the suggestions are the same\n    const uniqueSuggestionMessages = [...new Set(els.map(element => {\n      var _getSuggestedQuery;\n      return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();\n    }))];\n    if (\n    // only want to suggest if all the els have the same suggestion.\n    uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?\n    getSuggestedQuery(els[0], variant).queryName)) {\n      throw getSuggestionError(uniqueSuggestionMessages[0], container);\n    }\n  }\n  return els;\n};\n\n// TODO: This deviates from the published declarations\n// However, the implementation always required a dyadic (after `container`) not variadic `queryAllBy` considering the implementation of `makeFindQuery`\n// This is at least statically true and can be verified by accepting `QueryMethod<Arguments, HTMLElement[]>`\nfunction buildQueries(queryAllBy, getMultipleError, getMissingError) {\n  const queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError), queryAllBy.name, 'query');\n  const getAllBy = makeGetAllQuery(queryAllBy, getMissingError);\n  const getBy = makeSingleQuery(getAllBy, getMultipleError);\n  const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, 'get');\n  const getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace('query', 'get'), 'getAll');\n  const findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, 'findAll'));\n  const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, 'find'));\n  return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];\n}\n\nvar queryHelpers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getElementError: getElementError,\n  wrapAllByQueryWithSuggestion: wrapAllByQueryWithSuggestion,\n  wrapSingleQueryWithSuggestion: wrapSingleQueryWithSuggestion,\n  getMultipleElementsFoundError: getMultipleElementsFoundError,\n  queryAllByAttribute: queryAllByAttribute,\n  queryByAttribute: queryByAttribute,\n  makeSingleQuery: makeSingleQuery,\n  makeGetAllQuery: makeGetAllQuery,\n  makeFindQuery: makeFindQuery,\n  buildQueries: buildQueries\n});\n\nfunction queryAllLabels(container) {\n  return Array.from(container.querySelectorAll('label,input')).map(node => {\n    return {\n      node,\n      textToMatch: getLabelContent(node)\n    };\n  }).filter(_ref => {\n    let {\n      textToMatch\n    } = _ref;\n    return textToMatch !== null;\n  });\n}\nconst queryAllLabelsByText = function (container, text, _temp) {\n  let {\n    exact = true,\n    trim,\n    collapseWhitespace,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const textToMatchByLabels = queryAllLabels(container);\n  return textToMatchByLabels.filter(_ref2 => {\n    let {\n      node,\n      textToMatch\n    } = _ref2;\n    return matcher(textToMatch, node, text, matchNormalizer);\n  }).map(_ref3 => {\n    let {\n      node\n    } = _ref3;\n    return node;\n  });\n};\nconst queryAllByLabelText = function (container, text, _temp2) {\n  let {\n    selector = '*',\n    exact = true,\n    collapseWhitespace,\n    trim,\n    normalizer\n  } = _temp2 === void 0 ? {} : _temp2;\n  checkContainerType(container);\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const matchingLabelledElements = Array.from(container.querySelectorAll('*')).filter(element => {\n    return getRealLabels(element).length || element.hasAttribute('aria-labelledby');\n  }).reduce((labelledElements, labelledElement) => {\n    const labelList = getLabels(container, labelledElement, {\n      selector\n    });\n    labelList.filter(label => Boolean(label.formControl)).forEach(label => {\n      if (matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl) {\n        labelledElements.push(label.formControl);\n      }\n    });\n    const labelsValue = labelList.filter(label => Boolean(label.content)).map(label => label.content);\n    if (matcher(labelsValue.join(' '), labelledElement, text, matchNormalizer)) {\n      labelledElements.push(labelledElement);\n    }\n    if (labelsValue.length > 1) {\n      labelsValue.forEach((labelValue, index) => {\n        if (matcher(labelValue, labelledElement, text, matchNormalizer)) {\n          labelledElements.push(labelledElement);\n        }\n        const labelsFiltered = [...labelsValue];\n        labelsFiltered.splice(index, 1);\n        if (labelsFiltered.length > 1) {\n          if (matcher(labelsFiltered.join(' '), labelledElement, text, matchNormalizer)) {\n            labelledElements.push(labelledElement);\n          }\n        }\n      });\n    }\n    return labelledElements;\n  }, []).concat(queryAllByAttribute('aria-label', container, text, {\n    exact,\n    normalizer: matchNormalizer\n  }));\n  return Array.from(new Set(matchingLabelledElements)).filter(element => element.matches(selector));\n};\n\n// the getAll* query would normally look like this:\n// const getAllByLabelText = makeGetAllQuery(\n//   queryAllByLabelText,\n//   (c, text) => `Unable to find a label with the text of: ${text}`,\n// )\n// however, we can give a more helpful error message than the generic one,\n// so we're writing this one out by hand.\nconst getAllByLabelText = function (container, text) {\n  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    rest[_key - 2] = arguments[_key];\n  }\n  const els = queryAllByLabelText(container, text, ...rest);\n  if (!els.length) {\n    const labels = queryAllLabelsByText(container, text, ...rest);\n    if (labels.length) {\n      const tagNames = labels.map(label => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter(tagName => !!tagName);\n      if (tagNames.length) {\n        throw getConfig().getElementError(tagNames.map(tagName => \"Found a label with the text of: \" + text + \", however the element associated with this label (<\" + tagName + \" />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <\" + tagName + \" />, you can use aria-label or aria-labelledby instead.\").join('\\n\\n'), container);\n      } else {\n        throw getConfig().getElementError(\"Found a label with the text of: \" + text + \", however no form control was found associated to that label. Make sure you're using the \\\"for\\\" attribute or \\\"aria-labelledby\\\" attribute correctly.\", container);\n      }\n    } else {\n      throw getConfig().getElementError(\"Unable to find a label with the text of: \" + text, container);\n    }\n  }\n  return els;\n};\nfunction getTagNameOfElementAssociatedWithLabelViaFor(container, label) {\n  const htmlFor = label.getAttribute('for');\n  if (!htmlFor) {\n    return null;\n  }\n  const element = container.querySelector(\"[id=\\\"\" + htmlFor + \"\\\"]\");\n  return element ? element.tagName.toLowerCase() : null;\n}\n\n// the reason mentioned above is the same reason we're not using buildQueries\nconst getMultipleError$7 = (c, text) => \"Found multiple elements with the text of: \" + text;\nconst queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, 'query');\nconst getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7);\nconst findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, 'findAll'));\nconst findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, 'find'));\nconst getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, 'getAll');\nconst getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, 'get');\nconst queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, 'queryAll');\n\nconst queryAllByPlaceholderText = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  checkContainerType(args[0]);\n  return queryAllByAttribute('placeholder', ...args);\n};\nconst getMultipleError$6 = (c, text) => \"Found multiple elements with the placeholder text of: \" + text;\nconst getMissingError$6 = (c, text) => \"Unable to find an element with the placeholder text of: \" + text;\nconst queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, 'queryAll');\nconst [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6);\n\nconst queryAllByText = function (container, text, _temp) {\n  let {\n    selector = '*',\n    exact = true,\n    collapseWhitespace,\n    trim,\n    ignore = getConfig().defaultIgnore,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  checkContainerType(container);\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  let baseArray = [];\n  if (typeof container.matches === 'function' && container.matches(selector)) {\n    baseArray = [container];\n  }\n  return [...baseArray, ...Array.from(container.querySelectorAll(selector))]\n  // TODO: `matches` according lib.dom.d.ts can get only `string` but according our code it can handle also boolean :)\n  .filter(node => !ignore || !node.matches(ignore)).filter(node => matcher(getNodeText(node), node, text, matchNormalizer));\n};\nconst getMultipleError$5 = (c, text) => \"Found multiple elements with the text: \" + text;\nconst getMissingError$5 = function (c, text, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    collapseWhitespace,\n    trim,\n    normalizer,\n    selector\n  } = options;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const normalizedText = matchNormalizer(text.toString());\n  const isNormalizedDifferent = normalizedText !== text.toString();\n  const isCustomSelector = (selector != null ? selector : '*') !== '*';\n  return \"Unable to find an element with the text: \" + (isNormalizedDifferent ? normalizedText + \" (normalized from '\" + text + \"')\" : text) + (isCustomSelector ? \", which matches selector '\" + selector + \"'\" : '') + \". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.\";\n};\nconst queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, 'queryAll');\nconst [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5);\n\nconst queryAllByDisplayValue = function (container, value, _temp) {\n  let {\n    exact = true,\n    collapseWhitespace,\n    trim,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  checkContainerType(container);\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  return Array.from(container.querySelectorAll(\"input,textarea,select\")).filter(node => {\n    if (node.tagName === 'SELECT') {\n      const selectedOptions = Array.from(node.options).filter(option => option.selected);\n      return selectedOptions.some(optionNode => matcher(getNodeText(optionNode), optionNode, value, matchNormalizer));\n    } else {\n      return matcher(node.value, node, value, matchNormalizer);\n    }\n  });\n};\nconst getMultipleError$4 = (c, value) => \"Found multiple elements with the display value: \" + value + \".\";\nconst getMissingError$4 = (c, value) => \"Unable to find an element with the display value: \" + value + \".\";\nconst queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, 'queryAll');\nconst [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4);\n\n// Valid tags are img, input, area and custom elements\nconst VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i;\nconst queryAllByAltText = function (container, alt, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  checkContainerType(container);\n  return queryAllByAttribute('alt', container, alt, options).filter(node => VALID_TAG_REGEXP.test(node.tagName));\n};\nconst getMultipleError$3 = (c, alt) => \"Found multiple elements with the alt text: \" + alt;\nconst getMissingError$3 = (c, alt) => \"Unable to find an element with the alt text: \" + alt;\nconst queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, 'queryAll');\nconst [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3);\n\nconst isSvgTitle = node => {\n  var _node$parentElement;\n  return node.tagName.toLowerCase() === 'title' && ((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === 'svg';\n};\nconst queryAllByTitle = function (container, text, _temp) {\n  let {\n    exact = true,\n    collapseWhitespace,\n    trim,\n    normalizer\n  } = _temp === void 0 ? {} : _temp;\n  checkContainerType(container);\n  const matcher = exact ? matches : fuzzyMatches;\n  const matchNormalizer = makeNormalizer({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  return Array.from(container.querySelectorAll('[title], svg > title')).filter(node => matcher(node.getAttribute('title'), node, text, matchNormalizer) || isSvgTitle(node) && matcher(getNodeText(node), node, text, matchNormalizer));\n};\nconst getMultipleError$2 = (c, title) => \"Found multiple elements with the title: \" + title + \".\";\nconst getMissingError$2 = (c, title) => \"Unable to find an element with the title: \" + title + \".\";\nconst queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, 'queryAll');\nconst [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2);\n\n/* eslint-disable complexity */\nconst queryAllByRole = function (container, role, _temp) {\n  let {\n    hidden = getConfig().defaultHidden,\n    name,\n    description,\n    queryFallbacks = false,\n    selected,\n    busy,\n    checked,\n    pressed,\n    current,\n    level,\n    expanded,\n    value: {\n      now: valueNow,\n      min: valueMin,\n      max: valueMax,\n      text: valueText\n    } = {}\n  } = _temp === void 0 ? {} : _temp;\n  checkContainerType(container);\n  if (selected !== undefined) {\n    var _allRoles$get;\n    // guard against unknown roles\n    if (((_allRoles$get = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get.props['aria-selected']) === undefined) {\n      throw new Error(\"\\\"aria-selected\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (busy !== undefined) {\n    var _allRoles$get2;\n    // guard against unknown roles\n    if (((_allRoles$get2 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get2.props['aria-busy']) === undefined) {\n      throw new Error(\"\\\"aria-busy\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (checked !== undefined) {\n    var _allRoles$get3;\n    // guard against unknown roles\n    if (((_allRoles$get3 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get3.props['aria-checked']) === undefined) {\n      throw new Error(\"\\\"aria-checked\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (pressed !== undefined) {\n    var _allRoles$get4;\n    // guard against unknown roles\n    if (((_allRoles$get4 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get4.props['aria-pressed']) === undefined) {\n      throw new Error(\"\\\"aria-pressed\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (current !== undefined) {\n    var _allRoles$get5;\n    /* istanbul ignore next */\n    // guard against unknown roles\n    // All currently released ARIA versions support `aria-current` on all roles.\n    // Leaving this for symetry and forward compatibility\n    if (((_allRoles$get5 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get5.props['aria-current']) === undefined) {\n      throw new Error(\"\\\"aria-current\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (level !== undefined) {\n    // guard against using `level` option with any role other than `heading`\n    if (role !== 'heading') {\n      throw new Error(\"Role \\\"\" + role + \"\\\" cannot have \\\"level\\\" property.\");\n    }\n  }\n  if (valueNow !== undefined) {\n    var _allRoles$get6;\n    // guard against unknown roles\n    if (((_allRoles$get6 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get6.props['aria-valuenow']) === undefined) {\n      throw new Error(\"\\\"aria-valuenow\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (valueMax !== undefined) {\n    var _allRoles$get7;\n    // guard against unknown roles\n    if (((_allRoles$get7 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get7.props['aria-valuemax']) === undefined) {\n      throw new Error(\"\\\"aria-valuemax\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (valueMin !== undefined) {\n    var _allRoles$get8;\n    // guard against unknown roles\n    if (((_allRoles$get8 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get8.props['aria-valuemin']) === undefined) {\n      throw new Error(\"\\\"aria-valuemin\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (valueText !== undefined) {\n    var _allRoles$get9;\n    // guard against unknown roles\n    if (((_allRoles$get9 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get9.props['aria-valuetext']) === undefined) {\n      throw new Error(\"\\\"aria-valuetext\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  if (expanded !== undefined) {\n    var _allRoles$get10;\n    // guard against unknown roles\n    if (((_allRoles$get10 = aria_query__WEBPACK_IMPORTED_MODULE_2__.roles.get(role)) == null ? void 0 : _allRoles$get10.props['aria-expanded']) === undefined) {\n      throw new Error(\"\\\"aria-expanded\\\" is not supported on role \\\"\" + role + \"\\\".\");\n    }\n  }\n  const subtreeIsInaccessibleCache = new WeakMap();\n  function cachedIsSubtreeInaccessible(element) {\n    if (!subtreeIsInaccessibleCache.has(element)) {\n      subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element));\n    }\n    return subtreeIsInaccessibleCache.get(element);\n  }\n  return Array.from(container.querySelectorAll(\n  // Only query elements that can be matched by the following filters\n  makeRoleSelector(role))).filter(node => {\n    const isRoleSpecifiedExplicitly = node.hasAttribute('role');\n    if (isRoleSpecifiedExplicitly) {\n      const roleValue = node.getAttribute('role');\n      if (queryFallbacks) {\n        return roleValue.split(' ').filter(Boolean).some(roleAttributeToken => roleAttributeToken === role);\n      }\n      // other wise only send the first token to match\n      const [firstRoleAttributeToken] = roleValue.split(' ');\n      return firstRoleAttributeToken === role;\n    }\n    const implicitRoles = getImplicitAriaRoles(node);\n    return implicitRoles.some(implicitRole => {\n      return implicitRole === role;\n    });\n  }).filter(element => {\n    if (selected !== undefined) {\n      return selected === computeAriaSelected(element);\n    }\n    if (busy !== undefined) {\n      return busy === computeAriaBusy(element);\n    }\n    if (checked !== undefined) {\n      return checked === computeAriaChecked(element);\n    }\n    if (pressed !== undefined) {\n      return pressed === computeAriaPressed(element);\n    }\n    if (current !== undefined) {\n      return current === computeAriaCurrent(element);\n    }\n    if (expanded !== undefined) {\n      return expanded === computeAriaExpanded(element);\n    }\n    if (level !== undefined) {\n      return level === computeHeadingLevel(element);\n    }\n    if (valueNow !== undefined || valueMax !== undefined || valueMin !== undefined || valueText !== undefined) {\n      let valueMatches = true;\n      if (valueNow !== undefined) {\n        valueMatches && (valueMatches = valueNow === computeAriaValueNow(element));\n      }\n      if (valueMax !== undefined) {\n        valueMatches && (valueMatches = valueMax === computeAriaValueMax(element));\n      }\n      if (valueMin !== undefined) {\n        valueMatches && (valueMatches = valueMin === computeAriaValueMin(element));\n      }\n      if (valueText !== undefined) {\n        var _computeAriaValueText;\n        valueMatches && (valueMatches = matches((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, text => text));\n      }\n      return valueMatches;\n    }\n    // don't care if aria attributes are unspecified\n    return true;\n  }).filter(element => {\n    if (name === undefined) {\n      // Don't care\n      return true;\n    }\n    return matches((0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__.computeAccessibleName)(element, {\n      computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n    }), element, name, text => text);\n  }).filter(element => {\n    if (description === undefined) {\n      // Don't care\n      return true;\n    }\n    return matches((0,dom_accessibility_api__WEBPACK_IMPORTED_MODULE_1__.computeAccessibleDescription)(element, {\n      computedStyleSupportsPseudoElements: getConfig().computedStyleSupportsPseudoElements\n    }), element, description, text => text);\n  }).filter(element => {\n    return hidden === false ? isInaccessible(element, {\n      isSubtreeInaccessible: cachedIsSubtreeInaccessible\n    }) === false : true;\n  });\n};\nfunction makeRoleSelector(role) {\n  var _roleElements$get;\n  const explicitRoleSelector = \"*[role~=\\\"\" + role + \"\\\"]\";\n  const roleRelations = (_roleElements$get = aria_query__WEBPACK_IMPORTED_MODULE_2__.roleElements.get(role)) != null ? _roleElements$get : new Set();\n  const implicitRoleSelectors = new Set(Array.from(roleRelations).map(_ref => {\n    let {\n      name\n    } = _ref;\n    return name;\n  }));\n\n  // Current transpilation config sometimes assumes `...` is always applied to arrays.\n  // `...` is equivalent to `Array.prototype.concat` for arrays.\n  // If you replace this code with `[explicitRoleSelector, ...implicitRoleSelectors]`, make sure every transpilation target retains the `...` in favor of `Array.prototype.concat`.\n  return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(',');\n}\nconst getNameHint = name => {\n  let nameHint = '';\n  if (name === undefined) {\n    nameHint = '';\n  } else if (typeof name === 'string') {\n    nameHint = \" and name \\\"\" + name + \"\\\"\";\n  } else {\n    nameHint = \" and name `\" + name + \"`\";\n  }\n  return nameHint;\n};\nconst getMultipleError$1 = function (c, role, _temp2) {\n  let {\n    name\n  } = _temp2 === void 0 ? {} : _temp2;\n  return \"Found multiple elements with the role \\\"\" + role + \"\\\"\" + getNameHint(name);\n};\nconst getMissingError$1 = function (container, role, _temp3) {\n  let {\n    hidden = getConfig().defaultHidden,\n    name,\n    description\n  } = _temp3 === void 0 ? {} : _temp3;\n  if (getConfig()._disableExpensiveErrorDiagnostics) {\n    return \"Unable to find role=\\\"\" + role + \"\\\"\" + getNameHint(name);\n  }\n  let roles = '';\n  Array.from(container.children).forEach(childElement => {\n    roles += prettyRoles(childElement, {\n      hidden,\n      includeDescription: description !== undefined\n    });\n  });\n  let roleMessage;\n  if (roles.length === 0) {\n    if (hidden === false) {\n      roleMessage = 'There are no accessible roles. But there might be some inaccessible roles. ' + 'If you wish to access them, then set the `hidden` option to `true`. ' + 'Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole';\n    } else {\n      roleMessage = 'There are no available roles.';\n    }\n  } else {\n    roleMessage = (\"\\nHere are the \" + (hidden === false ? 'accessible' : 'available') + \" roles:\\n\\n  \" + roles.replace(/\\n/g, '\\n  ').replace(/\\n\\s\\s\\n/g, '\\n\\n') + \"\\n\").trim();\n  }\n  let nameHint = '';\n  if (name === undefined) {\n    nameHint = '';\n  } else if (typeof name === 'string') {\n    nameHint = \" and name \\\"\" + name + \"\\\"\";\n  } else {\n    nameHint = \" and name `\" + name + \"`\";\n  }\n  let descriptionHint = '';\n  if (description === undefined) {\n    descriptionHint = '';\n  } else if (typeof description === 'string') {\n    descriptionHint = \" and description \\\"\" + description + \"\\\"\";\n  } else {\n    descriptionHint = \" and description `\" + description + \"`\";\n  }\n  return (\"\\nUnable to find an \" + (hidden === false ? 'accessible ' : '') + \"element with the role \\\"\" + role + \"\\\"\" + nameHint + descriptionHint + \"\\n\\n\" + roleMessage).trim();\n};\nconst queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, 'queryAll');\nconst [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1);\n\nconst getTestIdAttribute = () => getConfig().testIdAttribute;\nconst queryAllByTestId = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  checkContainerType(args[0]);\n  return queryAllByAttribute(getTestIdAttribute(), ...args);\n};\nconst getMultipleError = (c, id) => \"Found multiple elements by: [\" + getTestIdAttribute() + \"=\\\"\" + id + \"\\\"]\";\nconst getMissingError = (c, id) => \"Unable to find an element by: [\" + getTestIdAttribute() + \"=\\\"\" + id + \"\\\"]\";\nconst queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, 'queryAll');\nconst [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError);\n\nvar queries = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  queryAllByLabelText: queryAllByLabelTextWithSuggestions,\n  queryByLabelText: queryByLabelText,\n  getAllByLabelText: getAllByLabelTextWithSuggestions,\n  getByLabelText: getByLabelTextWithSuggestions,\n  findAllByLabelText: findAllByLabelText,\n  findByLabelText: findByLabelText,\n  queryByPlaceholderText: queryByPlaceholderText,\n  queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions,\n  getByPlaceholderText: getByPlaceholderText,\n  getAllByPlaceholderText: getAllByPlaceholderText,\n  findAllByPlaceholderText: findAllByPlaceholderText,\n  findByPlaceholderText: findByPlaceholderText,\n  queryByText: queryByText,\n  queryAllByText: queryAllByTextWithSuggestions,\n  getByText: getByText,\n  getAllByText: getAllByText,\n  findAllByText: findAllByText,\n  findByText: findByText,\n  queryByDisplayValue: queryByDisplayValue,\n  queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions,\n  getByDisplayValue: getByDisplayValue,\n  getAllByDisplayValue: getAllByDisplayValue,\n  findAllByDisplayValue: findAllByDisplayValue,\n  findByDisplayValue: findByDisplayValue,\n  queryByAltText: queryByAltText,\n  queryAllByAltText: queryAllByAltTextWithSuggestions,\n  getByAltText: getByAltText,\n  getAllByAltText: getAllByAltText,\n  findAllByAltText: findAllByAltText,\n  findByAltText: findByAltText,\n  queryByTitle: queryByTitle,\n  queryAllByTitle: queryAllByTitleWithSuggestions,\n  getByTitle: getByTitle,\n  getAllByTitle: getAllByTitle,\n  findAllByTitle: findAllByTitle,\n  findByTitle: findByTitle,\n  queryByRole: queryByRole,\n  queryAllByRole: queryAllByRoleWithSuggestions,\n  getAllByRole: getAllByRole,\n  getByRole: getByRole,\n  findAllByRole: findAllByRole,\n  findByRole: findByRole,\n  queryByTestId: queryByTestId,\n  queryAllByTestId: queryAllByTestIdWithSuggestions,\n  getByTestId: getByTestId,\n  getAllByTestId: getAllByTestId,\n  findAllByTestId: findAllByTestId,\n  findByTestId: findByTestId\n});\n\n/**\n * @typedef {{[key: string]: Function}} FuncMap\n */\n\n/**\n * @param {HTMLElement} element container\n * @param {FuncMap} queries object of functions\n * @param {Object} initialValue for reducer\n * @returns {FuncMap} returns object of functions bound to container\n */\nfunction getQueriesForElement(element, queries$1, initialValue) {\n  if (queries$1 === void 0) {\n    queries$1 = queries;\n  }\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n  return Object.keys(queries$1).reduce((helpers, key) => {\n    const fn = queries$1[key];\n    helpers[key] = fn.bind(null, element);\n    return helpers;\n  }, initialValue);\n}\n\nconst isRemoved = result => !result || Array.isArray(result) && !result.length;\n\n// Check if the element is not present.\n// As the name implies, waitForElementToBeRemoved should check `present` --> `removed`\nfunction initialCheck(elements) {\n  if (isRemoved(elements)) {\n    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');\n  }\n}\nasync function waitForElementToBeRemoved(callback, options) {\n  // created here so we get a nice stacktrace\n  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');\n  if (typeof callback !== 'function') {\n    initialCheck(callback);\n    const elements = Array.isArray(callback) ? callback : [callback];\n    const getRemainingElements = elements.map(element => {\n      let parent = element.parentElement;\n      if (parent === null) return () => null;\n      while (parent.parentElement) parent = parent.parentElement;\n      return () => parent.contains(element) ? element : null;\n    });\n    callback = () => getRemainingElements.map(c => c()).filter(Boolean);\n  }\n  initialCheck(callback());\n  return waitForWrapper(() => {\n    let result;\n    try {\n      result = callback();\n    } catch (error) {\n      if (error.name === 'TestingLibraryElementError') {\n        return undefined;\n      }\n      throw error;\n    }\n    if (!isRemoved(result)) {\n      throw timeoutError;\n    }\n    return undefined;\n  }, options);\n}\n\n/*\neslint\n  require-await: \"off\"\n*/\n\nconst eventMap = {\n  // Clipboard Events\n  copy: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  cut: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  paste: {\n    EventType: 'ClipboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Composition Events\n  compositionEnd: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  compositionStart: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  compositionUpdate: {\n    EventType: 'CompositionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Keyboard Events\n  keyDown: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  keyPress: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  keyUp: {\n    EventType: 'KeyboardEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      charCode: 0,\n      composed: true\n    }\n  },\n  // Focus Events\n  focus: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  blur: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  focusIn: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  focusOut: {\n    EventType: 'FocusEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  // Form Events\n  change: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  input: {\n    EventType: 'InputEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  invalid: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: true\n    }\n  },\n  submit: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  reset: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  // Mouse Events\n  click: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      button: 0,\n      composed: true\n    }\n  },\n  contextMenu: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dblClick: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  drag: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragEnd: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragEnter: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragExit: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragLeave: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  dragOver: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  dragStart: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  drop: {\n    EventType: 'DragEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseDown: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseEnter: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  mouseLeave: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false,\n      composed: true\n    }\n  },\n  mouseMove: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseOut: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseOver: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  mouseUp: {\n    EventType: 'MouseEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Selection Events\n  select: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // Touch Events\n  touchCancel: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  touchEnd: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  touchMove: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  touchStart: {\n    EventType: 'TouchEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // UI Events\n  resize: {\n    EventType: 'UIEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  scroll: {\n    EventType: 'UIEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Wheel Events\n  wheel: {\n    EventType: 'WheelEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  // Media Events\n  abort: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  canPlay: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  canPlayThrough: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  durationChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  emptied: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  encrypted: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  ended: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadedData: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadedMetadata: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  loadStart: {\n    EventType: 'ProgressEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  pause: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  play: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  playing: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  progress: {\n    EventType: 'ProgressEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  rateChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  seeked: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  seeking: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  stalled: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  suspend: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  timeUpdate: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  volumeChange: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  waiting: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Events\n  load: {\n    // TODO: load events can be UIEvent or Event depending on what generated them\n    // This is where this abstraction breaks down.\n    // But the common targets are <img />, <script /> and window.\n    // Neither of these targets receive a UIEvent\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  error: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  // Animation Events\n  animationStart: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  animationEnd: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  animationIteration: {\n    EventType: 'AnimationEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // Transition Events\n  transitionCancel: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  transitionEnd: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true\n    }\n  },\n  transitionRun: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  transitionStart: {\n    EventType: 'TransitionEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // pointer events\n  pointerOver: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerEnter: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  pointerDown: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerMove: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerUp: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerCancel: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  pointerOut: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: true,\n      composed: true\n    }\n  },\n  pointerLeave: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  gotPointerCapture: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  lostPointerCapture: {\n    EventType: 'PointerEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false,\n      composed: true\n    }\n  },\n  // history events\n  popState: {\n    EventType: 'PopStateEvent',\n    defaultInit: {\n      bubbles: true,\n      cancelable: false\n    }\n  },\n  // window events\n  offline: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  },\n  online: {\n    EventType: 'Event',\n    defaultInit: {\n      bubbles: false,\n      cancelable: false\n    }\n  }\n};\nconst eventAliasMap = {\n  doubleClick: 'dblClick'\n};\n\nfunction fireEvent(element, event) {\n  return getConfig().eventWrapper(() => {\n    if (!event) {\n      throw new Error(\"Unable to fire an event - please provide an event object.\");\n    }\n    if (!element) {\n      throw new Error(\"Unable to fire a \\\"\" + event.type + \"\\\" event - please provide a DOM element.\");\n    }\n    return element.dispatchEvent(event);\n  });\n}\nfunction createEvent(eventName, node, init, _temp) {\n  let {\n    EventType = 'Event',\n    defaultInit = {}\n  } = _temp === void 0 ? {} : _temp;\n  if (!node) {\n    throw new Error(\"Unable to fire a \\\"\" + eventName + \"\\\" event - please provide a DOM element.\");\n  }\n  const eventInit = {\n    ...defaultInit,\n    ...init\n  };\n  const {\n    target: {\n      value,\n      files,\n      ...targetProperties\n    } = {}\n  } = eventInit;\n  if (value !== undefined) {\n    setNativeValue(node, value);\n  }\n  if (files !== undefined) {\n    // input.files is a read-only property so this is not allowed:\n    // input.files = [file]\n    // so we have to use this workaround to set the property\n    Object.defineProperty(node, 'files', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: files\n    });\n  }\n  Object.assign(node, targetProperties);\n  const window = getWindowFromNode(node);\n  const EventConstructor = window[EventType] || window.Event;\n  let event;\n  /* istanbul ignore else  */\n  if (typeof EventConstructor === 'function') {\n    event = new EventConstructor(eventName, eventInit);\n  } else {\n    // IE11 polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n    event = window.document.createEvent(EventType);\n    const {\n      bubbles,\n      cancelable,\n      detail,\n      ...otherInit\n    } = eventInit;\n    event.initEvent(eventName, bubbles, cancelable, detail);\n    Object.keys(otherInit).forEach(eventKey => {\n      event[eventKey] = otherInit[eventKey];\n    });\n  }\n\n  // DataTransfer is not supported in jsdom: https://github.com/jsdom/jsdom/issues/1568\n  const dataTransferProperties = ['dataTransfer', 'clipboardData'];\n  dataTransferProperties.forEach(dataTransferKey => {\n    const dataTransferValue = eventInit[dataTransferKey];\n    if (typeof dataTransferValue === 'object') {\n      /* istanbul ignore if  */\n      if (typeof window.DataTransfer === 'function') {\n        Object.defineProperty(event, dataTransferKey, {\n          value: Object.getOwnPropertyNames(dataTransferValue).reduce((acc, propName) => {\n            Object.defineProperty(acc, propName, {\n              value: dataTransferValue[propName]\n            });\n            return acc;\n          }, new window.DataTransfer())\n        });\n      } else {\n        Object.defineProperty(event, dataTransferKey, {\n          value: dataTransferValue\n        });\n      }\n    }\n  });\n  return event;\n}\nObject.keys(eventMap).forEach(key => {\n  const {\n    EventType,\n    defaultInit\n  } = eventMap[key];\n  const eventName = key.toLowerCase();\n  createEvent[key] = (node, init) => createEvent(eventName, node, init, {\n    EventType,\n    defaultInit\n  });\n  fireEvent[key] = (node, init) => fireEvent(node, createEvent[key](node, init));\n});\n\n// function written after some investigation here:\n// https://github.com/facebook/react/issues/10135#issuecomment-401496776\nfunction setNativeValue(element, value) {\n  const {\n    set: valueSetter\n  } = Object.getOwnPropertyDescriptor(element, 'value') || {};\n  const prototype = Object.getPrototypeOf(element);\n  const {\n    set: prototypeValueSetter\n  } = Object.getOwnPropertyDescriptor(prototype, 'value') || {};\n  if (prototypeValueSetter && valueSetter !== prototypeValueSetter) {\n    prototypeValueSetter.call(element, value);\n  } else {\n    /* istanbul ignore if */\n    // eslint-disable-next-line no-lonely-if -- Can't be ignored by istanbul otherwise\n    if (valueSetter) {\n      valueSetter.call(element, value);\n    } else {\n      throw new Error('The given element does not have a value setter');\n    }\n  }\n}\nObject.keys(eventAliasMap).forEach(aliasKey => {\n  const key = eventAliasMap[aliasKey];\n  fireEvent[aliasKey] = function () {\n    return fireEvent[key](...arguments);\n  };\n});\n\n/* eslint complexity:[\"error\", 9] */\n\n// WARNING: `lz-string` only has a default export but statically we assume named exports are allowd\nfunction unindent(string) {\n  // remove white spaces first, to save a few bytes.\n  // testing-playground will reformat on load any ways.\n  return string.replace(/[ \\t]*[\\n][ \\t]*/g, '\\n');\n}\nfunction encode(value) {\n  return lz_string__WEBPACK_IMPORTED_MODULE_3___default().compressToEncodedURIComponent(unindent(value));\n}\nfunction getPlaygroundUrl(markup) {\n  return \"https://testing-playground.com/#markup=\" + encode(markup);\n}\nconst debug = (element, maxLength, options) => Array.isArray(element) ? element.forEach(el => logDOM(el, maxLength, options)) : logDOM(element, maxLength, options);\nconst logTestingPlaygroundURL = function (element) {\n  if (element === void 0) {\n    element = getDocument().body;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!element || !('innerHTML' in element)) {\n    console.log(\"The element you're providing isn't a valid DOM element.\");\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!element.innerHTML) {\n    console.log(\"The provided element doesn't have any children.\");\n    return;\n  }\n  const playgroundUrl = getPlaygroundUrl(element.innerHTML);\n  console.log(\"Open this URL in your browser\\n\\n\" + playgroundUrl);\n  return playgroundUrl;\n};\nconst initialValue = {\n  debug,\n  logTestingPlaygroundURL\n};\nconst screen = typeof document !== 'undefined' && document.body // eslint-disable-line @typescript-eslint/no-unnecessary-condition\n? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key) => {\n  // `key` is for all intents and purposes the type of keyof `helpers`, which itself is the type of `initialValue` plus incoming properties from `queries`\n  // if `Object.keys(something)` returned Array<keyof typeof something> this explicit type assertion would not be necessary\n  // see https://stackoverflow.com/questions/55012174/why-doesnt-object-keys-return-a-keyof-type-in-typescript\n  helpers[key] = () => {\n    throw new TypeError('For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error');\n  };\n  return helpers;\n}, initialValue);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9AdGVzdGluZy1saWJyYXJ5L2RvbS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ3RCO0FBQ29FO0FBQzdCO0FBQzlCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEpBQTRKO0FBQzVKO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLGtEQUFvQjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QixpREFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ05BQWdOLHlCQUF5QjtBQUN6TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsb0RBQVk7O0FBRXpEO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRFQUFxQjtBQUMxRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscURBQXFELG1GQUE0QjtBQUNqRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLE9BQU8sa0JBQWtCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRFQUFxQjtBQUNqQztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixlQUFlO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsZUFBZTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThELEtBQUs7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2Q0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2Q0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2Q0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEVBQXFCO0FBQ3hDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRkFBNEI7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9EQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSxhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEVBQXNDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRXlxRCIsInNvdXJjZXMiOlsiL1VzZXJzL3Rlc3QvRG9jdW1lbnRzL0dpdEh1Yi9sZWFmeV9mYWN0b3J5L2Zyb250ZW5kL3NyYy9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9AdGVzdGluZy1saWJyYXJ5L2RvbS5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcHJldHR5Rm9ybWF0IGZyb20gJ3ByZXR0eS1mb3JtYXQnO1xuZXhwb3J0IHsgcHJldHR5Rm9ybWF0IH07XG5pbXBvcnQgeyBjb21wdXRlQWNjZXNzaWJsZU5hbWUsIGNvbXB1dGVBY2Nlc3NpYmxlRGVzY3JpcHRpb24gfSBmcm9tICdkb20tYWNjZXNzaWJpbGl0eS1hcGknO1xuaW1wb3J0IHsgZWxlbWVudFJvbGVzLCByb2xlcywgcm9sZUVsZW1lbnRzIH0gZnJvbSAnYXJpYS1xdWVyeSc7XG5pbXBvcnQgbHpTdHJpbmcgZnJvbSAnbHotc3RyaW5nJztcblxuLyoqXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9qZXN0L2Jsb2IvZTdiYjZhMWUyNmZmYWI5MDYxMWIyNTkzOTEyZGYxNWI2OTMxNTYxMS9wYWNrYWdlcy9wcmV0dHktZm9ybWF0L3NyYy9wbHVnaW5zL0RPTUVsZW1lbnQudHNcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgLS0gdHJ5aW5nIHRvIHN0YXkgYXMgY2xvc2UgdG8gdGhlIG9yaWdpbmFsIGFzIHBvc3NpYmxlICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG4vLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGlmIGtleXMgaXMgZW1wdHkuXG5jb25zdCBwcmludFByb3BzID0gKGtleXMsIHByb3BzLCBjb25maWcsIGluZGVudGF0aW9uLCBkZXB0aCwgcmVmcywgcHJpbnRlcikgPT4ge1xuICBjb25zdCBpbmRlbnRhdGlvbk5leHQgPSBpbmRlbnRhdGlvbiArIGNvbmZpZy5pbmRlbnQ7XG4gIGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5jb2xvcnM7XG4gIHJldHVybiBrZXlzLm1hcChrZXkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHNba2V5XTtcbiAgICBsZXQgcHJpbnRlZCA9IHByaW50ZXIodmFsdWUsIGNvbmZpZywgaW5kZW50YXRpb25OZXh0LCBkZXB0aCwgcmVmcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChwcmludGVkLmluZGV4T2YoJ1xcbicpICE9PSAtMSkge1xuICAgICAgICBwcmludGVkID0gY29uZmlnLnNwYWNpbmdPdXRlciArIGluZGVudGF0aW9uTmV4dCArIHByaW50ZWQgKyBjb25maWcuc3BhY2luZ091dGVyICsgaW5kZW50YXRpb247XG4gICAgICB9XG4gICAgICBwcmludGVkID0gJ3snICsgcHJpbnRlZCArICd9JztcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZy5zcGFjaW5nSW5uZXIgKyBpbmRlbnRhdGlvbiArIGNvbG9ycy5wcm9wLm9wZW4gKyBrZXkgKyBjb2xvcnMucHJvcC5jbG9zZSArICc9JyArIGNvbG9ycy52YWx1ZS5vcGVuICsgcHJpbnRlZCArIGNvbG9ycy52YWx1ZS5jbG9zZTtcbiAgfSkuam9pbignJyk7XG59O1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9ub2RlVHlwZSNub2RlX3R5cGVfY29uc3RhbnRzXG5jb25zdCBOb2RlVHlwZVRleHROb2RlID0gMztcblxuLy8gUmV0dXJuIGVtcHR5IHN0cmluZyBpZiBjaGlsZHJlbiBpcyBlbXB0eS5cbmNvbnN0IHByaW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbmZpZywgaW5kZW50YXRpb24sIGRlcHRoLCByZWZzLCBwcmludGVyKSA9PiBjaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICBjb25zdCBwcmludGVkQ2hpbGQgPSB0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnID8gcHJpbnRUZXh0KGNoaWxkLCBjb25maWcpIDogcHJpbnRlcihjaGlsZCwgY29uZmlnLCBpbmRlbnRhdGlvbiwgZGVwdGgsIHJlZnMpO1xuICBpZiAocHJpbnRlZENoaWxkID09PSAnJyAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkICE9PSBudWxsICYmIGNoaWxkLm5vZGVUeXBlICE9PSBOb2RlVHlwZVRleHROb2RlKSB7XG4gICAgLy8gQSBwbHVnaW4gc2VyaWFsaXplZCB0aGlzIE5vZGUgdG8gJycgbWVhbmluZyB3ZSBzaG91bGQgaWdub3JlIGl0LlxuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gY29uZmlnLnNwYWNpbmdPdXRlciArIGluZGVudGF0aW9uICsgcHJpbnRlZENoaWxkO1xufSkuam9pbignJyk7XG5jb25zdCBwcmludFRleHQgPSAodGV4dCwgY29uZmlnKSA9PiB7XG4gIGNvbnN0IGNvbnRlbnRDb2xvciA9IGNvbmZpZy5jb2xvcnMuY29udGVudDtcbiAgcmV0dXJuIGNvbnRlbnRDb2xvci5vcGVuICsgZXNjYXBlSFRNTCh0ZXh0KSArIGNvbnRlbnRDb2xvci5jbG9zZTtcbn07XG5jb25zdCBwcmludENvbW1lbnQgPSAoY29tbWVudCwgY29uZmlnKSA9PiB7XG4gIGNvbnN0IGNvbW1lbnRDb2xvciA9IGNvbmZpZy5jb2xvcnMuY29tbWVudDtcbiAgcmV0dXJuIGNvbW1lbnRDb2xvci5vcGVuICsgJzwhLS0nICsgZXNjYXBlSFRNTChjb21tZW50KSArICctLT4nICsgY29tbWVudENvbG9yLmNsb3NlO1xufTtcblxuLy8gU2VwYXJhdGUgdGhlIGZ1bmN0aW9ucyB0byBmb3JtYXQgcHJvcHMsIGNoaWxkcmVuLCBhbmQgZWxlbWVudCxcbi8vIHNvIGEgcGx1Z2luIGNvdWxkIG92ZXJyaWRlIGEgcGFydGljdWxhciBmdW5jdGlvbiwgaWYgbmVlZGVkLlxuLy8gVG9vIGJhZCwgc28gc2FkOiB0aGUgdHJhZGl0aW9uYWwgKGJ1dCB1bm5lY2Vzc2FyeSkgc3BhY2Vcbi8vIGluIGEgc2VsZi1jbG9zaW5nIHRhZ0NvbG9yIHJlcXVpcmVzIGEgc2Vjb25kIHRlc3Qgb2YgcHJpbnRlZFByb3BzLlxuY29uc3QgcHJpbnRFbGVtZW50ID0gKHR5cGUsIHByaW50ZWRQcm9wcywgcHJpbnRlZENoaWxkcmVuLCBjb25maWcsIGluZGVudGF0aW9uKSA9PiB7XG4gIGNvbnN0IHRhZ0NvbG9yID0gY29uZmlnLmNvbG9ycy50YWc7XG4gIHJldHVybiB0YWdDb2xvci5vcGVuICsgJzwnICsgdHlwZSArIChwcmludGVkUHJvcHMgJiYgdGFnQ29sb3IuY2xvc2UgKyBwcmludGVkUHJvcHMgKyBjb25maWcuc3BhY2luZ091dGVyICsgaW5kZW50YXRpb24gKyB0YWdDb2xvci5vcGVuKSArIChwcmludGVkQ2hpbGRyZW4gPyAnPicgKyB0YWdDb2xvci5jbG9zZSArIHByaW50ZWRDaGlsZHJlbiArIGNvbmZpZy5zcGFjaW5nT3V0ZXIgKyBpbmRlbnRhdGlvbiArIHRhZ0NvbG9yLm9wZW4gKyAnPC8nICsgdHlwZSA6IChwcmludGVkUHJvcHMgJiYgIWNvbmZpZy5taW4gPyAnJyA6ICcgJykgKyAnLycpICsgJz4nICsgdGFnQ29sb3IuY2xvc2U7XG59O1xuY29uc3QgcHJpbnRFbGVtZW50QXNMZWFmID0gKHR5cGUsIGNvbmZpZykgPT4ge1xuICBjb25zdCB0YWdDb2xvciA9IGNvbmZpZy5jb2xvcnMudGFnO1xuICByZXR1cm4gdGFnQ29sb3Iub3BlbiArICc8JyArIHR5cGUgKyB0YWdDb2xvci5jbG9zZSArICcg4oCmJyArIHRhZ0NvbG9yLm9wZW4gKyAnIC8+JyArIHRhZ0NvbG9yLmNsb3NlO1xufTtcbmNvbnN0IEVMRU1FTlRfTk9ERSQxID0gMTtcbmNvbnN0IFRFWFRfTk9ERSQxID0gMztcbmNvbnN0IENPTU1FTlRfTk9ERSQxID0gODtcbmNvbnN0IEZSQUdNRU5UX05PREUgPSAxMTtcbmNvbnN0IEVMRU1FTlRfUkVHRVhQID0gL14oKEhUTUx8U1ZHKVxcdyopP0VsZW1lbnQkLztcbmNvbnN0IHRlc3ROb2RlID0gdmFsID0+IHtcbiAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gdmFsLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGNvbnN0IHtcbiAgICBub2RlVHlwZSxcbiAgICB0YWdOYW1lXG4gIH0gPSB2YWw7XG4gIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IHR5cGVvZiB0YWdOYW1lID09PSAnc3RyaW5nJyAmJiB0YWdOYW1lLmluY2x1ZGVzKCctJykgfHwgdHlwZW9mIHZhbC5oYXNBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbicgJiYgdmFsLmhhc0F0dHJpYnV0ZSgnaXMnKTtcbiAgcmV0dXJuIG5vZGVUeXBlID09PSBFTEVNRU5UX05PREUkMSAmJiAoRUxFTUVOVF9SRUdFWFAudGVzdChjb25zdHJ1Y3Rvck5hbWUpIHx8IGlzQ3VzdG9tRWxlbWVudCkgfHwgbm9kZVR5cGUgPT09IFRFWFRfTk9ERSQxICYmIGNvbnN0cnVjdG9yTmFtZSA9PT0gJ1RleHQnIHx8IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUkMSAmJiBjb25zdHJ1Y3Rvck5hbWUgPT09ICdDb21tZW50JyB8fCBub2RlVHlwZSA9PT0gRlJBR01FTlRfTk9ERSAmJiBjb25zdHJ1Y3Rvck5hbWUgPT09ICdEb2N1bWVudEZyYWdtZW50Jztcbn07XG5mdW5jdGlvbiBub2RlSXNUZXh0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSQxO1xufVxuZnVuY3Rpb24gbm9kZUlzQ29tbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUkMTtcbn1cbmZ1bmN0aW9uIG5vZGVJc0ZyYWdtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IEZSQUdNRU5UX05PREU7XG59XG5mdW5jdGlvbiBjcmVhdGVET01FbGVtZW50RmlsdGVyKGZpbHRlck5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZXN0OiB2YWwgPT4ge1xuICAgICAgdmFyIF92YWwkY29uc3RydWN0b3IyO1xuICAgICAgcmV0dXJuICh2YWwgPT0gbnVsbCA/IHZvaWQgMCA6IChfdmFsJGNvbnN0cnVjdG9yMiA9IHZhbC5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF92YWwkY29uc3RydWN0b3IyLm5hbWUpICYmIHRlc3ROb2RlKHZhbCk7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IChub2RlLCBjb25maWcsIGluZGVudGF0aW9uLCBkZXB0aCwgcmVmcywgcHJpbnRlcikgPT4ge1xuICAgICAgaWYgKG5vZGVJc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHByaW50VGV4dChub2RlLmRhdGEsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZUlzQ29tbWVudChub2RlKSkge1xuICAgICAgICByZXR1cm4gcHJpbnRDb21tZW50KG5vZGUuZGF0YSwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBub2RlSXNGcmFnbWVudChub2RlKSA/IFwiRG9jdW1lbnRGcmFnbWVudFwiIDogbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoKytkZXB0aCA+IGNvbmZpZy5tYXhEZXB0aCkge1xuICAgICAgICByZXR1cm4gcHJpbnRFbGVtZW50QXNMZWFmKHR5cGUsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJpbnRFbGVtZW50KHR5cGUsIHByaW50UHJvcHMobm9kZUlzRnJhZ21lbnQobm9kZSkgPyBbXSA6IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKS5tYXAoYXR0ciA9PiBhdHRyLm5hbWUpLnNvcnQoKSwgbm9kZUlzRnJhZ21lbnQobm9kZSkgPyB7fSA6IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKS5yZWR1Y2UoKHByb3BzLCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgcHJvcHNbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICB9LCB7fSksIGNvbmZpZywgaW5kZW50YXRpb24gKyBjb25maWcuaW5kZW50LCBkZXB0aCwgcmVmcywgcHJpbnRlciksIHByaW50Q2hpbGRyZW4oQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZS5jaGlsZE5vZGVzIHx8IG5vZGUuY2hpbGRyZW4pLmZpbHRlcihmaWx0ZXJOb2RlKSwgY29uZmlnLCBpbmRlbnRhdGlvbiArIGNvbmZpZy5pbmRlbnQsIGRlcHRoLCByZWZzLCBwcmludGVyKSwgY29uZmlnLCBpbmRlbnRhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBXZSB0cnkgdG8gbG9hZCBub2RlIGRlcGVuZGVuY2llc1xubGV0IGNoYWxrID0gbnVsbDtcbmxldCByZWFkRmlsZVN5bmMgPSBudWxsO1xubGV0IGNvZGVGcmFtZUNvbHVtbnMgPSBudWxsO1xudHJ5IHtcbiAgY29uc3Qgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlLnJlcXVpcmU7XG4gIHJlYWRGaWxlU3luYyA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAnZnMnKS5yZWFkRmlsZVN5bmM7XG4gIGNvZGVGcmFtZUNvbHVtbnMgPSBub2RlUmVxdWlyZS5jYWxsKG1vZHVsZSwgJ0BiYWJlbC9jb2RlLWZyYW1lJykuY29kZUZyYW1lQ29sdW1ucztcbiAgY2hhbGsgPSBub2RlUmVxdWlyZS5jYWxsKG1vZHVsZSwgJ2NoYWxrJyk7XG59IGNhdGNoIHtcbiAgLy8gV2UncmUgaW4gYSBicm93c2VyIGVudmlyb25tZW50XG59XG5cbi8vIGZyYW1lIGhhcyB0aGUgZm9ybSBcImF0IG15TWV0aG9kIChsb2NhdGlvbi90by9teS9maWxlLmpzOjEwOjIpXCJcbmZ1bmN0aW9uIGdldENvZGVGcmFtZShmcmFtZSkge1xuICBjb25zdCBsb2NhdGlvblN0YXJ0ID0gZnJhbWUuaW5kZXhPZignKCcpICsgMTtcbiAgY29uc3QgbG9jYXRpb25FbmQgPSBmcmFtZS5pbmRleE9mKCcpJyk7XG4gIGNvbnN0IGZyYW1lTG9jYXRpb24gPSBmcmFtZS5zbGljZShsb2NhdGlvblN0YXJ0LCBsb2NhdGlvbkVuZCk7XG4gIGNvbnN0IGZyYW1lTG9jYXRpb25FbGVtZW50cyA9IGZyYW1lTG9jYXRpb24uc3BsaXQoJzonKTtcbiAgY29uc3QgW2ZpbGVuYW1lLCBsaW5lLCBjb2x1bW5dID0gW2ZyYW1lTG9jYXRpb25FbGVtZW50c1swXSwgcGFyc2VJbnQoZnJhbWVMb2NhdGlvbkVsZW1lbnRzWzFdLCAxMCksIHBhcnNlSW50KGZyYW1lTG9jYXRpb25FbGVtZW50c1syXSwgMTApXTtcbiAgbGV0IHJhd0ZpbGVDb250ZW50cyA9ICcnO1xuICB0cnkge1xuICAgIHJhd0ZpbGVDb250ZW50cyA9IHJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0Zi04Jyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBjb2RlRnJhbWUgPSBjb2RlRnJhbWVDb2x1bW5zKHJhd0ZpbGVDb250ZW50cywge1xuICAgIHN0YXJ0OiB7XG4gICAgICBsaW5lLFxuICAgICAgY29sdW1uXG4gICAgfVxuICB9LCB7XG4gICAgaGlnaGxpZ2h0Q29kZTogdHJ1ZSxcbiAgICBsaW5lc0JlbG93OiAwXG4gIH0pO1xuICByZXR1cm4gY2hhbGsuZGltKGZyYW1lTG9jYXRpb24pICsgXCJcXG5cIiArIGNvZGVGcmFtZSArIFwiXFxuXCI7XG59XG5mdW5jdGlvbiBnZXRVc2VyQ29kZUZyYW1lKCkge1xuICAvLyBJZiB3ZSBjb3VsZG4ndCBsb2FkIGRlcGVuZGVuY2llcywgd2UgY2FuJ3QgZ2VuZXJhdGUgdGhlIHVzZXIgdHJhY2VcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFyZWFkRmlsZVN5bmMgfHwgIWNvZGVGcmFtZUNvbHVtbnMpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKCk7XG4gIGNvbnN0IGZpcnN0Q2xpZW50Q29kZUZyYW1lID0gZXJyLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxKSAvLyBSZW1vdmUgZmlyc3QgbGluZSB3aGljaCBoYXMgdGhlIGZvcm0gXCJFcnJvcjogVHlwZUVycm9yXCJcbiAgLmZpbmQoZnJhbWUgPT4gIWZyYW1lLmluY2x1ZGVzKCdub2RlX21vZHVsZXMvJykpOyAvLyBJZ25vcmUgZnJhbWVzIGZyb20gM3JkIHBhcnR5IGxpYnJhcmllc1xuXG4gIHJldHVybiBnZXRDb2RlRnJhbWUoZmlyc3RDbGllbnRDb2RlRnJhbWUpO1xufVxuXG4vLyBDb25zdGFudCBub2RlLm5vZGVUeXBlIGZvciB0ZXh0IG5vZGVzLCBzZWU6XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9ub2RlVHlwZSNOb2RlX3R5cGVfY29uc3RhbnRzXG5jb25zdCBURVhUX05PREUgPSAzO1xuZnVuY3Rpb24gamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgaWYgKHR5cGVvZiBqZXN0ICE9PSAndW5kZWZpbmVkJyAmJiBqZXN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGxlZ2FjeSB0aW1lcnNcbiAgICAgIHNldFRpbWVvdXQuX2lzTW9ja0Z1bmN0aW9uID09PSB0cnVlIHx8XG4gICAgICAvLyBtb2Rlcm4gdGltZXJzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLW9iamVjdC1oYXMtb3duIC0tIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIHN1cHBvcnQgbWF0cml4XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0VGltZW91dCwgJ2Nsb2NrJylcbiAgICApO1xuICB9XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBkZWZhdWx0IGNvbnRhaW5lcicpO1xuICB9XG4gIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlLmRlZmF1bHRWaWV3KSB7XG4gICAgLy8gbm9kZSBpcyBkb2N1bWVudFxuICAgIHJldHVybiBub2RlLmRlZmF1bHRWaWV3O1xuICB9IGVsc2UgaWYgKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcbiAgICAvLyBub2RlIGlzIGEgRE9NIG5vZGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB9IGVsc2UgaWYgKG5vZGUud2luZG93KSB7XG4gICAgLy8gbm9kZSBpcyB3aW5kb3dcbiAgICByZXR1cm4gbm9kZS53aW5kb3c7XG4gIH0gZWxzZSBpZiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGxvb2tzIGxpa2UgdGhlIHdpbmRvdyBvYmplY3QgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGhlIHByb3ZpZGVkIG5vZGUuXCIpO1xuICB9IGVsc2UgaWYgKG5vZGUudGhlbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UgcGFzc2VkIGEgUHJvbWlzZSBvYmplY3QgaW5zdGVhZCBvZiBhIERPTSBub2RlLiBEaWQgeW91IGRvIHNvbWV0aGluZyBsaWtlIGBmaXJlRXZlbnQuY2xpY2soc2NyZWVuLmZpbmRCeS4uLmAgd2hlbiB5b3UgbWVhbnQgdG8gdXNlIGEgYGdldEJ5YCBxdWVyeSBgZmlyZUV2ZW50LmNsaWNrKHNjcmVlbi5nZXRCeS4uLmAsIG9yIGF3YWl0IHRoZSBmaW5kQnkgcXVlcnkgYGZpcmVFdmVudC5jbGljayhhd2FpdCBzY3JlZW4uZmluZEJ5Li4uYD9cIik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGxvb2tzIGxpa2UgeW91IHBhc3NlZCBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgRE9NIG5vZGUuIERpZCB5b3UgZG8gc29tZXRoaW5nIGxpa2UgYGZpcmVFdmVudC5jbGljayhzY3JlZW4uZ2V0QWxsQnkuLi5gIHdoZW4geW91IG1lYW50IHRvIHVzZSBhIGBnZXRCeWAgcXVlcnkgYGZpcmVFdmVudC5jbGljayhzY3JlZW4uZ2V0QnkuLi5gP1wiKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygbm9kZS5sb2dUZXN0aW5nUGxheWdyb3VuZFVSTCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGxvb2tzIGxpa2UgeW91IHBhc3NlZCBhIGBzY3JlZW5gIG9iamVjdC4gRGlkIHlvdSBkbyBzb21ldGhpbmcgbGlrZSBgZmlyZUV2ZW50LmNsaWNrKHNjcmVlbiwgLi4uYCB3aGVuIHlvdSBtZWFudCB0byB1c2UgYSBxdWVyeSwgZS5nLiBgZmlyZUV2ZW50LmNsaWNrKHNjcmVlbi5nZXRCeS4uLiwgYD9cIik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHVzZXIgcGFzc2VkIHNvbWV0aGluZyB1bnVzdWFsIHRvIGEgY2FsbGluZyBmdW5jdGlvblxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBnaXZlbiBub2RlIGlzIG5vdCBhbiBFbGVtZW50LCB0aGUgbm9kZSB0eXBlIGlzOiBcIiArIHR5cGVvZiBub2RlICsgXCIuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0NvbnRhaW5lclR5cGUoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyIHx8ICEodHlwZW9mIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB8fCAhKHR5cGVvZiBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgY29udGFpbmVyIHRvIGJlIGFuIEVsZW1lbnQsIGEgRG9jdW1lbnQgb3IgYSBEb2N1bWVudEZyYWdtZW50IGJ1dCBnb3QgXCIgKyBnZXRUeXBlTmFtZShjb250YWluZXIpICsgXCIuXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFR5cGVOYW1lKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gbnVsbCA/ICdudWxsJyA6IG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdDtcbiAgfVxufVxuXG5jb25zdCBzaG91bGRIaWdobGlnaHQgPSAoKSA9PiB7XG4gIGxldCBjb2xvcnM7XG4gIHRyeSB7XG4gICAgdmFyIF9wcm9jZXNzLCBfcHJvY2VzcyRlbnY7XG4gICAgY29sb3JzID0gSlNPTi5wYXJzZSgoX3Byb2Nlc3MgPSBwcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogKF9wcm9jZXNzJGVudiA9IF9wcm9jZXNzLmVudikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9jZXNzJGVudi5DT0xPUlMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWYgdGhpcyB0aHJvd3MsIHByb2Nlc3M/LmVudj8uQ09MT1JTIHdhc24ndCBwYXJzYWJsZS4gU2luY2Ugd2Ugb25seVxuICAgIC8vIGNhcmUgYWJvdXQgYHRydWVgIG9yIGBmYWxzZWAsIHdlIGNhbiBzYWZlbHkgaWdub3JlIHRoZSBlcnJvci5cbiAgfVxuICBpZiAodHlwZW9mIGNvbG9ycyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gSWYgYGNvbG9yc2AgaXMgc2V0IGV4cGxpY2l0bHkgKGJvdGggYHRydWVgIGFuZCBgZmFsc2VgKSwgdXNlIHRoYXQgdmFsdWUuXG4gICAgcmV0dXJuIGNvbG9ycztcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBgY29sb3JzYCBpcyBub3Qgc2V0LCBjb2xvcml6ZSBpZiB3ZSdyZSBpbiBub2RlLlxuICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAhPT0gdW5kZWZpbmVkICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gdW5kZWZpbmVkO1xuICB9XG59O1xuY29uc3Qge1xuICBET01Db2xsZWN0aW9uXG59ID0gcHJldHR5Rm9ybWF0LnBsdWdpbnM7XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL25vZGVUeXBlI25vZGVfdHlwZV9jb25zdGFudHNcbmNvbnN0IEVMRU1FTlRfTk9ERSA9IDE7XG5jb25zdCBDT01NRU5UX05PREUgPSA4O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svamVzdC9ibG9iLzYxNTA4NDE5NWFlMWFlNjFkZGQ1NjE2MmM2MmJiZGRhMTc1ODc1NjkvcGFja2FnZXMvcHJldHR5LWZvcm1hdC9zcmMvcGx1Z2lucy9ET01FbGVtZW50LnRzI0w1MFxuZnVuY3Rpb24gZmlsdGVyQ29tbWVudHNBbmREZWZhdWx0SWdub3JlVGFnc1RhZ3ModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgJiYgKHZhbHVlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIXZhbHVlLm1hdGNoZXMoZ2V0Q29uZmlnKCkuZGVmYXVsdElnbm9yZSkpO1xufVxuZnVuY3Rpb24gcHJldHR5RE9NKGRvbSwgbWF4TGVuZ3RoLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKCFkb20pIHtcbiAgICBkb20gPSBnZXREb2N1bWVudCgpLmJvZHk7XG4gIH1cbiAgaWYgKHR5cGVvZiBtYXhMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgbWF4TGVuZ3RoID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52LkRFQlVHX1BSSU5UX0xJTUlUIHx8IDcwMDA7XG4gIH1cbiAgaWYgKG1heExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAoZG9tLmRvY3VtZW50RWxlbWVudCkge1xuICAgIGRvbSA9IGRvbS5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgbGV0IGRvbVR5cGVOYW1lID0gdHlwZW9mIGRvbTtcbiAgaWYgKGRvbVR5cGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGRvbVR5cGVOYW1lID0gZG9tLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gZG9uJ3QgZmFsbCB3aXRoIGBpbmAgb3BlcmF0b3JcbiAgICBkb20gPSB7fTtcbiAgfVxuICBpZiAoISgnb3V0ZXJIVE1MJyBpbiBkb20pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgYnV0IGdvdCBcIiArIGRvbVR5cGVOYW1lKTtcbiAgfVxuICBjb25zdCB7XG4gICAgZmlsdGVyTm9kZSA9IGZpbHRlckNvbW1lbnRzQW5kRGVmYXVsdElnbm9yZVRhZ3NUYWdzLFxuICAgIC4uLnByZXR0eUZvcm1hdE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRlYnVnQ29udGVudCA9IHByZXR0eUZvcm1hdC5mb3JtYXQoZG9tLCB7XG4gICAgcGx1Z2luczogW2NyZWF0ZURPTUVsZW1lbnRGaWx0ZXIoZmlsdGVyTm9kZSksIERPTUNvbGxlY3Rpb25dLFxuICAgIHByaW50RnVuY3Rpb25OYW1lOiBmYWxzZSxcbiAgICBoaWdobGlnaHQ6IHNob3VsZEhpZ2hsaWdodCgpLFxuICAgIC4uLnByZXR0eUZvcm1hdE9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBtYXhMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBkb20ub3V0ZXJIVE1MLmxlbmd0aCA+IG1heExlbmd0aCA/IGRlYnVnQ29udGVudC5zbGljZSgwLCBtYXhMZW5ndGgpICsgXCIuLi5cIiA6IGRlYnVnQ29udGVudDtcbn1cbmNvbnN0IGxvZ0RPTSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgdXNlckNvZGVGcmFtZSA9IGdldFVzZXJDb2RlRnJhbWUoKTtcbiAgaWYgKHVzZXJDb2RlRnJhbWUpIHtcbiAgICBjb25zb2xlLmxvZyhwcmV0dHlET00oLi4uYXJndW1lbnRzKSArIFwiXFxuXFxuXCIgKyB1c2VyQ29kZUZyYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhwcmV0dHlET00oLi4uYXJndW1lbnRzKSk7XG4gIH1cbn07XG5cbi8vIEl0IHdvdWxkIGJlIGNsZWFuZXIgZm9yIHRoaXMgdG8gbGl2ZSBpbnNpZGUgJy4vcXVlcmllcycsIGJ1dFxuLy8gb3RoZXIgcGFydHMgb2YgdGhlIGNvZGUgYXNzdW1lIHRoYXQgYWxsIGV4cG9ydHMgZnJvbVxuLy8gJy4vcXVlcmllcycgYXJlIHF1ZXJ5IGZ1bmN0aW9ucy5cbmxldCBjb25maWcgPSB7XG4gIHRlc3RJZEF0dHJpYnV0ZTogJ2RhdGEtdGVzdGlkJyxcbiAgYXN5bmNVdGlsVGltZW91dDogMTAwMCxcbiAgLy8gYXN5bmNXcmFwcGVyIGFuZCBhZHZhbmNlVGltZXJzV3JhcHBlciBpcyB0byBzdXBwb3J0IFJlYWN0J3MgYXN5bmMgYGFjdGAgZnVuY3Rpb24uXG4gIC8vIGZvcmNpbmcgcmVhY3QtdGVzdGluZy1saWJyYXJ5IHRvIHdyYXAgYWxsIGFzeW5jIGZ1bmN0aW9ucyB3b3VsZCd2ZSBiZWVuXG4gIC8vIGEgdG90YWwgbmlnaHRtYXJlIChjb25zaWRlciB3cmFwcGluZyBldmVyeSBmaW5kQnkqIHF1ZXJ5IGFuZCB0aGVuIGFsc29cbiAgLy8gdXBkYXRpbmcgYHdpdGhpbmAgc28gdGhvc2Ugd291bGQgYmUgd3JhcHBlZCB0b28uIFRvdGFsIG5pZ2h0bWFyZSkuXG4gIC8vIHNvIHdlIGhhdmUgdGhpcyBjb25maWcgb3B0aW9uIHRoYXQncyByZWFsbHkgb25seSBpbnRlbmRlZCBmb3JcbiAgLy8gcmVhY3QtdGVzdGluZy1saWJyYXJ5IHRvIHVzZS4gRm9yIHRoYXQgcmVhc29uLCB0aGlzIGZlYXR1cmUgd2lsbCByZW1haW5cbiAgLy8gdW5kb2N1bWVudGVkLlxuICBhc3luY1dyYXBwZXI6IGNiID0+IGNiKCksXG4gIHVuc3RhYmxlX2FkdmFuY2VUaW1lcnNXcmFwcGVyOiBjYiA9PiBjYigpLFxuICBldmVudFdyYXBwZXI6IGNiID0+IGNiKCksXG4gIC8vIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBgaGlkZGVuYCBvcHRpb24gaW4gYEJ5Um9sZWAgcXVlcmllc1xuICBkZWZhdWx0SGlkZGVuOiBmYWxzZSxcbiAgLy8gZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGBpZ25vcmVgIG9wdGlvbiBpbiBgQnlUZXh0YCBxdWVyaWVzXG4gIGRlZmF1bHRJZ25vcmU6ICdzY3JpcHQsIHN0eWxlJyxcbiAgLy8gc2hvd09yaWdpbmFsU3RhY2tUcmFjZSBmbGFnIHRvIHNob3cgdGhlIGZ1bGwgZXJyb3Igc3RhY2sgdHJhY2VzIGZvciBhc3luYyBlcnJvcnNcbiAgc2hvd09yaWdpbmFsU3RhY2tUcmFjZTogZmFsc2UsXG4gIC8vIHRocm93IGVycm9ycyB3LyBzdWdnZXN0aW9ucyBmb3IgYmV0dGVyIHF1ZXJpZXMuIE9wdCBpbiBzbyBvZmYgYnkgZGVmYXVsdC5cbiAgdGhyb3dTdWdnZXN0aW9uczogZmFsc2UsXG4gIC8vIGNhbGxlZCB3aGVuIGdldEJ5KiBxdWVyaWVzIGZhaWwuIChtZXNzYWdlLCBjb250YWluZXIpID0+IEVycm9yXG4gIGdldEVsZW1lbnRFcnJvcihtZXNzYWdlLCBjb250YWluZXIpIHtcbiAgICBjb25zdCBwcmV0dGlmaWVkRE9NID0gcHJldHR5RE9NKGNvbnRhaW5lcik7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoW21lc3NhZ2UsIFwiSWdub3JlZCBub2RlczogY29tbWVudHMsIFwiICsgY29uZmlnLmRlZmF1bHRJZ25vcmUgKyBcIlxcblwiICsgcHJldHRpZmllZERPTV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcblxcbicpKTtcbiAgICBlcnJvci5uYW1lID0gJ1Rlc3RpbmdMaWJyYXJ5RWxlbWVudEVycm9yJztcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0sXG4gIF9kaXNhYmxlRXhwZW5zaXZlRXJyb3JEaWFnbm9zdGljczogZmFsc2UsXG4gIGNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzOiBmYWxzZVxufTtcbmZ1bmN0aW9uIHJ1bldpdGhFeHBlbnNpdmVFcnJvckRpYWdub3N0aWNzRGlzYWJsZWQoY2FsbGJhY2spIHtcbiAgdHJ5IHtcbiAgICBjb25maWcuX2Rpc2FibGVFeHBlbnNpdmVFcnJvckRpYWdub3N0aWNzID0gdHJ1ZTtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25maWcuX2Rpc2FibGVFeHBlbnNpdmVFcnJvckRpYWdub3N0aWNzID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZShuZXdDb25maWcpIHtcbiAgaWYgKHR5cGVvZiBuZXdDb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBQYXNzIHRoZSBleGlzdGluZyBjb25maWcgb3V0IHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvblxuICAgIC8vIGFuZCBhY2NlcHQgYSBkZWx0YSBpbiByZXR1cm5cbiAgICBuZXdDb25maWcgPSBuZXdDb25maWcoY29uZmlnKTtcbiAgfVxuXG4gIC8vIE1lcmdlIHRoZSBpbmNvbWluZyBjb25maWcgZGVsdGFcbiAgY29uZmlnID0ge1xuICAgIC4uLmNvbmZpZyxcbiAgICAuLi5uZXdDb25maWdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbmZpZygpIHtcbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuY29uc3QgbGFiZWxsZWROb2RlTmFtZXMgPSBbJ2J1dHRvbicsICdtZXRlcicsICdvdXRwdXQnLCAncHJvZ3Jlc3MnLCAnc2VsZWN0JywgJ3RleHRhcmVhJywgJ2lucHV0J107XG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudChub2RlKSB7XG4gIGlmIChsYWJlbGxlZE5vZGVOYW1lcy5pbmNsdWRlcyhub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHJldHVybiBub2RlLnRleHRDb250ZW50O1xuICByZXR1cm4gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLm1hcChjaGlsZE5vZGUgPT4gZ2V0VGV4dENvbnRlbnQoY2hpbGROb2RlKSkuam9pbignJyk7XG59XG5mdW5jdGlvbiBnZXRMYWJlbENvbnRlbnQoZWxlbWVudCkge1xuICBsZXQgdGV4dENvbnRlbnQ7XG4gIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xhYmVsJykge1xuICAgIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LnZhbHVlIHx8IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRleHRDb250ZW50O1xufVxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXBzMWxvbi9kb20tYWNjZXNzaWJpbGl0eS1hcGkvcHVsbC8zNTJcbmZ1bmN0aW9uIGdldFJlYWxMYWJlbHMoZWxlbWVudCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSB0eXBlcyBhcmUgbm90IGF3YXJlIG9mIG9sZGVyIGJyb3dzZXJzIHRoYXQgZG9uJ3QgaW1wbGVtZW50IGBsYWJlbHNgXG4gIGlmIChlbGVtZW50LmxhYmVscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9sYWJlbHM7XG4gICAgcmV0dXJuIChfbGFiZWxzID0gZWxlbWVudC5sYWJlbHMpICE9IG51bGwgPyBfbGFiZWxzIDogW107XG4gIH1cbiAgaWYgKCFpc0xhYmVsYWJsZShlbGVtZW50KSkgcmV0dXJuIFtdO1xuICBjb25zdCBsYWJlbHMgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGFiZWwnKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obGFiZWxzKS5maWx0ZXIobGFiZWwgPT4gbGFiZWwuY29udHJvbCA9PT0gZWxlbWVudCk7XG59XG5mdW5jdGlvbiBpc0xhYmVsYWJsZShlbGVtZW50KSB7XG4gIHJldHVybiAvQlVUVE9OfE1FVEVSfE9VVFBVVHxQUk9HUkVTU3xTRUxFQ1R8VEVYVEFSRUEvLnRlc3QoZWxlbWVudC50YWdOYW1lKSB8fCBlbGVtZW50LnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSAhPT0gJ2hpZGRlbic7XG59XG5mdW5jdGlvbiBnZXRMYWJlbHMoY29udGFpbmVyLCBlbGVtZW50LCBfdGVtcCkge1xuICBsZXQge1xuICAgIHNlbGVjdG9yID0gJyonXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgYXJpYUxhYmVsbGVkQnkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gIGNvbnN0IGxhYmVsc0lkID0gYXJpYUxhYmVsbGVkQnkgPyBhcmlhTGFiZWxsZWRCeS5zcGxpdCgnICcpIDogW107XG4gIHJldHVybiBsYWJlbHNJZC5sZW5ndGggPyBsYWJlbHNJZC5tYXAobGFiZWxJZCA9PiB7XG4gICAgY29uc3QgbGFiZWxsaW5nRWxlbWVudCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2lkPVxcXCJcIiArIGxhYmVsSWQgKyBcIlxcXCJdXCIpO1xuICAgIHJldHVybiBsYWJlbGxpbmdFbGVtZW50ID8ge1xuICAgICAgY29udGVudDogZ2V0TGFiZWxDb250ZW50KGxhYmVsbGluZ0VsZW1lbnQpLFxuICAgICAgZm9ybUNvbnRyb2w6IG51bGxcbiAgICB9IDoge1xuICAgICAgY29udGVudDogJycsXG4gICAgICBmb3JtQ29udHJvbDogbnVsbFxuICAgIH07XG4gIH0pIDogQXJyYXkuZnJvbShnZXRSZWFsTGFiZWxzKGVsZW1lbnQpKS5tYXAobGFiZWwgPT4ge1xuICAgIGNvbnN0IHRleHRUb01hdGNoID0gZ2V0TGFiZWxDb250ZW50KGxhYmVsKTtcbiAgICBjb25zdCBmb3JtQ29udHJvbFNlbGVjdG9yID0gJ2J1dHRvbiwgaW5wdXQsIG1ldGVyLCBvdXRwdXQsIHByb2dyZXNzLCBzZWxlY3QsIHRleHRhcmVhJztcbiAgICBjb25zdCBsYWJlbGxlZEZvcm1Db250cm9sID0gQXJyYXkuZnJvbShsYWJlbC5xdWVyeVNlbGVjdG9yQWxsKGZvcm1Db250cm9sU2VsZWN0b3IpKS5maWx0ZXIoZm9ybUNvbnRyb2xFbGVtZW50ID0+IGZvcm1Db250cm9sRWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSlbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IHRleHRUb01hdGNoLFxuICAgICAgZm9ybUNvbnRyb2w6IGxhYmVsbGVkRm9ybUNvbnRyb2xcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm90TnVsbE9yVW5kZWZpbmVkKG1hdGNoZXIpIHtcbiAgaWYgKG1hdGNoZXIgPT09IG51bGwgfHwgbWF0Y2hlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zIC0tIGltcGxpY2l0bHkgY29udmVydGluZyBgVGAgdG8gYHN0cmluZ2BcbiAgICBcIkl0IGxvb2tzIGxpa2UgXCIgKyBtYXRjaGVyICsgXCIgd2FzIHBhc3NlZCBpbnN0ZWFkIG9mIGEgbWF0Y2hlci4gRGlkIHlvdSBkbyBzb21ldGhpbmcgbGlrZSBnZXRCeVRleHQoXCIgKyBtYXRjaGVyICsgXCIpP1wiKTtcbiAgfVxufVxuZnVuY3Rpb24gZnV6enlNYXRjaGVzKHRleHRUb01hdGNoLCBub2RlLCBtYXRjaGVyLCBub3JtYWxpemVyKSB7XG4gIGlmICh0eXBlb2YgdGV4dFRvTWF0Y2ggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzc2VydE5vdE51bGxPclVuZGVmaW5lZChtYXRjaGVyKTtcbiAgY29uc3Qgbm9ybWFsaXplZFRleHQgPSBub3JtYWxpemVyKHRleHRUb01hdGNoKTtcbiAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWF0Y2hlciA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplZFRleHQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhtYXRjaGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF0Y2hlcihub3JtYWxpemVkVGV4dCwgbm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoUmVnRXhwKG1hdGNoZXIsIG5vcm1hbGl6ZWRUZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gbWF0Y2hlcyh0ZXh0VG9NYXRjaCwgbm9kZSwgbWF0Y2hlciwgbm9ybWFsaXplcikge1xuICBpZiAodHlwZW9mIHRleHRUb01hdGNoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3NlcnROb3ROdWxsT3JVbmRlZmluZWQobWF0Y2hlcik7XG4gIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gbm9ybWFsaXplcih0ZXh0VG9NYXRjaCk7XG4gIGlmIChtYXRjaGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gbWF0Y2hlcihub3JtYWxpemVkVGV4dCwgbm9kZSk7XG4gIH0gZWxzZSBpZiAobWF0Y2hlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBtYXRjaFJlZ0V4cChtYXRjaGVyLCBub3JtYWxpemVkVGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUZXh0ID09PSBTdHJpbmcobWF0Y2hlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERlZmF1bHROb3JtYWxpemVyKF90ZW1wKSB7XG4gIGxldCB7XG4gICAgdHJpbSA9IHRydWUsXG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlID0gdHJ1ZVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIHJldHVybiB0ZXh0ID0+IHtcbiAgICBsZXQgbm9ybWFsaXplZFRleHQgPSB0ZXh0O1xuICAgIG5vcm1hbGl6ZWRUZXh0ID0gdHJpbSA/IG5vcm1hbGl6ZWRUZXh0LnRyaW0oKSA6IG5vcm1hbGl6ZWRUZXh0O1xuICAgIG5vcm1hbGl6ZWRUZXh0ID0gY29sbGFwc2VXaGl0ZXNwYWNlID8gbm9ybWFsaXplZFRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpIDogbm9ybWFsaXplZFRleHQ7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUZXh0O1xuICB9O1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBub3JtYWxpemVyIHRvIHBhc3MgdG8gZnVuY3Rpb25zIGluIG1hdGNoZXMuanNcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IHRyaW0gVGhlIHVzZXItc3BlY2lmaWVkIHZhbHVlIGZvciBgdHJpbWAsIHdpdGhvdXRcbiAqIGFueSBkZWZhdWx0aW5nIGhhdmluZyBiZWVuIGFwcGxpZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IGNvbGxhcHNlV2hpdGVzcGFjZSBUaGUgdXNlci1zcGVjaWZpZWQgdmFsdWUgZm9yXG4gKiBgY29sbGFwc2VXaGl0ZXNwYWNlYCwgd2l0aG91dCBhbnkgZGVmYXVsdGluZyBoYXZpbmcgYmVlbiBhcHBsaWVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufHVuZGVmaW5lZH0gbm9ybWFsaXplciBUaGUgdXNlci1zcGVjaWZpZWQgbm9ybWFsaXplclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5vcm1hbGl6ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYWtlTm9ybWFsaXplcihfcmVmKSB7XG4gIGxldCB7XG4gICAgdHJpbSxcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgbm9ybWFsaXplclxuICB9ID0gX3JlZjtcbiAgaWYgKCFub3JtYWxpemVyKSB7XG4gICAgLy8gTm8gY3VzdG9tIG5vcm1hbGl6ZXIgc3BlY2lmaWVkLiBKdXN0IHVzZSBkZWZhdWx0LlxuICAgIHJldHVybiBnZXREZWZhdWx0Tm9ybWFsaXplcih7XG4gICAgICB0cmltLFxuICAgICAgY29sbGFwc2VXaGl0ZXNwYWNlXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0cmltICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY29sbGFwc2VXaGl0ZXNwYWNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRoZXkndmUgYWxzbyBzcGVjaWZpZWQgYSB2YWx1ZSBmb3IgdHJpbSBvciBjb2xsYXBzZVdoaXRlc3BhY2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyaW0gYW5kIGNvbGxhcHNlV2hpdGVzcGFjZSBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGEgbm9ybWFsaXplci4gJyArICdJZiB5b3Ugd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgdHJpbSBhbmQgY29sbGFwc2VXaGl0ZXNwYWNlIGxvZ2ljIGluIHlvdXIgbm9ybWFsaXplciwgJyArICd1c2UgXCJnZXREZWZhdWx0Tm9ybWFsaXplcih7dHJpbSwgY29sbGFwc2VXaGl0ZXNwYWNlfSlcIiBhbmQgY29tcG9zZSB0aGF0IGludG8geW91ciBub3JtYWxpemVyJyk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZXI7XG59XG5mdW5jdGlvbiBtYXRjaFJlZ0V4cChtYXRjaGVyLCB0ZXh0KSB7XG4gIGNvbnN0IG1hdGNoID0gbWF0Y2hlci50ZXN0KHRleHQpO1xuICBpZiAobWF0Y2hlci5nbG9iYWwgJiYgbWF0Y2hlci5sYXN0SW5kZXggIT09IDApIHtcbiAgICBjb25zb2xlLndhcm4oXCJUbyBtYXRjaCBhbGwgZWxlbWVudHMgd2UgaGFkIHRvIHJlc2V0IHRoZSBsYXN0SW5kZXggb2YgdGhlIFJlZ0V4cCBiZWNhdXNlIHRoZSBnbG9iYWwgZmxhZyBpcyBlbmFibGVkLiBXZSBlbmNvdXJhZ2UgdG8gcmVtb3ZlIHRoZSBnbG9iYWwgZmxhZyBmcm9tIHRoZSBSZWdFeHAuXCIpO1xuICAgIG1hdGNoZXIubGFzdEluZGV4ID0gMDtcbiAgfVxuICByZXR1cm4gbWF0Y2g7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVUZXh0KG5vZGUpIHtcbiAgaWYgKG5vZGUubWF0Y2hlcygnaW5wdXRbdHlwZT1zdWJtaXRdLCBpbnB1dFt0eXBlPWJ1dHRvbl0sIGlucHV0W3R5cGU9cmVzZXRdJykpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFICYmIEJvb2xlYW4oY2hpbGQudGV4dENvbnRlbnQpKS5tYXAoYyA9PiBjLnRleHRDb250ZW50KS5qb2luKCcnKTtcbn1cblxuY29uc3QgZWxlbWVudFJvbGVMaXN0ID0gYnVpbGRFbGVtZW50Um9sZUxpc3QoZWxlbWVudFJvbGVzKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gYHRydWVgIGlmIGBlbGVtZW50YCBhbmQgaXRzIHN1YnRyZWUgYXJlIGluYWNjZXNzaWJsZVxuICovXG5mdW5jdGlvbiBpc1N1YnRyZWVJbmFjY2Vzc2libGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5oaWRkZW4gPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQYXJ0aWFsIGltcGxlbWVudGF0aW9uIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS0xLjIvI3RyZWVfZXhjbHVzaW9uXG4gKiB3aGljaCBzaG91bGQgb25seSBiZSB1c2VkIGZvciBlbGVtZW50cyB3aXRoIGEgbm9uLXByZXNlbnRhdGlvbmFsIHJvbGUgaS5lLlxuICogYHJvbGU9XCJub25lXCJgIGFuZCBgcm9sZT1cInByZXNlbnRhdGlvblwiYCB3aWxsIG5vdCBiZSBleGNsdWRlZC5cbiAqXG4gKiBJbXBsZW1lbnRzIGFyaWEtaGlkZGVuIHNlbWFudGljcyAoaS5lLiBwYXJlbnQgb3ZlcnJpZGVzIGNoaWxkKVxuICogSWdub3JlcyBcIkNoaWxkIFByZXNlbnRhdGlvbmFsOiBUcnVlXCIgY2hhcmFjdGVyaXN0aWNzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLVxuICogQHBhcmFtIHtmdW5jdGlvbiAoZWxlbWVudDogRWxlbWVudCk6IGJvb2xlYW59IG9wdGlvbnMuaXNTdWJ0cmVlSW5hY2Nlc3NpYmxlIC1cbiAqIGNhbiBiZSB1c2VkIHRvIHJldHVybiBjYWNoZWQgcmVzdWx0cyBmcm9tIHByZXZpb3VzIGlzU3VidHJlZUluYWNjZXNzaWJsZSBjYWxsc1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZXhjbHVkZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0luYWNjZXNzaWJsZShlbGVtZW50LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzU3VidHJlZUluYWNjZXNzaWJsZTogaXNTdWJ0cmVlSW5hY2Nlc3NpYmxlSW1wbCA9IGlzU3VidHJlZUluYWNjZXNzaWJsZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAvLyBzaW5jZSB2aXNpYmlsaXR5IGlzIGluaGVyaXRlZCB3ZSBjYW4gZXhpdCBlYXJseVxuICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBsZXQgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB3aGlsZSAoY3VycmVudEVsZW1lbnQpIHtcbiAgICBpZiAoaXNTdWJ0cmVlSW5hY2Nlc3NpYmxlSW1wbChjdXJyZW50RWxlbWVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0SW1wbGljaXRBcmlhUm9sZXMoY3VycmVudE5vZGUpIHtcbiAgLy8gZXNsaW50IGJ1ZyBoZXJlOlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZm9yIChjb25zdCB7XG4gICAgbWF0Y2gsXG4gICAgcm9sZXNcbiAgfSBvZiBlbGVtZW50Um9sZUxpc3QpIHtcbiAgICBpZiAobWF0Y2goY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gWy4uLnJvbGVzXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gYnVpbGRFbGVtZW50Um9sZUxpc3QoZWxlbWVudFJvbGVzTWFwKSB7XG4gIGZ1bmN0aW9uIG1ha2VFbGVtZW50U2VsZWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBuYW1lLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBcIlwiICsgbmFtZSArIGF0dHJpYnV0ZXMubWFwKF9yZWYyID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIG5hbWU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjb25zdHJhaW50cyA9IFtdXG4gICAgICB9ID0gX3JlZjI7XG4gICAgICBjb25zdCBzaG91bGROb3RFeGlzdCA9IGNvbnN0cmFpbnRzLmluZGV4T2YoJ3VuZGVmaW5lZCcpICE9PSAtMTtcbiAgICAgIGlmIChzaG91bGROb3RFeGlzdCkge1xuICAgICAgICByZXR1cm4gXCI6bm90KFtcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIl0pXCI7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBcIltcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIl1cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIltcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIl1cIjtcbiAgICAgIH1cbiAgICB9KS5qb2luKCcnKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTZWxlY3RvclNwZWNpZmljaXR5KF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBbXVxuICAgIH0gPSBfcmVmMztcbiAgICByZXR1cm4gYXR0cmlidXRlcy5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gYnlTZWxlY3RvclNwZWNpZmljaXR5KF9yZWY0LCBfcmVmNSkge1xuICAgIGxldCB7XG4gICAgICBzcGVjaWZpY2l0eTogbGVmdFNwZWNpZmljaXR5XG4gICAgfSA9IF9yZWY0O1xuICAgIGxldCB7XG4gICAgICBzcGVjaWZpY2l0eTogcmlnaHRTcGVjaWZpY2l0eVxuICAgIH0gPSBfcmVmNTtcbiAgICByZXR1cm4gcmlnaHRTcGVjaWZpY2l0eSAtIGxlZnRTcGVjaWZpY2l0eTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaChlbGVtZW50KSB7XG4gICAgbGV0IHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBbXVxuICAgIH0gPSBlbGVtZW50O1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Rlc3RpbmctbGlicmFyeS9kb20tdGVzdGluZy1saWJyYXJ5L2lzc3Vlcy84MTRcbiAgICBjb25zdCB0eXBlVGV4dEluZGV4ID0gYXR0cmlidXRlcy5maW5kSW5kZXgoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS52YWx1ZSAmJiBhdHRyaWJ1dGUubmFtZSA9PT0gJ3R5cGUnICYmIGF0dHJpYnV0ZS52YWx1ZSA9PT0gJ3RleHQnKTtcbiAgICBpZiAodHlwZVRleHRJbmRleCA+PSAwKSB7XG4gICAgICAvLyBub3QgdXNpbmcgc3BsaWNlIHRvIG5vdCBtdXRhdGUgdGhlIGF0dHJpYnV0ZXMgYXJyYXlcbiAgICAgIGF0dHJpYnV0ZXMgPSBbLi4uYXR0cmlidXRlcy5zbGljZSgwLCB0eXBlVGV4dEluZGV4KSwgLi4uYXR0cmlidXRlcy5zbGljZSh0eXBlVGV4dEluZGV4ICsgMSldO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RvciA9IG1ha2VFbGVtZW50U2VsZWN0b3Ioe1xuICAgICAgLi4uZWxlbWVudCxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICBpZiAodHlwZVRleHRJbmRleCA+PSAwICYmIG5vZGUudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH07XG4gIH1cbiAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gIC8vIGVzbGludCBidWcgaGVyZTpcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGZvciAoY29uc3QgW2VsZW1lbnQsIHJvbGVzXSBvZiBlbGVtZW50Um9sZXNNYXAuZW50cmllcygpKSB7XG4gICAgcmVzdWx0ID0gWy4uLnJlc3VsdCwge1xuICAgICAgbWF0Y2g6IG1hdGNoKGVsZW1lbnQpLFxuICAgICAgcm9sZXM6IEFycmF5LmZyb20ocm9sZXMpLFxuICAgICAgc3BlY2lmaWNpdHk6IGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoZWxlbWVudClcbiAgICB9XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnNvcnQoYnlTZWxlY3RvclNwZWNpZmljaXR5KTtcbn1cbmZ1bmN0aW9uIGdldFJvbGVzKGNvbnRhaW5lciwgX3RlbXApIHtcbiAgbGV0IHtcbiAgICBoaWRkZW4gPSBmYWxzZVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGZ1bmN0aW9uIGZsYXR0ZW5ET00obm9kZSkge1xuICAgIHJldHVybiBbbm9kZSwgLi4uQXJyYXkuZnJvbShub2RlLmNoaWxkcmVuKS5yZWR1Y2UoKGFjYywgY2hpbGQpID0+IFsuLi5hY2MsIC4uLmZsYXR0ZW5ET00oY2hpbGQpXSwgW10pXTtcbiAgfVxuICByZXR1cm4gZmxhdHRlbkRPTShjb250YWluZXIpLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICByZXR1cm4gaGlkZGVuID09PSBmYWxzZSA/IGlzSW5hY2Nlc3NpYmxlKGVsZW1lbnQpID09PSBmYWxzZSA6IHRydWU7XG4gIH0pLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgbGV0IHJvbGVzID0gW107XG4gICAgLy8gVE9ETzogVGhpcyB2aW9sYXRlcyBodG1sLWFyaWEgd2hpY2ggZG9lcyBub3QgYWxsb3cgYW55IHJvbGUgb24gZXZlcnkgZWxlbWVudFxuICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZSgncm9sZScpKSB7XG4gICAgICByb2xlcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdyb2xlJykuc3BsaXQoJyAnKS5zbGljZSgwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9sZXMgPSBnZXRJbXBsaWNpdEFyaWFSb2xlcyhub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvbGVzLnJlZHVjZSgocm9sZXNBY2MsIHJvbGUpID0+IEFycmF5LmlzQXJyYXkocm9sZXNBY2Nbcm9sZV0pID8ge1xuICAgICAgLi4ucm9sZXNBY2MsXG4gICAgICBbcm9sZV06IFsuLi5yb2xlc0FjY1tyb2xlXSwgbm9kZV1cbiAgICB9IDoge1xuICAgICAgLi4ucm9sZXNBY2MsXG4gICAgICBbcm9sZV06IFtub2RlXVxuICAgIH0sIGFjYyk7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHByZXR0eVJvbGVzKGRvbSwgX3JlZjYpIHtcbiAgbGV0IHtcbiAgICBoaWRkZW4sXG4gICAgaW5jbHVkZURlc2NyaXB0aW9uXG4gIH0gPSBfcmVmNjtcbiAgY29uc3Qgcm9sZXMgPSBnZXRSb2xlcyhkb20sIHtcbiAgICBoaWRkZW5cbiAgfSk7XG4gIC8vIFdlIHByZWZlciB0byBza2lwIGdlbmVyaWMgcm9sZSwgd2UgZG9uJ3QgcmVjb21tZW5kIGl0XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyb2xlcykuZmlsdGVyKF9yZWY3ID0+IHtcbiAgICBsZXQgW3JvbGVdID0gX3JlZjc7XG4gICAgcmV0dXJuIHJvbGUgIT09ICdnZW5lcmljJztcbiAgfSkubWFwKF9yZWY4ID0+IHtcbiAgICBsZXQgW3JvbGUsIGVsZW1lbnRzXSA9IF9yZWY4O1xuICAgIGNvbnN0IGRlbGltaXRlckJhciA9ICctJy5yZXBlYXQoNTApO1xuICAgIGNvbnN0IGVsZW1lbnRzU3RyaW5nID0gZWxlbWVudHMubWFwKGVsID0+IHtcbiAgICAgIGNvbnN0IG5hbWVTdHJpbmcgPSBcIk5hbWUgXFxcIlwiICsgY29tcHV0ZUFjY2Vzc2libGVOYW1lKGVsLCB7XG4gICAgICAgIGNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzOiBnZXRDb25maWcoKS5jb21wdXRlZFN0eWxlU3VwcG9ydHNQc2V1ZG9FbGVtZW50c1xuICAgICAgfSkgKyBcIlxcXCI6XFxuXCI7XG4gICAgICBjb25zdCBkb21TdHJpbmcgPSBwcmV0dHlET00oZWwuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICBpZiAoaW5jbHVkZURlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uU3RyaW5nID0gXCJEZXNjcmlwdGlvbiBcXFwiXCIgKyBjb21wdXRlQWNjZXNzaWJsZURlc2NyaXB0aW9uKGVsLCB7XG4gICAgICAgICAgY29tcHV0ZWRTdHlsZVN1cHBvcnRzUHNldWRvRWxlbWVudHM6IGdldENvbmZpZygpLmNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzXG4gICAgICAgIH0pICsgXCJcXFwiOlxcblwiO1xuICAgICAgICByZXR1cm4gXCJcIiArIG5hbWVTdHJpbmcgKyBkZXNjcmlwdGlvblN0cmluZyArIGRvbVN0cmluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiICsgbmFtZVN0cmluZyArIGRvbVN0cmluZztcbiAgICB9KS5qb2luKCdcXG5cXG4nKTtcbiAgICByZXR1cm4gcm9sZSArIFwiOlxcblxcblwiICsgZWxlbWVudHNTdHJpbmcgKyBcIlxcblxcblwiICsgZGVsaW1pdGVyQmFyO1xuICB9KS5qb2luKCdcXG4nKTtcbn1cbmNvbnN0IGxvZ1JvbGVzID0gZnVuY3Rpb24gKGRvbSwgX3RlbXAyKSB7XG4gIGxldCB7XG4gICAgaGlkZGVuID0gZmFsc2VcbiAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gIHJldHVybiBjb25zb2xlLmxvZyhwcmV0dHlSb2xlcyhkb20sIHtcbiAgICBoaWRkZW5cbiAgfSkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge2Jvb2xlYW4gfCB1bmRlZmluZWR9IC0gZmFsc2UvdHJ1ZSBpZiAobm90KXNlbGVjdGVkLCB1bmRlZmluZWQgaWYgbm90IHNlbGVjdGFibGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUFyaWFTZWxlY3RlZChlbGVtZW50KSB7XG4gIC8vIGltcGxpY2l0IHZhbHVlIGZyb20gaHRtbC1hYW0gbWFwcGluZ3M6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sLWFhbS0xLjAvI2h0bWwtYXR0cmlidXRlLXN0YXRlLWFuZC1wcm9wZXJ0eS1tYXBwaW5nc1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hYW0tMS4wLyNkZXRhaWxzLWlkLTk3XG4gIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuc2VsZWN0ZWQ7XG4gIH1cblxuICAvLyBleHBsaWNpdCB2YWx1ZVxuICByZXR1cm4gY2hlY2tCb29sZWFuQXR0cmlidXRlKGVsZW1lbnQsICdhcmlhLXNlbGVjdGVkJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC1cbiAqIEByZXR1cm5zIHtib29sZWFufSAtXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBcmlhQnVzeShlbGVtZW50KSB7XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS0xLjEvI2FyaWEtYnVzeVxuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpID09PSAndHJ1ZSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC1cbiAqIEByZXR1cm5zIHtib29sZWFuIHwgdW5kZWZpbmVkfSAtIGZhbHNlL3RydWUgaWYgKG5vdCljaGVja2VkLCB1bmRlZmluZWQgaWYgbm90IGNoZWNrZWQtYWJsZVxuICovXG5mdW5jdGlvbiBjb21wdXRlQXJpYUNoZWNrZWQoZWxlbWVudCkge1xuICAvLyBpbXBsaWNpdCB2YWx1ZSBmcm9tIGh0bWwtYWFtIG1hcHBpbmdzOiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hYW0tMS4wLyNodG1sLWF0dHJpYnV0ZS1zdGF0ZS1hbmQtcHJvcGVydHktbWFwcGluZ3NcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWwtYWFtLTEuMC8jZGV0YWlscy1pZC01NlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hYW0tMS4wLyNkZXRhaWxzLWlkLTY3XG4gIGlmICgnaW5kZXRlcm1pbmF0ZScgaW4gZWxlbWVudCAmJiBlbGVtZW50LmluZGV0ZXJtaW5hdGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICgnY2hlY2tlZCcgaW4gZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoZWNrZWQ7XG4gIH1cblxuICAvLyBleHBsaWNpdCB2YWx1ZVxuICByZXR1cm4gY2hlY2tCb29sZWFuQXR0cmlidXRlKGVsZW1lbnQsICdhcmlhLWNoZWNrZWQnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge2Jvb2xlYW4gfCB1bmRlZmluZWR9IC0gZmFsc2UvdHJ1ZSBpZiAobm90KXByZXNzZWQsIHVuZGVmaW5lZCBpZiBub3QgcHJlc3MtYWJsZVxuICovXG5mdW5jdGlvbiBjb21wdXRlQXJpYVByZXNzZWQoZWxlbWVudCkge1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtMS4xLyNhcmlhLXByZXNzZWRcbiAgcmV0dXJuIGNoZWNrQm9vbGVhbkF0dHJpYnV0ZShlbGVtZW50LCAnYXJpYS1wcmVzc2VkJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC1cbiAqIEByZXR1cm5zIHtib29sZWFuIHwgc3RyaW5nIHwgbnVsbH0gLVxuICovXG5mdW5jdGlvbiBjb21wdXRlQXJpYUN1cnJlbnQoZWxlbWVudCkge1xuICB2YXIgX3JlZjksIF9jaGVja0Jvb2xlYW5BdHRyaWJ1dDtcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLTEuMS8jYXJpYS1jdXJyZW50XG4gIHJldHVybiAoX3JlZjkgPSAoX2NoZWNrQm9vbGVhbkF0dHJpYnV0ID0gY2hlY2tCb29sZWFuQXR0cmlidXRlKGVsZW1lbnQsICdhcmlhLWN1cnJlbnQnKSkgIT0gbnVsbCA/IF9jaGVja0Jvb2xlYW5BdHRyaWJ1dCA6IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKSkgIT0gbnVsbCA/IF9yZWY5IDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC1cbiAqIEByZXR1cm5zIHtib29sZWFuIHwgdW5kZWZpbmVkfSAtIGZhbHNlL3RydWUgaWYgKG5vdClleHBhbmRlZCwgdW5kZWZpbmVkIGlmIG5vdCBleHBhbmQtYWJsZVxuICovXG5mdW5jdGlvbiBjb21wdXRlQXJpYUV4cGFuZGVkKGVsZW1lbnQpIHtcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLTEuMS8jYXJpYS1leHBhbmRlZFxuICByZXR1cm4gY2hlY2tCb29sZWFuQXR0cmlidXRlKGVsZW1lbnQsICdhcmlhLWV4cGFuZGVkJyk7XG59XG5mdW5jdGlvbiBjaGVja0Jvb2xlYW5BdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZVZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgaWYgKGF0dHJpYnV0ZVZhbHVlID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXR0cmlidXRlVmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBudW1iZXIgaWYgaW1wbGljaXQgaGVhZGluZyBvciBhcmlhLWxldmVsIHByZXNlbnQsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUhlYWRpbmdMZXZlbChlbGVtZW50KSB7XG4gIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9odG1sLWFhbS8jZWwtaDEtaDZcbiAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2h0bWwtYWFtLyNlbC1oMS1oNlxuICBjb25zdCBpbXBsaWNpdEhlYWRpbmdMZXZlbHMgPSB7XG4gICAgSDE6IDEsXG4gICAgSDI6IDIsXG4gICAgSDM6IDMsXG4gICAgSDQ6IDQsXG4gICAgSDU6IDUsXG4gICAgSDY6IDZcbiAgfTtcbiAgLy8gZXhwbGljaXQgYXJpYS1sZXZlbCB2YWx1ZVxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtMS4yLyNhcmlhLWxldmVsXG4gIGNvbnN0IGFyaWFMZXZlbEF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxldmVsJykgJiYgTnVtYmVyKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxldmVsJykpO1xuICByZXR1cm4gYXJpYUxldmVsQXR0cmlidXRlIHx8IGltcGxpY2l0SGVhZGluZ0xldmVsc1tlbGVtZW50LnRhZ05hbWVdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBcmlhVmFsdWVOb3coZWxlbWVudCkge1xuICBjb25zdCB2YWx1ZU5vdyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93Jyk7XG4gIHJldHVybiB2YWx1ZU5vdyA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6ICt2YWx1ZU5vdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLVxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLVxuICovXG5mdW5jdGlvbiBjb21wdXRlQXJpYVZhbHVlTWF4KGVsZW1lbnQpIHtcbiAgY29uc3QgdmFsdWVNYXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW1heCcpO1xuICByZXR1cm4gdmFsdWVNYXggPT09IG51bGwgPyB1bmRlZmluZWQgOiArdmFsdWVNYXg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC1cbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUFyaWFWYWx1ZU1pbihlbGVtZW50KSB7XG4gIGNvbnN0IHZhbHVlTWluID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVtaW4nKTtcbiAgcmV0dXJuIHZhbHVlTWluID09PSBudWxsID8gdW5kZWZpbmVkIDogK3ZhbHVlTWluO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBcmlhVmFsdWVUZXh0KGVsZW1lbnQpIHtcbiAgY29uc3QgdmFsdWVUZXh0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0Jyk7XG4gIHJldHVybiB2YWx1ZVRleHQgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2YWx1ZVRleHQ7XG59XG5cbmNvbnN0IG5vcm1hbGl6ZSA9IGdldERlZmF1bHROb3JtYWxpemVyKCk7XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qK1xcLT9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGdldFJlZ0V4cE1hdGNoZXIoc3RyaW5nKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChzdHJpbmcudG9Mb3dlckNhc2UoKSksICdpJyk7XG59XG5mdW5jdGlvbiBtYWtlU3VnZ2VzdGlvbihxdWVyeU5hbWUsIGVsZW1lbnQsIGNvbnRlbnQsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICB2YXJpYW50LFxuICAgIG5hbWVcbiAgfSA9IF9yZWY7XG4gIGxldCB3YXJuaW5nID0gJyc7XG4gIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IHt9O1xuICBjb25zdCBxdWVyeUFyZ3MgPSBbWydSb2xlJywgJ1Rlc3RJZCddLmluY2x1ZGVzKHF1ZXJ5TmFtZSkgPyBjb250ZW50IDogZ2V0UmVnRXhwTWF0Y2hlcihjb250ZW50KV07XG4gIGlmIChuYW1lKSB7XG4gICAgcXVlcnlPcHRpb25zLm5hbWUgPSBnZXRSZWdFeHBNYXRjaGVyKG5hbWUpO1xuICB9XG4gIGlmIChxdWVyeU5hbWUgPT09ICdSb2xlJyAmJiBpc0luYWNjZXNzaWJsZShlbGVtZW50KSkge1xuICAgIHF1ZXJ5T3B0aW9ucy5oaWRkZW4gPSB0cnVlO1xuICAgIHdhcm5pbmcgPSBcIkVsZW1lbnQgaXMgaW5hY2Nlc3NpYmxlLiBUaGlzIG1lYW5zIHRoYXQgdGhlIGVsZW1lbnQgYW5kIGFsbCBpdHMgY2hpbGRyZW4gYXJlIGludmlzaWJsZSB0byBzY3JlZW4gcmVhZGVycy5cXG4gICAgSWYgeW91IGFyZSB1c2luZyB0aGUgYXJpYS1oaWRkZW4gcHJvcCwgbWFrZSBzdXJlIHRoaXMgaXMgdGhlIHJpZ2h0IGNob2ljZSBmb3IgeW91ciBjYXNlLlxcbiAgICBcIjtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXMocXVlcnlPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgcXVlcnlBcmdzLnB1c2gocXVlcnlPcHRpb25zKTtcbiAgfVxuICBjb25zdCBxdWVyeU1ldGhvZCA9IHZhcmlhbnQgKyBcIkJ5XCIgKyBxdWVyeU5hbWU7XG4gIHJldHVybiB7XG4gICAgcXVlcnlOYW1lLFxuICAgIHF1ZXJ5TWV0aG9kLFxuICAgIHF1ZXJ5QXJncyxcbiAgICB2YXJpYW50LFxuICAgIHdhcm5pbmcsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAod2FybmluZykge1xuICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgICB9XG4gICAgICBsZXQgW3RleHQsIG9wdGlvbnNdID0gcXVlcnlBcmdzO1xuICAgICAgdGV4dCA9IHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdGV4dCArIFwiJ1wiIDogdGV4dDtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXCIsIHsgXCIgKyBPYmplY3QuZW50cmllcyhvcHRpb25zKS5tYXAoX3JlZjIgPT4ge1xuICAgICAgICBsZXQgW2ssIHZdID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBrICsgXCI6IFwiICsgdjtcbiAgICAgIH0pLmpvaW4oJywgJykgKyBcIiB9XCIgOiAnJztcbiAgICAgIHJldHVybiBxdWVyeU1ldGhvZCArIFwiKFwiICsgdGV4dCArIG9wdGlvbnMgKyBcIilcIjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjYW5TdWdnZXN0KGN1cnJlbnRNZXRob2QsIHJlcXVlc3RlZE1ldGhvZCwgZGF0YSkge1xuICByZXR1cm4gZGF0YSAmJiAoIXJlcXVlc3RlZE1ldGhvZCB8fCByZXF1ZXN0ZWRNZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gY3VycmVudE1ldGhvZC50b0xvd2VyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGdldFN1Z2dlc3RlZFF1ZXJ5KGVsZW1lbnQsIHZhcmlhbnQsIG1ldGhvZCkge1xuICB2YXIgX2VsZW1lbnQkZ2V0QXR0cmlidXRlLCBfZ2V0SW1wbGljaXRBcmlhUm9sZXM7XG4gIGlmICh2YXJpYW50ID09PSB2b2lkIDApIHtcbiAgICB2YXJpYW50ID0gJ2dldCc7XG4gIH1cbiAgLy8gZG9uJ3QgY3JlYXRlIHN1Z2dlc3Rpb25zIGZvciBzY3JpcHQgYW5kIHN0eWxlIGVsZW1lbnRzXG4gIGlmIChlbGVtZW50Lm1hdGNoZXMoZ2V0Q29uZmlnKCkuZGVmYXVsdElnbm9yZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy9XZSBwcmVmZXIgdG8gc3VnZ2VzdCBzb21ldGhpbmcgZWxzZSBpZiB0aGUgcm9sZSBpcyBnZW5lcmljXG4gIGNvbnN0IHJvbGUgPSAoX2VsZW1lbnQkZ2V0QXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSkgIT0gbnVsbCA/IF9lbGVtZW50JGdldEF0dHJpYnV0ZSA6IChfZ2V0SW1wbGljaXRBcmlhUm9sZXMgPSBnZXRJbXBsaWNpdEFyaWFSb2xlcyhlbGVtZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXRJbXBsaWNpdEFyaWFSb2xlc1swXTtcbiAgaWYgKHJvbGUgIT09ICdnZW5lcmljJyAmJiBjYW5TdWdnZXN0KCdSb2xlJywgbWV0aG9kLCByb2xlKSkge1xuICAgIHJldHVybiBtYWtlU3VnZ2VzdGlvbignUm9sZScsIGVsZW1lbnQsIHJvbGUsIHtcbiAgICAgIHZhcmlhbnQsXG4gICAgICBuYW1lOiBjb21wdXRlQWNjZXNzaWJsZU5hbWUoZWxlbWVudCwge1xuICAgICAgICBjb21wdXRlZFN0eWxlU3VwcG9ydHNQc2V1ZG9FbGVtZW50czogZ2V0Q29uZmlnKCkuY29tcHV0ZWRTdHlsZVN1cHBvcnRzUHNldWRvRWxlbWVudHNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbGFiZWxUZXh0ID0gZ2V0TGFiZWxzKGRvY3VtZW50LCBlbGVtZW50KS5tYXAobGFiZWwgPT4gbGFiZWwuY29udGVudCkuam9pbignICcpO1xuICBpZiAoY2FuU3VnZ2VzdCgnTGFiZWxUZXh0JywgbWV0aG9kLCBsYWJlbFRleHQpKSB7XG4gICAgcmV0dXJuIG1ha2VTdWdnZXN0aW9uKCdMYWJlbFRleHQnLCBlbGVtZW50LCBsYWJlbFRleHQsIHtcbiAgICAgIHZhcmlhbnRcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwbGFjZWhvbGRlclRleHQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKTtcbiAgaWYgKGNhblN1Z2dlc3QoJ1BsYWNlaG9sZGVyVGV4dCcsIG1ldGhvZCwgcGxhY2Vob2xkZXJUZXh0KSkge1xuICAgIHJldHVybiBtYWtlU3VnZ2VzdGlvbignUGxhY2Vob2xkZXJUZXh0JywgZWxlbWVudCwgcGxhY2Vob2xkZXJUZXh0LCB7XG4gICAgICB2YXJpYW50XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdGV4dENvbnRlbnQgPSBub3JtYWxpemUoZ2V0Tm9kZVRleHQoZWxlbWVudCkpO1xuICBpZiAoY2FuU3VnZ2VzdCgnVGV4dCcsIG1ldGhvZCwgdGV4dENvbnRlbnQpKSB7XG4gICAgcmV0dXJuIG1ha2VTdWdnZXN0aW9uKCdUZXh0JywgZWxlbWVudCwgdGV4dENvbnRlbnQsIHtcbiAgICAgIHZhcmlhbnRcbiAgICB9KTtcbiAgfVxuICBpZiAoY2FuU3VnZ2VzdCgnRGlzcGxheVZhbHVlJywgbWV0aG9kLCBlbGVtZW50LnZhbHVlKSkge1xuICAgIHJldHVybiBtYWtlU3VnZ2VzdGlvbignRGlzcGxheVZhbHVlJywgZWxlbWVudCwgbm9ybWFsaXplKGVsZW1lbnQudmFsdWUpLCB7XG4gICAgICB2YXJpYW50XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYWx0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FsdCcpO1xuICBpZiAoY2FuU3VnZ2VzdCgnQWx0VGV4dCcsIG1ldGhvZCwgYWx0KSkge1xuICAgIHJldHVybiBtYWtlU3VnZ2VzdGlvbignQWx0VGV4dCcsIGVsZW1lbnQsIGFsdCwge1xuICAgICAgdmFyaWFudFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHRpdGxlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gIGlmIChjYW5TdWdnZXN0KCdUaXRsZScsIG1ldGhvZCwgdGl0bGUpKSB7XG4gICAgcmV0dXJuIG1ha2VTdWdnZXN0aW9uKCdUaXRsZScsIGVsZW1lbnQsIHRpdGxlLCB7XG4gICAgICB2YXJpYW50XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdGVzdElkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoZ2V0Q29uZmlnKCkudGVzdElkQXR0cmlidXRlKTtcbiAgaWYgKGNhblN1Z2dlc3QoJ1Rlc3RJZCcsIG1ldGhvZCwgdGVzdElkKSkge1xuICAgIHJldHVybiBtYWtlU3VnZ2VzdGlvbignVGVzdElkJywgZWxlbWVudCwgdGVzdElkLCB7XG4gICAgICB2YXJpYW50XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLy8gVGhpcyBpcyBzbyB0aGUgc3RhY2sgdHJhY2UgdGhlIGRldmVsb3BlciBzZWVzIGlzIG9uZSB0aGF0J3Ncbi8vIGNsb3NlciB0byB0aGVpciBjb2RlIChiZWNhdXNlIGFzeW5jIHN0YWNrIHRyYWNlcyBhcmUgaGFyZCB0byBmb2xsb3cpLlxuZnVuY3Rpb24gY29weVN0YWNrVHJhY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdGFyZ2V0LnN0YWNrID0gc291cmNlLnN0YWNrLnJlcGxhY2Uoc291cmNlLm1lc3NhZ2UsIHRhcmdldC5tZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIHdhaXRGb3IoY2FsbGJhY2ssIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjb250YWluZXIgPSBnZXREb2N1bWVudCgpLFxuICAgIHRpbWVvdXQgPSBnZXRDb25maWcoKS5hc3luY1V0aWxUaW1lb3V0LFxuICAgIHNob3dPcmlnaW5hbFN0YWNrVHJhY2UgPSBnZXRDb25maWcoKS5zaG93T3JpZ2luYWxTdGFja1RyYWNlLFxuICAgIHN0YWNrVHJhY2VFcnJvcixcbiAgICBpbnRlcnZhbCA9IDUwLFxuICAgIG9uVGltZW91dCA9IGVycm9yID0+IHtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBnZXRDb25maWcoKS5nZXRFbGVtZW50RXJyb3IoZXJyb3IubWVzc2FnZSwgY29udGFpbmVyKS5tZXNzYWdlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sXG4gICAgbXV0YXRpb25PYnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9XG4gIH0gPSBfcmVmO1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVjZWl2ZWQgYGNhbGxiYWNrYCBhcmcgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgbGFzdEVycm9yLCBpbnRlcnZhbElkLCBvYnNlcnZlcjtcbiAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICBsZXQgcHJvbWlzZVN0YXR1cyA9ICdpZGxlJztcbiAgICBjb25zdCBvdmVyYWxsVGltZW91dFRpbWVyID0gc2V0VGltZW91dChoYW5kbGVUaW1lb3V0LCB0aW1lb3V0KTtcbiAgICBjb25zdCB1c2luZ0plc3RGYWtlVGltZXJzID0gamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKCk7XG4gICAgaWYgKHVzaW5nSmVzdEZha2VUaW1lcnMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdW5zdGFibGVfYWR2YW5jZVRpbWVyc1dyYXBwZXI6IGFkdmFuY2VUaW1lcnNXcmFwcGVyXG4gICAgICB9ID0gZ2V0Q29uZmlnKCk7XG4gICAgICBjaGVja0NhbGxiYWNrKCk7XG4gICAgICAvLyB0aGlzIGlzIGEgZGFuZ2Vyb3VzIHJ1bGUgdG8gZGlzYWJsZSBiZWNhdXNlIGl0IGNvdWxkIGxlYWQgdG8gYW5cbiAgICAgIC8vIGluZmluaXRlIGxvb3AuIEhvd2V2ZXIsIGVzbGludCBpc24ndCBzbWFydCBlbm91Z2ggdG8ga25vdyB0aGF0IHdlJ3JlXG4gICAgICAvLyBzZXR0aW5nIGZpbmlzaGVkIGluc2lkZSBgb25Eb25lYCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHdlJ3JlIGRvbmVcbiAgICAgIC8vIHdhaXRpbmcgb3Igd2hlbiB3ZSd2ZSB0aW1lZCBvdXQuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5tb2RpZmllZC1sb29wLWNvbmRpdGlvblxuICAgICAgd2hpbGUgKCFmaW5pc2hlZCkge1xuICAgICAgICBpZiAoIWplc3RGYWtlVGltZXJzQXJlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJDaGFuZ2VkIGZyb20gdXNpbmcgZmFrZSB0aW1lcnMgdG8gcmVhbCB0aW1lcnMgd2hpbGUgdXNpbmcgd2FpdEZvci4gVGhpcyBpcyBub3QgYWxsb3dlZCBhbmQgd2lsbCByZXN1bHQgaW4gdmVyeSBzdHJhbmdlIGJlaGF2aW9yLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBhd2FpdGluZyBhbGwgYXN5bmMgdGhpbmdzIHlvdXIgdGVzdCBpcyBkb2luZyBiZWZvcmUgY2hhbmdpbmcgdG8gcmVhbCB0aW1lcnMuIEZvciBtb3JlIGluZm8sIHBsZWFzZSBnbyB0byBodHRwczovL2dpdGh1Yi5jb20vdGVzdGluZy1saWJyYXJ5L2RvbS10ZXN0aW5nLWxpYnJhcnkvaXNzdWVzLzgzMFwiKTtcbiAgICAgICAgICBpZiAoIXNob3dPcmlnaW5hbFN0YWNrVHJhY2UpIGNvcHlTdGFja1RyYWNlKGVycm9yLCBzdGFja1RyYWNlRXJyb3IpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gdGhpcyByYXJlIGNhc2UsIHdlICpuZWVkKiB0byB3YWl0IGZvciBpbi1mbGlnaHQgcHJvbWlzZXNcbiAgICAgICAgLy8gdG8gcmVzb2x2ZSBiZWZvcmUgY29udGludWluZy4gV2UgZG9uJ3QgbmVlZCB0byB0YWtlIGFkdmFudGFnZVxuICAgICAgICAvLyBvZiBwYXJhbGxlbGl6YXRpb24gc28gd2UncmUgZmluZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU5MjQzNTg2Lzk3MTU5MlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICBhd2FpdCBhZHZhbmNlVGltZXJzV3JhcHBlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gd2UgKmNvdWxkKiAobWF5YmUgc2hvdWxkPykgdXNlIGBhZHZhbmNlVGltZXJzVG9OZXh0VGltZXJgIGJ1dCBpdCdzXG4gICAgICAgICAgLy8gcG9zc2libGUgdGhhdCBjb3VsZCBtYWtlIHRoaXMgbG9vcCBnbyBvbiBmb3JldmVyIGlmIHNvbWVvbmUgaXMgdXNpbmdcbiAgICAgICAgICAvLyB0aGlyZCBwYXJ0eSBjb2RlIHRoYXQncyBzZXR0aW5nIHVwIHJlY3Vyc2l2ZSB0aW1lcnMgc28gcmFwaWRseSB0aGF0XG4gICAgICAgICAgLy8gdGhlIHVzZXIncyB0aW1lcidzIGRvbid0IGdldCBhIGNoYW5jZSB0byByZXNvbHZlLiBTbyB3ZSdsbCBhZHZhbmNlXG4gICAgICAgICAgLy8gYnkgYW4gaW50ZXJ2YWwgaW5zdGVhZC4gKFdlIGhhdmUgYSB0ZXN0IGZvciB0aGlzIGNhc2UpLlxuICAgICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZShpbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEl0J3MgcmVhbGx5IGltcG9ydGFudCB0aGF0IGNoZWNrQ2FsbGJhY2sgaXMgcnVuICpiZWZvcmUqIHdlIGZsdXNoXG4gICAgICAgIC8vIGluLWZsaWdodCBwcm9taXNlcy4gVG8gYmUgaG9uZXN0LCBJJ20gbm90IHN1cmUgd2h5LCBhbmQgSSBjYW4ndCBxdWl0ZVxuICAgICAgICAvLyB0aGluayBvZiBhIHdheSB0byByZXByb2R1Y2UgdGhlIHByb2JsZW0gaW4gYSB0ZXN0LCBidXQgSSBzcGVudFxuICAgICAgICAvLyBhbiBlbnRpcmUgZGF5IGJhbmdpbmcgbXkgaGVhZCBhZ2FpbnN0IGEgd2FsbCBvbiB0aGlzLlxuICAgICAgICBjaGVja0NhbGxiYWNrKCk7XG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNoZWNrQ29udGFpbmVyVHlwZShjb250YWluZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChjaGVja1JlYWxUaW1lcnNDYWxsYmFjaywgaW50ZXJ2YWwpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBNdXRhdGlvbk9ic2VydmVyXG4gICAgICB9ID0gZ2V0V2luZG93RnJvbU5vZGUoY29udGFpbmVyKTtcbiAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hlY2tSZWFsVGltZXJzQ2FsbGJhY2spO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIG11dGF0aW9uT2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIGNoZWNrQ2FsbGJhY2soKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Eb25lKGVycm9yLCByZXN1bHQpIHtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dChvdmVyYWxsVGltZW91dFRpbWVyKTtcbiAgICAgIGlmICghdXNpbmdKZXN0RmFrZVRpbWVycykge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tSZWFsVGltZXJzQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKCkpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJDaGFuZ2VkIGZyb20gdXNpbmcgcmVhbCB0aW1lcnMgdG8gZmFrZSB0aW1lcnMgd2hpbGUgdXNpbmcgd2FpdEZvci4gVGhpcyBpcyBub3QgYWxsb3dlZCBhbmQgd2lsbCByZXN1bHQgaW4gdmVyeSBzdHJhbmdlIGJlaGF2aW9yLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBhd2FpdGluZyBhbGwgYXN5bmMgdGhpbmdzIHlvdXIgdGVzdCBpcyBkb2luZyBiZWZvcmUgY2hhbmdpbmcgdG8gZmFrZSB0aW1lcnMuIEZvciBtb3JlIGluZm8sIHBsZWFzZSBnbyB0byBodHRwczovL2dpdGh1Yi5jb20vdGVzdGluZy1saWJyYXJ5L2RvbS10ZXN0aW5nLWxpYnJhcnkvaXNzdWVzLzgzMFwiKTtcbiAgICAgICAgaWYgKCFzaG93T3JpZ2luYWxTdGFja1RyYWNlKSBjb3B5U3RhY2tUcmFjZShlcnJvciwgc3RhY2tUcmFjZUVycm9yKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hlY2tDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NhbGxiYWNrKCkge1xuICAgICAgaWYgKHByb21pc2VTdGF0dXMgPT09ICdwZW5kaW5nJykgcmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcnVuV2l0aEV4cGVuc2l2ZUVycm9yRGlhZ25vc3RpY3NEaXNhYmxlZChjYWxsYmFjayk7XG4gICAgICAgIGlmICh0eXBlb2YgKHJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcmVzdWx0LnRoZW4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcHJvbWlzZVN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlZFZhbHVlID0+IHtcbiAgICAgICAgICAgIHByb21pc2VTdGF0dXMgPSAncmVzb2x2ZWQnO1xuICAgICAgICAgICAgb25Eb25lKG51bGwsIHJlc29sdmVkVmFsdWUpO1xuICAgICAgICAgIH0sIHJlamVjdGVkVmFsdWUgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZVN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICBsYXN0RXJyb3IgPSByZWplY3RlZFZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRG9uZShudWxsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGBjYWxsYmFja2AgdGhyb3dzLCB3YWl0IGZvciB0aGUgbmV4dCBtdXRhdGlvbiwgaW50ZXJ2YWwsIG9yIHRpbWVvdXQuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBTYXZlIHRoZSBtb3N0IHJlY2VudCBjYWxsYmFjayBlcnJvciB0byByZWplY3QgdGhlIHByb21pc2Ugd2l0aCBpdCBpbiB0aGUgZXZlbnQgb2YgYSB0aW1lb3V0XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICBlcnJvciA9IGxhc3RFcnJvcjtcbiAgICAgICAgaWYgKCFzaG93T3JpZ2luYWxTdGFja1RyYWNlICYmIGVycm9yLm5hbWUgPT09ICdUZXN0aW5nTGlicmFyeUVsZW1lbnRFcnJvcicpIHtcbiAgICAgICAgICBjb3B5U3RhY2tUcmFjZShlcnJvciwgc3RhY2tUcmFjZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ1RpbWVkIG91dCBpbiB3YWl0Rm9yLicpO1xuICAgICAgICBpZiAoIXNob3dPcmlnaW5hbFN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBjb3B5U3RhY2tUcmFjZShlcnJvciwgc3RhY2tUcmFjZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25Eb25lKG9uVGltZW91dChlcnJvciksIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB3YWl0Rm9yV3JhcHBlcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAvLyBjcmVhdGUgdGhlIGVycm9yIGhlcmUgc28gaXRzIHN0YWNrIHRyYWNlIGlzIGFzIGNsb3NlIHRvIHRoZVxuICAvLyBjYWxsaW5nIGNvZGUgYXMgcG9zc2libGVcbiAgY29uc3Qgc3RhY2tUcmFjZUVycm9yID0gbmV3IEVycm9yKCdTVEFDS19UUkFDRV9NRVNTQUdFJyk7XG4gIHJldHVybiBnZXRDb25maWcoKS5hc3luY1dyYXBwZXIoKCkgPT4gd2FpdEZvcihjYWxsYmFjaywge1xuICAgIHN0YWNrVHJhY2VFcnJvcixcbiAgICAuLi5vcHRpb25zXG4gIH0pKTtcbn1cblxuLypcbmVzbGludFxuICBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uOiBbXCJlcnJvclwiLCB7XCJtYXhcIjogMjAwfV0sXG4qL1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50RXJyb3IobWVzc2FnZSwgY29udGFpbmVyKSB7XG4gIHJldHVybiBnZXRDb25maWcoKS5nZXRFbGVtZW50RXJyb3IobWVzc2FnZSwgY29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIGdldE11bHRpcGxlRWxlbWVudHNGb3VuZEVycm9yKG1lc3NhZ2UsIGNvbnRhaW5lcikge1xuICByZXR1cm4gZ2V0RWxlbWVudEVycm9yKG1lc3NhZ2UgKyBcIlxcblxcbihJZiB0aGlzIGlzIGludGVudGlvbmFsLCB0aGVuIHVzZSB0aGUgYCpBbGxCeSpgIHZhcmlhbnQgb2YgdGhlIHF1ZXJ5IChsaWtlIGBxdWVyeUFsbEJ5VGV4dGAsIGBnZXRBbGxCeVRleHRgLCBvciBgZmluZEFsbEJ5VGV4dGApKS5cIiwgY29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5QWxsQnlBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250YWluZXIsIHRleHQsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgZXhhY3QgPSB0cnVlLFxuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBtYXRjaGVyID0gZXhhY3QgPyBtYXRjaGVzIDogZnV6enlNYXRjaGVzO1xuICBjb25zdCBtYXRjaE5vcm1hbGl6ZXIgPSBtYWtlTm9ybWFsaXplcih7XG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplclxuICB9KTtcbiAgcmV0dXJuIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIgKyBhdHRyaWJ1dGUgKyBcIl1cIikpLmZpbHRlcihub2RlID0+IG1hdGNoZXIobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSwgbm9kZSwgdGV4dCwgbWF0Y2hOb3JtYWxpemVyKSk7XG59XG5mdW5jdGlvbiBxdWVyeUJ5QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGFpbmVyLCB0ZXh0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGVscyA9IHF1ZXJ5QWxsQnlBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250YWluZXIsIHRleHQsIG9wdGlvbnMpO1xuICBpZiAoZWxzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBnZXRNdWx0aXBsZUVsZW1lbnRzRm91bmRFcnJvcihcIkZvdW5kIG11bHRpcGxlIGVsZW1lbnRzIGJ5IFtcIiArIGF0dHJpYnV0ZSArIFwiPVwiICsgdGV4dCArIFwiXVwiLCBjb250YWluZXIpO1xuICB9XG4gIHJldHVybiBlbHNbMF0gfHwgbnVsbDtcbn1cblxuLy8gdGhpcyBhY2NlcHRzIGEgcXVlcnkgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0aHJvd3MgYW4gZXJyb3Jcbi8vIGlmIG1vcmUgdGhhbiBvbmUgZWxlbWVudHMgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBpdCByZXR1cm5zIHRoZSBmaXJzdFxuLy8gZWxlbWVudCBvciBudWxsXG5mdW5jdGlvbiBtYWtlU2luZ2xlUXVlcnkoYWxsUXVlcnksIGdldE11bHRpcGxlRXJyb3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgY29uc3QgZWxzID0gYWxsUXVlcnkoY29udGFpbmVyLCAuLi5hcmdzKTtcbiAgICBpZiAoZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRTdHJpbmdzID0gZWxzLm1hcChlbGVtZW50ID0+IGdldEVsZW1lbnRFcnJvcihudWxsLCBlbGVtZW50KS5tZXNzYWdlKS5qb2luKCdcXG5cXG4nKTtcbiAgICAgIHRocm93IGdldE11bHRpcGxlRWxlbWVudHNGb3VuZEVycm9yKGdldE11bHRpcGxlRXJyb3IoY29udGFpbmVyLCAuLi5hcmdzKSArIFwiXFxuXFxuSGVyZSBhcmUgdGhlIG1hdGNoaW5nIGVsZW1lbnRzOlxcblxcblwiICsgZWxlbWVudFN0cmluZ3MsIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBlbHNbMF0gfHwgbnVsbDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1Z2dlc3Rpb25FcnJvcihzdWdnZXN0aW9uLCBjb250YWluZXIpIHtcbiAgcmV0dXJuIGdldENvbmZpZygpLmdldEVsZW1lbnRFcnJvcihcIkEgYmV0dGVyIHF1ZXJ5IGlzIGF2YWlsYWJsZSwgdHJ5IHRoaXM6XFxuXCIgKyBzdWdnZXN0aW9uLnRvU3RyaW5nKCkgKyBcIlxcblwiLCBjb250YWluZXIpO1xufVxuXG4vLyB0aGlzIGFjY2VwdHMgYSBxdWVyeSBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRocm93cyBhbiBlcnJvclxuLy8gaWYgYW4gZW1wdHkgbGlzdCBvZiBlbGVtZW50cyBpcyByZXR1cm5lZFxuZnVuY3Rpb24gbWFrZUdldEFsbFF1ZXJ5KGFsbFF1ZXJ5LCBnZXRNaXNzaW5nRXJyb3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgY29uc3QgZWxzID0gYWxsUXVlcnkoY29udGFpbmVyLCAuLi5hcmdzKTtcbiAgICBpZiAoIWVscy5sZW5ndGgpIHtcbiAgICAgIHRocm93IGdldENvbmZpZygpLmdldEVsZW1lbnRFcnJvcihnZXRNaXNzaW5nRXJyb3IoY29udGFpbmVyLCAuLi5hcmdzKSwgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVscztcbiAgfTtcbn1cblxuLy8gdGhpcyBhY2NlcHRzIGEgZ2V0dGVyIHF1ZXJ5IGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggY2FsbHNcbi8vIHdhaXRGb3IgYW5kIHBhc3NpbmcgYSBmdW5jdGlvbiB3aGljaCBpbnZva2VzIHRoZSBnZXR0ZXIuXG5mdW5jdGlvbiBtYWtlRmluZFF1ZXJ5KGdldHRlcikge1xuICByZXR1cm4gKGNvbnRhaW5lciwgdGV4dCwgb3B0aW9ucywgd2FpdEZvck9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gd2FpdEZvcldyYXBwZXIoKCkgPT4ge1xuICAgICAgcmV0dXJuIGdldHRlcihjb250YWluZXIsIHRleHQsIG9wdGlvbnMpO1xuICAgIH0sIHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIC4uLndhaXRGb3JPcHRpb25zXG4gICAgfSk7XG4gIH07XG59XG5jb25zdCB3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbiA9IChxdWVyeSwgcXVlcnlBbGxCeU5hbWUsIHZhcmlhbnQpID0+IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSBxdWVyeShjb250YWluZXIsIC4uLmFyZ3MpO1xuICBjb25zdCBbe1xuICAgIHN1Z2dlc3QgPSBnZXRDb25maWcoKS50aHJvd1N1Z2dlc3Rpb25zXG4gIH0gPSB7fV0gPSBhcmdzLnNsaWNlKC0xKTtcbiAgaWYgKGVsZW1lbnQgJiYgc3VnZ2VzdCkge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBnZXRTdWdnZXN0ZWRRdWVyeShlbGVtZW50LCB2YXJpYW50KTtcbiAgICBpZiAoc3VnZ2VzdGlvbiAmJiAhcXVlcnlBbGxCeU5hbWUuZW5kc1dpdGgoc3VnZ2VzdGlvbi5xdWVyeU5hbWUpKSB7XG4gICAgICB0aHJvdyBnZXRTdWdnZXN0aW9uRXJyb3Ioc3VnZ2VzdGlvbi50b1N0cmluZygpLCBjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn07XG5jb25zdCB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uID0gKHF1ZXJ5LCBxdWVyeUFsbEJ5TmFtZSwgdmFyaWFudCkgPT4gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cbiAgY29uc3QgZWxzID0gcXVlcnkoY29udGFpbmVyLCAuLi5hcmdzKTtcbiAgY29uc3QgW3tcbiAgICBzdWdnZXN0ID0gZ2V0Q29uZmlnKCkudGhyb3dTdWdnZXN0aW9uc1xuICB9ID0ge31dID0gYXJncy5zbGljZSgtMSk7XG4gIGlmIChlbHMubGVuZ3RoICYmIHN1Z2dlc3QpIHtcbiAgICAvLyBnZXQgYSB1bmlxdWUgbGlzdCBvZiBhbGwgc3VnZ2VzdGlvbiBtZXNzYWdlcy4gIFdlIGFyZSBvbmx5IGdvaW5nIHRvIG1ha2UgYSBzdWdnZXN0aW9uIGlmXG4gICAgLy8gYWxsIHRoZSBzdWdnZXN0aW9ucyBhcmUgdGhlIHNhbWVcbiAgICBjb25zdCB1bmlxdWVTdWdnZXN0aW9uTWVzc2FnZXMgPSBbLi4ubmV3IFNldChlbHMubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgdmFyIF9nZXRTdWdnZXN0ZWRRdWVyeTtcbiAgICAgIHJldHVybiAoX2dldFN1Z2dlc3RlZFF1ZXJ5ID0gZ2V0U3VnZ2VzdGVkUXVlcnkoZWxlbWVudCwgdmFyaWFudCkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0U3VnZ2VzdGVkUXVlcnkudG9TdHJpbmcoKTtcbiAgICB9KSldO1xuICAgIGlmIChcbiAgICAvLyBvbmx5IHdhbnQgdG8gc3VnZ2VzdCBpZiBhbGwgdGhlIGVscyBoYXZlIHRoZSBzYW1lIHN1Z2dlc3Rpb24uXG4gICAgdW5pcXVlU3VnZ2VzdGlvbk1lc3NhZ2VzLmxlbmd0aCA9PT0gMSAmJiAhcXVlcnlBbGxCeU5hbWUuZW5kc1dpdGgoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gLS0gVE9ETzogQ2FuIHRoaXMgYmUgbnVsbCBhdCBydW50aW1lP1xuICAgIGdldFN1Z2dlc3RlZFF1ZXJ5KGVsc1swXSwgdmFyaWFudCkucXVlcnlOYW1lKSkge1xuICAgICAgdGhyb3cgZ2V0U3VnZ2VzdGlvbkVycm9yKHVuaXF1ZVN1Z2dlc3Rpb25NZXNzYWdlc1swXSwgY29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVscztcbn07XG5cbi8vIFRPRE86IFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgcHVibGlzaGVkIGRlY2xhcmF0aW9uc1xuLy8gSG93ZXZlciwgdGhlIGltcGxlbWVudGF0aW9uIGFsd2F5cyByZXF1aXJlZCBhIGR5YWRpYyAoYWZ0ZXIgYGNvbnRhaW5lcmApIG5vdCB2YXJpYWRpYyBgcXVlcnlBbGxCeWAgY29uc2lkZXJpbmcgdGhlIGltcGxlbWVudGF0aW9uIG9mIGBtYWtlRmluZFF1ZXJ5YFxuLy8gVGhpcyBpcyBhdCBsZWFzdCBzdGF0aWNhbGx5IHRydWUgYW5kIGNhbiBiZSB2ZXJpZmllZCBieSBhY2NlcHRpbmcgYFF1ZXJ5TWV0aG9kPEFyZ3VtZW50cywgSFRNTEVsZW1lbnRbXT5gXG5mdW5jdGlvbiBidWlsZFF1ZXJpZXMocXVlcnlBbGxCeSwgZ2V0TXVsdGlwbGVFcnJvciwgZ2V0TWlzc2luZ0Vycm9yKSB7XG4gIGNvbnN0IHF1ZXJ5QnkgPSB3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbihtYWtlU2luZ2xlUXVlcnkocXVlcnlBbGxCeSwgZ2V0TXVsdGlwbGVFcnJvciksIHF1ZXJ5QWxsQnkubmFtZSwgJ3F1ZXJ5Jyk7XG4gIGNvbnN0IGdldEFsbEJ5ID0gbWFrZUdldEFsbFF1ZXJ5KHF1ZXJ5QWxsQnksIGdldE1pc3NpbmdFcnJvcik7XG4gIGNvbnN0IGdldEJ5ID0gbWFrZVNpbmdsZVF1ZXJ5KGdldEFsbEJ5LCBnZXRNdWx0aXBsZUVycm9yKTtcbiAgY29uc3QgZ2V0QnlXaXRoU3VnZ2VzdGlvbnMgPSB3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbihnZXRCeSwgcXVlcnlBbGxCeS5uYW1lLCAnZ2V0Jyk7XG4gIGNvbnN0IGdldEFsbFdpdGhTdWdnZXN0aW9ucyA9IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24oZ2V0QWxsQnksIHF1ZXJ5QWxsQnkubmFtZS5yZXBsYWNlKCdxdWVyeScsICdnZXQnKSwgJ2dldEFsbCcpO1xuICBjb25zdCBmaW5kQWxsQnkgPSBtYWtlRmluZFF1ZXJ5KHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24oZ2V0QWxsQnksIHF1ZXJ5QWxsQnkubmFtZSwgJ2ZpbmRBbGwnKSk7XG4gIGNvbnN0IGZpbmRCeSA9IG1ha2VGaW5kUXVlcnkod3JhcFNpbmdsZVF1ZXJ5V2l0aFN1Z2dlc3Rpb24oZ2V0QnksIHF1ZXJ5QWxsQnkubmFtZSwgJ2ZpbmQnKSk7XG4gIHJldHVybiBbcXVlcnlCeSwgZ2V0QWxsV2l0aFN1Z2dlc3Rpb25zLCBnZXRCeVdpdGhTdWdnZXN0aW9ucywgZmluZEFsbEJ5LCBmaW5kQnldO1xufVxuXG52YXIgcXVlcnlIZWxwZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdldEVsZW1lbnRFcnJvcjogZ2V0RWxlbWVudEVycm9yLFxuICB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uOiB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uLFxuICB3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbjogd3JhcFNpbmdsZVF1ZXJ5V2l0aFN1Z2dlc3Rpb24sXG4gIGdldE11bHRpcGxlRWxlbWVudHNGb3VuZEVycm9yOiBnZXRNdWx0aXBsZUVsZW1lbnRzRm91bmRFcnJvcixcbiAgcXVlcnlBbGxCeUF0dHJpYnV0ZTogcXVlcnlBbGxCeUF0dHJpYnV0ZSxcbiAgcXVlcnlCeUF0dHJpYnV0ZTogcXVlcnlCeUF0dHJpYnV0ZSxcbiAgbWFrZVNpbmdsZVF1ZXJ5OiBtYWtlU2luZ2xlUXVlcnksXG4gIG1ha2VHZXRBbGxRdWVyeTogbWFrZUdldEFsbFF1ZXJ5LFxuICBtYWtlRmluZFF1ZXJ5OiBtYWtlRmluZFF1ZXJ5LFxuICBidWlsZFF1ZXJpZXM6IGJ1aWxkUXVlcmllc1xufSk7XG5cbmZ1bmN0aW9uIHF1ZXJ5QWxsTGFiZWxzKGNvbnRhaW5lcikge1xuICByZXR1cm4gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnbGFiZWwsaW5wdXQnKSkubWFwKG5vZGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlLFxuICAgICAgdGV4dFRvTWF0Y2g6IGdldExhYmVsQ29udGVudChub2RlKVxuICAgIH07XG4gIH0pLmZpbHRlcihfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgdGV4dFRvTWF0Y2hcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gdGV4dFRvTWF0Y2ggIT09IG51bGw7XG4gIH0pO1xufVxuY29uc3QgcXVlcnlBbGxMYWJlbHNCeVRleHQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCB0ZXh0LCBfdGVtcCkge1xuICBsZXQge1xuICAgIGV4YWN0ID0gdHJ1ZSxcbiAgICB0cmltLFxuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICBub3JtYWxpemVyXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgbWF0Y2hlciA9IGV4YWN0ID8gbWF0Y2hlcyA6IGZ1enp5TWF0Y2hlcztcbiAgY29uc3QgbWF0Y2hOb3JtYWxpemVyID0gbWFrZU5vcm1hbGl6ZXIoe1xuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSk7XG4gIGNvbnN0IHRleHRUb01hdGNoQnlMYWJlbHMgPSBxdWVyeUFsbExhYmVscyhjb250YWluZXIpO1xuICByZXR1cm4gdGV4dFRvTWF0Y2hCeUxhYmVscy5maWx0ZXIoX3JlZjIgPT4ge1xuICAgIGxldCB7XG4gICAgICBub2RlLFxuICAgICAgdGV4dFRvTWF0Y2hcbiAgICB9ID0gX3JlZjI7XG4gICAgcmV0dXJuIG1hdGNoZXIodGV4dFRvTWF0Y2gsIG5vZGUsIHRleHQsIG1hdGNoTm9ybWFsaXplcik7XG4gIH0pLm1hcChfcmVmMyA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG5vZGVcbiAgICB9ID0gX3JlZjM7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xufTtcbmNvbnN0IHF1ZXJ5QWxsQnlMYWJlbFRleHQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCB0ZXh0LCBfdGVtcDIpIHtcbiAgbGV0IHtcbiAgICBzZWxlY3RvciA9ICcqJyxcbiAgICBleGFjdCA9IHRydWUsXG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplclxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgY2hlY2tDb250YWluZXJUeXBlKGNvbnRhaW5lcik7XG4gIGNvbnN0IG1hdGNoZXIgPSBleGFjdCA/IG1hdGNoZXMgOiBmdXp6eU1hdGNoZXM7XG4gIGNvbnN0IG1hdGNoTm9ybWFsaXplciA9IG1ha2VOb3JtYWxpemVyKHtcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgdHJpbSxcbiAgICBub3JtYWxpemVyXG4gIH0pO1xuICBjb25zdCBtYXRjaGluZ0xhYmVsbGVkRWxlbWVudHMgPSBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcqJykpLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICByZXR1cm4gZ2V0UmVhbExhYmVscyhlbGVtZW50KS5sZW5ndGggfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScpO1xuICB9KS5yZWR1Y2UoKGxhYmVsbGVkRWxlbWVudHMsIGxhYmVsbGVkRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGxhYmVsTGlzdCA9IGdldExhYmVscyhjb250YWluZXIsIGxhYmVsbGVkRWxlbWVudCwge1xuICAgICAgc2VsZWN0b3JcbiAgICB9KTtcbiAgICBsYWJlbExpc3QuZmlsdGVyKGxhYmVsID0+IEJvb2xlYW4obGFiZWwuZm9ybUNvbnRyb2wpKS5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgIGlmIChtYXRjaGVyKGxhYmVsLmNvbnRlbnQsIGxhYmVsLmZvcm1Db250cm9sLCB0ZXh0LCBtYXRjaE5vcm1hbGl6ZXIpICYmIGxhYmVsLmZvcm1Db250cm9sKSB7XG4gICAgICAgIGxhYmVsbGVkRWxlbWVudHMucHVzaChsYWJlbC5mb3JtQ29udHJvbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbGFiZWxzVmFsdWUgPSBsYWJlbExpc3QuZmlsdGVyKGxhYmVsID0+IEJvb2xlYW4obGFiZWwuY29udGVudCkpLm1hcChsYWJlbCA9PiBsYWJlbC5jb250ZW50KTtcbiAgICBpZiAobWF0Y2hlcihsYWJlbHNWYWx1ZS5qb2luKCcgJyksIGxhYmVsbGVkRWxlbWVudCwgdGV4dCwgbWF0Y2hOb3JtYWxpemVyKSkge1xuICAgICAgbGFiZWxsZWRFbGVtZW50cy5wdXNoKGxhYmVsbGVkRWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChsYWJlbHNWYWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICBsYWJlbHNWYWx1ZS5mb3JFYWNoKChsYWJlbFZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAobWF0Y2hlcihsYWJlbFZhbHVlLCBsYWJlbGxlZEVsZW1lbnQsIHRleHQsIG1hdGNoTm9ybWFsaXplcikpIHtcbiAgICAgICAgICBsYWJlbGxlZEVsZW1lbnRzLnB1c2gobGFiZWxsZWRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYWJlbHNGaWx0ZXJlZCA9IFsuLi5sYWJlbHNWYWx1ZV07XG4gICAgICAgIGxhYmVsc0ZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmIChsYWJlbHNGaWx0ZXJlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXIobGFiZWxzRmlsdGVyZWQuam9pbignICcpLCBsYWJlbGxlZEVsZW1lbnQsIHRleHQsIG1hdGNoTm9ybWFsaXplcikpIHtcbiAgICAgICAgICAgIGxhYmVsbGVkRWxlbWVudHMucHVzaChsYWJlbGxlZEVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbGxlZEVsZW1lbnRzO1xuICB9LCBbXSkuY29uY2F0KHF1ZXJ5QWxsQnlBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBjb250YWluZXIsIHRleHQsIHtcbiAgICBleGFjdCxcbiAgICBub3JtYWxpemVyOiBtYXRjaE5vcm1hbGl6ZXJcbiAgfSkpO1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KG1hdGNoaW5nTGFiZWxsZWRFbGVtZW50cykpLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpO1xufTtcblxuLy8gdGhlIGdldEFsbCogcXVlcnkgd291bGQgbm9ybWFsbHkgbG9vayBsaWtlIHRoaXM6XG4vLyBjb25zdCBnZXRBbGxCeUxhYmVsVGV4dCA9IG1ha2VHZXRBbGxRdWVyeShcbi8vICAgcXVlcnlBbGxCeUxhYmVsVGV4dCxcbi8vICAgKGMsIHRleHQpID0+IGBVbmFibGUgdG8gZmluZCBhIGxhYmVsIHdpdGggdGhlIHRleHQgb2Y6ICR7dGV4dH1gLFxuLy8gKVxuLy8gaG93ZXZlciwgd2UgY2FuIGdpdmUgYSBtb3JlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZSB0aGFuIHRoZSBnZW5lcmljIG9uZSxcbi8vIHNvIHdlJ3JlIHdyaXRpbmcgdGhpcyBvbmUgb3V0IGJ5IGhhbmQuXG5jb25zdCBnZXRBbGxCeUxhYmVsVGV4dCA9IGZ1bmN0aW9uIChjb250YWluZXIsIHRleHQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHJlc3RbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGNvbnN0IGVscyA9IHF1ZXJ5QWxsQnlMYWJlbFRleHQoY29udGFpbmVyLCB0ZXh0LCAuLi5yZXN0KTtcbiAgaWYgKCFlbHMubGVuZ3RoKSB7XG4gICAgY29uc3QgbGFiZWxzID0gcXVlcnlBbGxMYWJlbHNCeVRleHQoY29udGFpbmVyLCB0ZXh0LCAuLi5yZXN0KTtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGFnTmFtZXMgPSBsYWJlbHMubWFwKGxhYmVsID0+IGdldFRhZ05hbWVPZkVsZW1lbnRBc3NvY2lhdGVkV2l0aExhYmVsVmlhRm9yKGNvbnRhaW5lciwgbGFiZWwpKS5maWx0ZXIodGFnTmFtZSA9PiAhIXRhZ05hbWUpO1xuICAgICAgaWYgKHRhZ05hbWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBnZXRDb25maWcoKS5nZXRFbGVtZW50RXJyb3IodGFnTmFtZXMubWFwKHRhZ05hbWUgPT4gXCJGb3VuZCBhIGxhYmVsIHdpdGggdGhlIHRleHQgb2Y6IFwiICsgdGV4dCArIFwiLCBob3dldmVyIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxhYmVsICg8XCIgKyB0YWdOYW1lICsgXCIgLz4pIGlzIG5vbi1sYWJlbGxhYmxlIFtodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxhYmVsXS4gSWYgeW91IHJlYWxseSBuZWVkIHRvIGxhYmVsIGEgPFwiICsgdGFnTmFtZSArIFwiIC8+LCB5b3UgY2FuIHVzZSBhcmlhLWxhYmVsIG9yIGFyaWEtbGFiZWxsZWRieSBpbnN0ZWFkLlwiKS5qb2luKCdcXG5cXG4nKSwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGdldENvbmZpZygpLmdldEVsZW1lbnRFcnJvcihcIkZvdW5kIGEgbGFiZWwgd2l0aCB0aGUgdGV4dCBvZjogXCIgKyB0ZXh0ICsgXCIsIGhvd2V2ZXIgbm8gZm9ybSBjb250cm9sIHdhcyBmb3VuZCBhc3NvY2lhdGVkIHRvIHRoYXQgbGFiZWwuIE1ha2Ugc3VyZSB5b3UncmUgdXNpbmcgdGhlIFxcXCJmb3JcXFwiIGF0dHJpYnV0ZSBvciBcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIiBhdHRyaWJ1dGUgY29ycmVjdGx5LlwiLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBnZXRDb25maWcoKS5nZXRFbGVtZW50RXJyb3IoXCJVbmFibGUgdG8gZmluZCBhIGxhYmVsIHdpdGggdGhlIHRleHQgb2Y6IFwiICsgdGV4dCwgY29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVscztcbn07XG5mdW5jdGlvbiBnZXRUYWdOYW1lT2ZFbGVtZW50QXNzb2NpYXRlZFdpdGhMYWJlbFZpYUZvcihjb250YWluZXIsIGxhYmVsKSB7XG4gIGNvbnN0IGh0bWxGb3IgPSBsYWJlbC5nZXRBdHRyaWJ1dGUoJ2ZvcicpO1xuICBpZiAoIWh0bWxGb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJbaWQ9XFxcIlwiICsgaHRtbEZvciArIFwiXFxcIl1cIik7XG4gIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuXG4vLyB0aGUgcmVhc29uIG1lbnRpb25lZCBhYm92ZSBpcyB0aGUgc2FtZSByZWFzb24gd2UncmUgbm90IHVzaW5nIGJ1aWxkUXVlcmllc1xuY29uc3QgZ2V0TXVsdGlwbGVFcnJvciQ3ID0gKGMsIHRleHQpID0+IFwiRm91bmQgbXVsdGlwbGUgZWxlbWVudHMgd2l0aCB0aGUgdGV4dCBvZjogXCIgKyB0ZXh0O1xuY29uc3QgcXVlcnlCeUxhYmVsVGV4dCA9IHdyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uKG1ha2VTaW5nbGVRdWVyeShxdWVyeUFsbEJ5TGFiZWxUZXh0LCBnZXRNdWx0aXBsZUVycm9yJDcpLCBxdWVyeUFsbEJ5TGFiZWxUZXh0Lm5hbWUsICdxdWVyeScpO1xuY29uc3QgZ2V0QnlMYWJlbFRleHQgPSBtYWtlU2luZ2xlUXVlcnkoZ2V0QWxsQnlMYWJlbFRleHQsIGdldE11bHRpcGxlRXJyb3IkNyk7XG5jb25zdCBmaW5kQWxsQnlMYWJlbFRleHQgPSBtYWtlRmluZFF1ZXJ5KHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24oZ2V0QWxsQnlMYWJlbFRleHQsIGdldEFsbEJ5TGFiZWxUZXh0Lm5hbWUsICdmaW5kQWxsJykpO1xuY29uc3QgZmluZEJ5TGFiZWxUZXh0ID0gbWFrZUZpbmRRdWVyeSh3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbihnZXRCeUxhYmVsVGV4dCwgZ2V0QWxsQnlMYWJlbFRleHQubmFtZSwgJ2ZpbmQnKSk7XG5jb25zdCBnZXRBbGxCeUxhYmVsVGV4dFdpdGhTdWdnZXN0aW9ucyA9IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24oZ2V0QWxsQnlMYWJlbFRleHQsIGdldEFsbEJ5TGFiZWxUZXh0Lm5hbWUsICdnZXRBbGwnKTtcbmNvbnN0IGdldEJ5TGFiZWxUZXh0V2l0aFN1Z2dlc3Rpb25zID0gd3JhcFNpbmdsZVF1ZXJ5V2l0aFN1Z2dlc3Rpb24oZ2V0QnlMYWJlbFRleHQsIGdldEFsbEJ5TGFiZWxUZXh0Lm5hbWUsICdnZXQnKTtcbmNvbnN0IHF1ZXJ5QWxsQnlMYWJlbFRleHRXaXRoU3VnZ2VzdGlvbnMgPSB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uKHF1ZXJ5QWxsQnlMYWJlbFRleHQsIHF1ZXJ5QWxsQnlMYWJlbFRleHQubmFtZSwgJ3F1ZXJ5QWxsJyk7XG5cbmNvbnN0IHF1ZXJ5QWxsQnlQbGFjZWhvbGRlclRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgY2hlY2tDb250YWluZXJUeXBlKGFyZ3NbMF0pO1xuICByZXR1cm4gcXVlcnlBbGxCeUF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCAuLi5hcmdzKTtcbn07XG5jb25zdCBnZXRNdWx0aXBsZUVycm9yJDYgPSAoYywgdGV4dCkgPT4gXCJGb3VuZCBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBwbGFjZWhvbGRlciB0ZXh0IG9mOiBcIiArIHRleHQ7XG5jb25zdCBnZXRNaXNzaW5nRXJyb3IkNiA9IChjLCB0ZXh0KSA9PiBcIlVuYWJsZSB0byBmaW5kIGFuIGVsZW1lbnQgd2l0aCB0aGUgcGxhY2Vob2xkZXIgdGV4dCBvZjogXCIgKyB0ZXh0O1xuY29uc3QgcXVlcnlBbGxCeVBsYWNlaG9sZGVyVGV4dFdpdGhTdWdnZXN0aW9ucyA9IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24ocXVlcnlBbGxCeVBsYWNlaG9sZGVyVGV4dCwgcXVlcnlBbGxCeVBsYWNlaG9sZGVyVGV4dC5uYW1lLCAncXVlcnlBbGwnKTtcbmNvbnN0IFtxdWVyeUJ5UGxhY2Vob2xkZXJUZXh0LCBnZXRBbGxCeVBsYWNlaG9sZGVyVGV4dCwgZ2V0QnlQbGFjZWhvbGRlclRleHQsIGZpbmRBbGxCeVBsYWNlaG9sZGVyVGV4dCwgZmluZEJ5UGxhY2Vob2xkZXJUZXh0XSA9IGJ1aWxkUXVlcmllcyhxdWVyeUFsbEJ5UGxhY2Vob2xkZXJUZXh0LCBnZXRNdWx0aXBsZUVycm9yJDYsIGdldE1pc3NpbmdFcnJvciQ2KTtcblxuY29uc3QgcXVlcnlBbGxCeVRleHQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCB0ZXh0LCBfdGVtcCkge1xuICBsZXQge1xuICAgIHNlbGVjdG9yID0gJyonLFxuICAgIGV4YWN0ID0gdHJ1ZSxcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgdHJpbSxcbiAgICBpZ25vcmUgPSBnZXRDb25maWcoKS5kZWZhdWx0SWdub3JlLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjaGVja0NvbnRhaW5lclR5cGUoY29udGFpbmVyKTtcbiAgY29uc3QgbWF0Y2hlciA9IGV4YWN0ID8gbWF0Y2hlcyA6IGZ1enp5TWF0Y2hlcztcbiAgY29uc3QgbWF0Y2hOb3JtYWxpemVyID0gbWFrZU5vcm1hbGl6ZXIoe1xuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSk7XG4gIGxldCBiYXNlQXJyYXkgPSBbXTtcbiAgaWYgKHR5cGVvZiBjb250YWluZXIubWF0Y2hlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBjb250YWluZXIubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICBiYXNlQXJyYXkgPSBbY29udGFpbmVyXTtcbiAgfVxuICByZXR1cm4gWy4uLmJhc2VBcnJheSwgLi4uQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXVxuICAvLyBUT0RPOiBgbWF0Y2hlc2AgYWNjb3JkaW5nIGxpYi5kb20uZC50cyBjYW4gZ2V0IG9ubHkgYHN0cmluZ2AgYnV0IGFjY29yZGluZyBvdXIgY29kZSBpdCBjYW4gaGFuZGxlIGFsc28gYm9vbGVhbiA6KVxuICAuZmlsdGVyKG5vZGUgPT4gIWlnbm9yZSB8fCAhbm9kZS5tYXRjaGVzKGlnbm9yZSkpLmZpbHRlcihub2RlID0+IG1hdGNoZXIoZ2V0Tm9kZVRleHQobm9kZSksIG5vZGUsIHRleHQsIG1hdGNoTm9ybWFsaXplcikpO1xufTtcbmNvbnN0IGdldE11bHRpcGxlRXJyb3IkNSA9IChjLCB0ZXh0KSA9PiBcIkZvdW5kIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHRleHQ6IFwiICsgdGV4dDtcbmNvbnN0IGdldE1pc3NpbmdFcnJvciQ1ID0gZnVuY3Rpb24gKGMsIHRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgY29sbGFwc2VXaGl0ZXNwYWNlLFxuICAgIHRyaW0sXG4gICAgbm9ybWFsaXplcixcbiAgICBzZWxlY3RvclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbWF0Y2hOb3JtYWxpemVyID0gbWFrZU5vcm1hbGl6ZXIoe1xuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gbWF0Y2hOb3JtYWxpemVyKHRleHQudG9TdHJpbmcoKSk7XG4gIGNvbnN0IGlzTm9ybWFsaXplZERpZmZlcmVudCA9IG5vcm1hbGl6ZWRUZXh0ICE9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gIGNvbnN0IGlzQ3VzdG9tU2VsZWN0b3IgPSAoc2VsZWN0b3IgIT0gbnVsbCA/IHNlbGVjdG9yIDogJyonKSAhPT0gJyonO1xuICByZXR1cm4gXCJVbmFibGUgdG8gZmluZCBhbiBlbGVtZW50IHdpdGggdGhlIHRleHQ6IFwiICsgKGlzTm9ybWFsaXplZERpZmZlcmVudCA/IG5vcm1hbGl6ZWRUZXh0ICsgXCIgKG5vcm1hbGl6ZWQgZnJvbSAnXCIgKyB0ZXh0ICsgXCInKVwiIDogdGV4dCkgKyAoaXNDdXN0b21TZWxlY3RvciA/IFwiLCB3aGljaCBtYXRjaGVzIHNlbGVjdG9yICdcIiArIHNlbGVjdG9yICsgXCInXCIgOiAnJykgKyBcIi4gVGhpcyBjb3VsZCBiZSBiZWNhdXNlIHRoZSB0ZXh0IGlzIGJyb2tlbiB1cCBieSBtdWx0aXBsZSBlbGVtZW50cy4gSW4gdGhpcyBjYXNlLCB5b3UgY2FuIHByb3ZpZGUgYSBmdW5jdGlvbiBmb3IgeW91ciB0ZXh0IG1hdGNoZXIgdG8gbWFrZSB5b3VyIG1hdGNoZXIgbW9yZSBmbGV4aWJsZS5cIjtcbn07XG5jb25zdCBxdWVyeUFsbEJ5VGV4dFdpdGhTdWdnZXN0aW9ucyA9IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24ocXVlcnlBbGxCeVRleHQsIHF1ZXJ5QWxsQnlUZXh0Lm5hbWUsICdxdWVyeUFsbCcpO1xuY29uc3QgW3F1ZXJ5QnlUZXh0LCBnZXRBbGxCeVRleHQsIGdldEJ5VGV4dCwgZmluZEFsbEJ5VGV4dCwgZmluZEJ5VGV4dF0gPSBidWlsZFF1ZXJpZXMocXVlcnlBbGxCeVRleHQsIGdldE11bHRpcGxlRXJyb3IkNSwgZ2V0TWlzc2luZ0Vycm9yJDUpO1xuXG5jb25zdCBxdWVyeUFsbEJ5RGlzcGxheVZhbHVlID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgdmFsdWUsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgZXhhY3QgPSB0cnVlLFxuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjaGVja0NvbnRhaW5lclR5cGUoY29udGFpbmVyKTtcbiAgY29uc3QgbWF0Y2hlciA9IGV4YWN0ID8gbWF0Y2hlcyA6IGZ1enp5TWF0Y2hlcztcbiAgY29uc3QgbWF0Y2hOb3JtYWxpemVyID0gbWFrZU5vcm1hbGl6ZXIoe1xuICAgIGNvbGxhcHNlV2hpdGVzcGFjZSxcbiAgICB0cmltLFxuICAgIG5vcm1hbGl6ZXJcbiAgfSk7XG4gIHJldHVybiBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXQsdGV4dGFyZWEsc2VsZWN0XCIpKS5maWx0ZXIobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IEFycmF5LmZyb20obm9kZS5vcHRpb25zKS5maWx0ZXIob3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRPcHRpb25zLnNvbWUob3B0aW9uTm9kZSA9PiBtYXRjaGVyKGdldE5vZGVUZXh0KG9wdGlvbk5vZGUpLCBvcHRpb25Ob2RlLCB2YWx1ZSwgbWF0Y2hOb3JtYWxpemVyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXRjaGVyKG5vZGUudmFsdWUsIG5vZGUsIHZhbHVlLCBtYXRjaE5vcm1hbGl6ZXIpO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgZ2V0TXVsdGlwbGVFcnJvciQ0ID0gKGMsIHZhbHVlKSA9PiBcIkZvdW5kIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIGRpc3BsYXkgdmFsdWU6IFwiICsgdmFsdWUgKyBcIi5cIjtcbmNvbnN0IGdldE1pc3NpbmdFcnJvciQ0ID0gKGMsIHZhbHVlKSA9PiBcIlVuYWJsZSB0byBmaW5kIGFuIGVsZW1lbnQgd2l0aCB0aGUgZGlzcGxheSB2YWx1ZTogXCIgKyB2YWx1ZSArIFwiLlwiO1xuY29uc3QgcXVlcnlBbGxCeURpc3BsYXlWYWx1ZVdpdGhTdWdnZXN0aW9ucyA9IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24ocXVlcnlBbGxCeURpc3BsYXlWYWx1ZSwgcXVlcnlBbGxCeURpc3BsYXlWYWx1ZS5uYW1lLCAncXVlcnlBbGwnKTtcbmNvbnN0IFtxdWVyeUJ5RGlzcGxheVZhbHVlLCBnZXRBbGxCeURpc3BsYXlWYWx1ZSwgZ2V0QnlEaXNwbGF5VmFsdWUsIGZpbmRBbGxCeURpc3BsYXlWYWx1ZSwgZmluZEJ5RGlzcGxheVZhbHVlXSA9IGJ1aWxkUXVlcmllcyhxdWVyeUFsbEJ5RGlzcGxheVZhbHVlLCBnZXRNdWx0aXBsZUVycm9yJDQsIGdldE1pc3NpbmdFcnJvciQ0KTtcblxuLy8gVmFsaWQgdGFncyBhcmUgaW1nLCBpbnB1dCwgYXJlYSBhbmQgY3VzdG9tIGVsZW1lbnRzXG5jb25zdCBWQUxJRF9UQUdfUkVHRVhQID0gL14oaW1nfGlucHV0fGFyZWF8ListLispJC9pO1xuY29uc3QgcXVlcnlBbGxCeUFsdFRleHQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBhbHQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjaGVja0NvbnRhaW5lclR5cGUoY29udGFpbmVyKTtcbiAgcmV0dXJuIHF1ZXJ5QWxsQnlBdHRyaWJ1dGUoJ2FsdCcsIGNvbnRhaW5lciwgYWx0LCBvcHRpb25zKS5maWx0ZXIobm9kZSA9PiBWQUxJRF9UQUdfUkVHRVhQLnRlc3Qobm9kZS50YWdOYW1lKSk7XG59O1xuY29uc3QgZ2V0TXVsdGlwbGVFcnJvciQzID0gKGMsIGFsdCkgPT4gXCJGb3VuZCBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBhbHQgdGV4dDogXCIgKyBhbHQ7XG5jb25zdCBnZXRNaXNzaW5nRXJyb3IkMyA9IChjLCBhbHQpID0+IFwiVW5hYmxlIHRvIGZpbmQgYW4gZWxlbWVudCB3aXRoIHRoZSBhbHQgdGV4dDogXCIgKyBhbHQ7XG5jb25zdCBxdWVyeUFsbEJ5QWx0VGV4dFdpdGhTdWdnZXN0aW9ucyA9IHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24ocXVlcnlBbGxCeUFsdFRleHQsIHF1ZXJ5QWxsQnlBbHRUZXh0Lm5hbWUsICdxdWVyeUFsbCcpO1xuY29uc3QgW3F1ZXJ5QnlBbHRUZXh0LCBnZXRBbGxCeUFsdFRleHQsIGdldEJ5QWx0VGV4dCwgZmluZEFsbEJ5QWx0VGV4dCwgZmluZEJ5QWx0VGV4dF0gPSBidWlsZFF1ZXJpZXMocXVlcnlBbGxCeUFsdFRleHQsIGdldE11bHRpcGxlRXJyb3IkMywgZ2V0TWlzc2luZ0Vycm9yJDMpO1xuXG5jb25zdCBpc1N2Z1RpdGxlID0gbm9kZSA9PiB7XG4gIHZhciBfbm9kZSRwYXJlbnRFbGVtZW50O1xuICByZXR1cm4gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0aXRsZScgJiYgKChfbm9kZSRwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkcGFyZW50RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAnc3ZnJztcbn07XG5jb25zdCBxdWVyeUFsbEJ5VGl0bGUgPSBmdW5jdGlvbiAoY29udGFpbmVyLCB0ZXh0LCBfdGVtcCkge1xuICBsZXQge1xuICAgIGV4YWN0ID0gdHJ1ZSxcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgdHJpbSxcbiAgICBub3JtYWxpemVyXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY2hlY2tDb250YWluZXJUeXBlKGNvbnRhaW5lcik7XG4gIGNvbnN0IG1hdGNoZXIgPSBleGFjdCA/IG1hdGNoZXMgOiBmdXp6eU1hdGNoZXM7XG4gIGNvbnN0IG1hdGNoTm9ybWFsaXplciA9IG1ha2VOb3JtYWxpemVyKHtcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgdHJpbSxcbiAgICBub3JtYWxpemVyXG4gIH0pO1xuICByZXR1cm4gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW3RpdGxlXSwgc3ZnID4gdGl0bGUnKSkuZmlsdGVyKG5vZGUgPT4gbWF0Y2hlcihub2RlLmdldEF0dHJpYnV0ZSgndGl0bGUnKSwgbm9kZSwgdGV4dCwgbWF0Y2hOb3JtYWxpemVyKSB8fCBpc1N2Z1RpdGxlKG5vZGUpICYmIG1hdGNoZXIoZ2V0Tm9kZVRleHQobm9kZSksIG5vZGUsIHRleHQsIG1hdGNoTm9ybWFsaXplcikpO1xufTtcbmNvbnN0IGdldE11bHRpcGxlRXJyb3IkMiA9IChjLCB0aXRsZSkgPT4gXCJGb3VuZCBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSB0aXRsZTogXCIgKyB0aXRsZSArIFwiLlwiO1xuY29uc3QgZ2V0TWlzc2luZ0Vycm9yJDIgPSAoYywgdGl0bGUpID0+IFwiVW5hYmxlIHRvIGZpbmQgYW4gZWxlbWVudCB3aXRoIHRoZSB0aXRsZTogXCIgKyB0aXRsZSArIFwiLlwiO1xuY29uc3QgcXVlcnlBbGxCeVRpdGxlV2l0aFN1Z2dlc3Rpb25zID0gd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihxdWVyeUFsbEJ5VGl0bGUsIHF1ZXJ5QWxsQnlUaXRsZS5uYW1lLCAncXVlcnlBbGwnKTtcbmNvbnN0IFtxdWVyeUJ5VGl0bGUsIGdldEFsbEJ5VGl0bGUsIGdldEJ5VGl0bGUsIGZpbmRBbGxCeVRpdGxlLCBmaW5kQnlUaXRsZV0gPSBidWlsZFF1ZXJpZXMocXVlcnlBbGxCeVRpdGxlLCBnZXRNdWx0aXBsZUVycm9yJDIsIGdldE1pc3NpbmdFcnJvciQyKTtcblxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuY29uc3QgcXVlcnlBbGxCeVJvbGUgPSBmdW5jdGlvbiAoY29udGFpbmVyLCByb2xlLCBfdGVtcCkge1xuICBsZXQge1xuICAgIGhpZGRlbiA9IGdldENvbmZpZygpLmRlZmF1bHRIaWRkZW4sXG4gICAgbmFtZSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBxdWVyeUZhbGxiYWNrcyA9IGZhbHNlLFxuICAgIHNlbGVjdGVkLFxuICAgIGJ1c3ksXG4gICAgY2hlY2tlZCxcbiAgICBwcmVzc2VkLFxuICAgIGN1cnJlbnQsXG4gICAgbGV2ZWwsXG4gICAgZXhwYW5kZWQsXG4gICAgdmFsdWU6IHtcbiAgICAgIG5vdzogdmFsdWVOb3csXG4gICAgICBtaW46IHZhbHVlTWluLFxuICAgICAgbWF4OiB2YWx1ZU1heCxcbiAgICAgIHRleHQ6IHZhbHVlVGV4dFxuICAgIH0gPSB7fVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNoZWNrQ29udGFpbmVyVHlwZShjb250YWluZXIpO1xuICBpZiAoc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYWxsUm9sZXMkZ2V0O1xuICAgIC8vIGd1YXJkIGFnYWluc3QgdW5rbm93biByb2xlc1xuICAgIGlmICgoKF9hbGxSb2xlcyRnZXQgPSByb2xlcy5nZXQocm9sZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYWxsUm9sZXMkZ2V0LnByb3BzWydhcmlhLXNlbGVjdGVkJ10pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJhcmlhLXNlbGVjdGVkXFxcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIi5cIik7XG4gICAgfVxuICB9XG4gIGlmIChidXN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2FsbFJvbGVzJGdldDI7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCB1bmtub3duIHJvbGVzXG4gICAgaWYgKCgoX2FsbFJvbGVzJGdldDIgPSByb2xlcy5nZXQocm9sZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYWxsUm9sZXMkZ2V0Mi5wcm9wc1snYXJpYS1idXN5J10pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJhcmlhLWJ1c3lcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgb24gcm9sZSBcXFwiXCIgKyByb2xlICsgXCJcXFwiLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNoZWNrZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYWxsUm9sZXMkZ2V0MztcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHVua25vd24gcm9sZXNcbiAgICBpZiAoKChfYWxsUm9sZXMkZ2V0MyA9IHJvbGVzLmdldChyb2xlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbGxSb2xlcyRnZXQzLnByb3BzWydhcmlhLWNoZWNrZWQnXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImFyaWEtY2hlY2tlZFxcXCIgaXMgbm90IHN1cHBvcnRlZCBvbiByb2xlIFxcXCJcIiArIHJvbGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAocHJlc3NlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hbGxSb2xlcyRnZXQ0O1xuICAgIC8vIGd1YXJkIGFnYWluc3QgdW5rbm93biByb2xlc1xuICAgIGlmICgoKF9hbGxSb2xlcyRnZXQ0ID0gcm9sZXMuZ2V0KHJvbGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2FsbFJvbGVzJGdldDQucHJvcHNbJ2FyaWEtcHJlc3NlZCddKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXFwiYXJpYS1wcmVzc2VkXFxcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIi5cIik7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2FsbFJvbGVzJGdldDU7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvLyBndWFyZCBhZ2FpbnN0IHVua25vd24gcm9sZXNcbiAgICAvLyBBbGwgY3VycmVudGx5IHJlbGVhc2VkIEFSSUEgdmVyc2lvbnMgc3VwcG9ydCBgYXJpYS1jdXJyZW50YCBvbiBhbGwgcm9sZXMuXG4gICAgLy8gTGVhdmluZyB0aGlzIGZvciBzeW1ldHJ5IGFuZCBmb3J3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoKChfYWxsUm9sZXMkZ2V0NSA9IHJvbGVzLmdldChyb2xlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbGxSb2xlcyRnZXQ1LnByb3BzWydhcmlhLWN1cnJlbnQnXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImFyaWEtY3VycmVudFxcXCIgaXMgbm90IHN1cHBvcnRlZCBvbiByb2xlIFxcXCJcIiArIHJvbGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGd1YXJkIGFnYWluc3QgdXNpbmcgYGxldmVsYCBvcHRpb24gd2l0aCBhbnkgcm9sZSBvdGhlciB0aGFuIGBoZWFkaW5nYFxuICAgIGlmIChyb2xlICE9PSAnaGVhZGluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIiBjYW5ub3QgaGF2ZSBcXFwibGV2ZWxcXFwiIHByb3BlcnR5LlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbHVlTm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2FsbFJvbGVzJGdldDY7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCB1bmtub3duIHJvbGVzXG4gICAgaWYgKCgoX2FsbFJvbGVzJGdldDYgPSByb2xlcy5nZXQocm9sZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYWxsUm9sZXMkZ2V0Ni5wcm9wc1snYXJpYS12YWx1ZW5vdyddKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXFwiYXJpYS12YWx1ZW5vd1xcXCIgaXMgbm90IHN1cHBvcnRlZCBvbiByb2xlIFxcXCJcIiArIHJvbGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAodmFsdWVNYXggIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYWxsUm9sZXMkZ2V0NztcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHVua25vd24gcm9sZXNcbiAgICBpZiAoKChfYWxsUm9sZXMkZ2V0NyA9IHJvbGVzLmdldChyb2xlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbGxSb2xlcyRnZXQ3LnByb3BzWydhcmlhLXZhbHVlbWF4J10pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJhcmlhLXZhbHVlbWF4XFxcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIi5cIik7XG4gICAgfVxuICB9XG4gIGlmICh2YWx1ZU1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hbGxSb2xlcyRnZXQ4O1xuICAgIC8vIGd1YXJkIGFnYWluc3QgdW5rbm93biByb2xlc1xuICAgIGlmICgoKF9hbGxSb2xlcyRnZXQ4ID0gcm9sZXMuZ2V0KHJvbGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2FsbFJvbGVzJGdldDgucHJvcHNbJ2FyaWEtdmFsdWVtaW4nXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcImFyaWEtdmFsdWVtaW5cXFwiIGlzIG5vdCBzdXBwb3J0ZWQgb24gcm9sZSBcXFwiXCIgKyByb2xlICsgXCJcXFwiLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbHVlVGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hbGxSb2xlcyRnZXQ5O1xuICAgIC8vIGd1YXJkIGFnYWluc3QgdW5rbm93biByb2xlc1xuICAgIGlmICgoKF9hbGxSb2xlcyRnZXQ5ID0gcm9sZXMuZ2V0KHJvbGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2FsbFJvbGVzJGdldDkucHJvcHNbJ2FyaWEtdmFsdWV0ZXh0J10pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJhcmlhLXZhbHVldGV4dFxcXCIgaXMgbm90IHN1cHBvcnRlZCBvbiByb2xlIFxcXCJcIiArIHJvbGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwYW5kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYWxsUm9sZXMkZ2V0MTA7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCB1bmtub3duIHJvbGVzXG4gICAgaWYgKCgoX2FsbFJvbGVzJGdldDEwID0gcm9sZXMuZ2V0KHJvbGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2FsbFJvbGVzJGdldDEwLnByb3BzWydhcmlhLWV4cGFuZGVkJ10pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJhcmlhLWV4cGFuZGVkXFxcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIi5cIik7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN1YnRyZWVJc0luYWNjZXNzaWJsZUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gY2FjaGVkSXNTdWJ0cmVlSW5hY2Nlc3NpYmxlKGVsZW1lbnQpIHtcbiAgICBpZiAoIXN1YnRyZWVJc0luYWNjZXNzaWJsZUNhY2hlLmhhcyhlbGVtZW50KSkge1xuICAgICAgc3VidHJlZUlzSW5hY2Nlc3NpYmxlQ2FjaGUuc2V0KGVsZW1lbnQsIGlzU3VidHJlZUluYWNjZXNzaWJsZShlbGVtZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBzdWJ0cmVlSXNJbmFjY2Vzc2libGVDYWNoZS5nZXQoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gIC8vIE9ubHkgcXVlcnkgZWxlbWVudHMgdGhhdCBjYW4gYmUgbWF0Y2hlZCBieSB0aGUgZm9sbG93aW5nIGZpbHRlcnNcbiAgbWFrZVJvbGVTZWxlY3Rvcihyb2xlKSkpLmZpbHRlcihub2RlID0+IHtcbiAgICBjb25zdCBpc1JvbGVTcGVjaWZpZWRFeHBsaWNpdGx5ID0gbm9kZS5oYXNBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICBpZiAoaXNSb2xlU3BlY2lmaWVkRXhwbGljaXRseSkge1xuICAgICAgY29uc3Qgcm9sZVZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgIGlmIChxdWVyeUZhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gcm9sZVZhbHVlLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pLnNvbWUocm9sZUF0dHJpYnV0ZVRva2VuID0+IHJvbGVBdHRyaWJ1dGVUb2tlbiA9PT0gcm9sZSk7XG4gICAgICB9XG4gICAgICAvLyBvdGhlciB3aXNlIG9ubHkgc2VuZCB0aGUgZmlyc3QgdG9rZW4gdG8gbWF0Y2hcbiAgICAgIGNvbnN0IFtmaXJzdFJvbGVBdHRyaWJ1dGVUb2tlbl0gPSByb2xlVmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBmaXJzdFJvbGVBdHRyaWJ1dGVUb2tlbiA9PT0gcm9sZTtcbiAgICB9XG4gICAgY29uc3QgaW1wbGljaXRSb2xlcyA9IGdldEltcGxpY2l0QXJpYVJvbGVzKG5vZGUpO1xuICAgIHJldHVybiBpbXBsaWNpdFJvbGVzLnNvbWUoaW1wbGljaXRSb2xlID0+IHtcbiAgICAgIHJldHVybiBpbXBsaWNpdFJvbGUgPT09IHJvbGU7XG4gICAgfSk7XG4gIH0pLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICBpZiAoc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkID09PSBjb21wdXRlQXJpYVNlbGVjdGVkKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoYnVzeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYnVzeSA9PT0gY29tcHV0ZUFyaWFCdXN5KGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoY2hlY2tlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2hlY2tlZCA9PT0gY29tcHV0ZUFyaWFDaGVja2VkKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAocHJlc3NlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJlc3NlZCA9PT0gY29tcHV0ZUFyaWFQcmVzc2VkKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY3VycmVudCA9PT0gY29tcHV0ZUFyaWFDdXJyZW50KGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoZXhwYW5kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSBjb21wdXRlQXJpYUV4cGFuZGVkKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGxldmVsID09PSBjb21wdXRlSGVhZGluZ0xldmVsKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodmFsdWVOb3cgIT09IHVuZGVmaW5lZCB8fCB2YWx1ZU1heCAhPT0gdW5kZWZpbmVkIHx8IHZhbHVlTWluICE9PSB1bmRlZmluZWQgfHwgdmFsdWVUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB2YWx1ZU1hdGNoZXMgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlTm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVNYXRjaGVzICYmICh2YWx1ZU1hdGNoZXMgPSB2YWx1ZU5vdyA9PT0gY29tcHV0ZUFyaWFWYWx1ZU5vdyhlbGVtZW50KSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVNYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZU1hdGNoZXMgJiYgKHZhbHVlTWF0Y2hlcyA9IHZhbHVlTWF4ID09PSBjb21wdXRlQXJpYVZhbHVlTWF4KGVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZU1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlTWF0Y2hlcyAmJiAodmFsdWVNYXRjaGVzID0gdmFsdWVNaW4gPT09IGNvbXB1dGVBcmlhVmFsdWVNaW4oZWxlbWVudCkpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlVGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfY29tcHV0ZUFyaWFWYWx1ZVRleHQ7XG4gICAgICAgIHZhbHVlTWF0Y2hlcyAmJiAodmFsdWVNYXRjaGVzID0gbWF0Y2hlcygoX2NvbXB1dGVBcmlhVmFsdWVUZXh0ID0gY29tcHV0ZUFyaWFWYWx1ZVRleHQoZWxlbWVudCkpICE9IG51bGwgPyBfY29tcHV0ZUFyaWFWYWx1ZVRleHQgOiBudWxsLCBlbGVtZW50LCB2YWx1ZVRleHQsIHRleHQgPT4gdGV4dCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlTWF0Y2hlcztcbiAgICB9XG4gICAgLy8gZG9uJ3QgY2FyZSBpZiBhcmlhIGF0dHJpYnV0ZXMgYXJlIHVuc3BlY2lmaWVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBEb24ndCBjYXJlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXMoY29tcHV0ZUFjY2Vzc2libGVOYW1lKGVsZW1lbnQsIHtcbiAgICAgIGNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzOiBnZXRDb25maWcoKS5jb21wdXRlZFN0eWxlU3VwcG9ydHNQc2V1ZG9FbGVtZW50c1xuICAgIH0pLCBlbGVtZW50LCBuYW1lLCB0ZXh0ID0+IHRleHQpO1xuICB9KS5maWx0ZXIoZWxlbWVudCA9PiB7XG4gICAgaWYgKGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIERvbid0IGNhcmVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcyhjb21wdXRlQWNjZXNzaWJsZURlc2NyaXB0aW9uKGVsZW1lbnQsIHtcbiAgICAgIGNvbXB1dGVkU3R5bGVTdXBwb3J0c1BzZXVkb0VsZW1lbnRzOiBnZXRDb25maWcoKS5jb21wdXRlZFN0eWxlU3VwcG9ydHNQc2V1ZG9FbGVtZW50c1xuICAgIH0pLCBlbGVtZW50LCBkZXNjcmlwdGlvbiwgdGV4dCA9PiB0ZXh0KTtcbiAgfSkuZmlsdGVyKGVsZW1lbnQgPT4ge1xuICAgIHJldHVybiBoaWRkZW4gPT09IGZhbHNlID8gaXNJbmFjY2Vzc2libGUoZWxlbWVudCwge1xuICAgICAgaXNTdWJ0cmVlSW5hY2Nlc3NpYmxlOiBjYWNoZWRJc1N1YnRyZWVJbmFjY2Vzc2libGVcbiAgICB9KSA9PT0gZmFsc2UgOiB0cnVlO1xuICB9KTtcbn07XG5mdW5jdGlvbiBtYWtlUm9sZVNlbGVjdG9yKHJvbGUpIHtcbiAgdmFyIF9yb2xlRWxlbWVudHMkZ2V0O1xuICBjb25zdCBleHBsaWNpdFJvbGVTZWxlY3RvciA9IFwiKltyb2xlfj1cXFwiXCIgKyByb2xlICsgXCJcXFwiXVwiO1xuICBjb25zdCByb2xlUmVsYXRpb25zID0gKF9yb2xlRWxlbWVudHMkZ2V0ID0gcm9sZUVsZW1lbnRzLmdldChyb2xlKSkgIT0gbnVsbCA/IF9yb2xlRWxlbWVudHMkZ2V0IDogbmV3IFNldCgpO1xuICBjb25zdCBpbXBsaWNpdFJvbGVTZWxlY3RvcnMgPSBuZXcgU2V0KEFycmF5LmZyb20ocm9sZVJlbGF0aW9ucykubWFwKF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICBuYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH0pKTtcblxuICAvLyBDdXJyZW50IHRyYW5zcGlsYXRpb24gY29uZmlnIHNvbWV0aW1lcyBhc3N1bWVzIGAuLi5gIGlzIGFsd2F5cyBhcHBsaWVkIHRvIGFycmF5cy5cbiAgLy8gYC4uLmAgaXMgZXF1aXZhbGVudCB0byBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgZm9yIGFycmF5cy5cbiAgLy8gSWYgeW91IHJlcGxhY2UgdGhpcyBjb2RlIHdpdGggYFtleHBsaWNpdFJvbGVTZWxlY3RvciwgLi4uaW1wbGljaXRSb2xlU2VsZWN0b3JzXWAsIG1ha2Ugc3VyZSBldmVyeSB0cmFuc3BpbGF0aW9uIHRhcmdldCByZXRhaW5zIHRoZSBgLi4uYCBpbiBmYXZvciBvZiBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAuXG4gIHJldHVybiBbZXhwbGljaXRSb2xlU2VsZWN0b3JdLmNvbmNhdChBcnJheS5mcm9tKGltcGxpY2l0Um9sZVNlbGVjdG9ycykpLmpvaW4oJywnKTtcbn1cbmNvbnN0IGdldE5hbWVIaW50ID0gbmFtZSA9PiB7XG4gIGxldCBuYW1lSGludCA9ICcnO1xuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbmFtZUhpbnQgPSAnJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lSGludCA9IFwiIGFuZCBuYW1lIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIjtcbiAgfSBlbHNlIHtcbiAgICBuYW1lSGludCA9IFwiIGFuZCBuYW1lIGBcIiArIG5hbWUgKyBcImBcIjtcbiAgfVxuICByZXR1cm4gbmFtZUhpbnQ7XG59O1xuY29uc3QgZ2V0TXVsdGlwbGVFcnJvciQxID0gZnVuY3Rpb24gKGMsIHJvbGUsIF90ZW1wMikge1xuICBsZXQge1xuICAgIG5hbWVcbiAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gIHJldHVybiBcIkZvdW5kIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHJvbGUgXFxcIlwiICsgcm9sZSArIFwiXFxcIlwiICsgZ2V0TmFtZUhpbnQobmFtZSk7XG59O1xuY29uc3QgZ2V0TWlzc2luZ0Vycm9yJDEgPSBmdW5jdGlvbiAoY29udGFpbmVyLCByb2xlLCBfdGVtcDMpIHtcbiAgbGV0IHtcbiAgICBoaWRkZW4gPSBnZXRDb25maWcoKS5kZWZhdWx0SGlkZGVuLFxuICAgIG5hbWUsXG4gICAgZGVzY3JpcHRpb25cbiAgfSA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDM7XG4gIGlmIChnZXRDb25maWcoKS5fZGlzYWJsZUV4cGVuc2l2ZUVycm9yRGlhZ25vc3RpY3MpIHtcbiAgICByZXR1cm4gXCJVbmFibGUgdG8gZmluZCByb2xlPVxcXCJcIiArIHJvbGUgKyBcIlxcXCJcIiArIGdldE5hbWVIaW50KG5hbWUpO1xuICB9XG4gIGxldCByb2xlcyA9ICcnO1xuICBBcnJheS5mcm9tKGNvbnRhaW5lci5jaGlsZHJlbikuZm9yRWFjaChjaGlsZEVsZW1lbnQgPT4ge1xuICAgIHJvbGVzICs9IHByZXR0eVJvbGVzKGNoaWxkRWxlbWVudCwge1xuICAgICAgaGlkZGVuLFxuICAgICAgaW5jbHVkZURlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0pO1xuICBsZXQgcm9sZU1lc3NhZ2U7XG4gIGlmIChyb2xlcy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgcm9sZU1lc3NhZ2UgPSAnVGhlcmUgYXJlIG5vIGFjY2Vzc2libGUgcm9sZXMuIEJ1dCB0aGVyZSBtaWdodCBiZSBzb21lIGluYWNjZXNzaWJsZSByb2xlcy4gJyArICdJZiB5b3Ugd2lzaCB0byBhY2Nlc3MgdGhlbSwgdGhlbiBzZXQgdGhlIGBoaWRkZW5gIG9wdGlvbiB0byBgdHJ1ZWAuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vdGVzdGluZy1saWJyYXJ5LmNvbS9kb2NzL2RvbS10ZXN0aW5nLWxpYnJhcnkvYXBpLXF1ZXJpZXMjYnlyb2xlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcm9sZU1lc3NhZ2UgPSAnVGhlcmUgYXJlIG5vIGF2YWlsYWJsZSByb2xlcy4nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByb2xlTWVzc2FnZSA9IChcIlxcbkhlcmUgYXJlIHRoZSBcIiArIChoaWRkZW4gPT09IGZhbHNlID8gJ2FjY2Vzc2libGUnIDogJ2F2YWlsYWJsZScpICsgXCIgcm9sZXM6XFxuXFxuICBcIiArIHJvbGVzLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAnKS5yZXBsYWNlKC9cXG5cXHNcXHNcXG4vZywgJ1xcblxcbicpICsgXCJcXG5cIikudHJpbSgpO1xuICB9XG4gIGxldCBuYW1lSGludCA9ICcnO1xuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbmFtZUhpbnQgPSAnJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lSGludCA9IFwiIGFuZCBuYW1lIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIjtcbiAgfSBlbHNlIHtcbiAgICBuYW1lSGludCA9IFwiIGFuZCBuYW1lIGBcIiArIG5hbWUgKyBcImBcIjtcbiAgfVxuICBsZXQgZGVzY3JpcHRpb25IaW50ID0gJyc7XG4gIGlmIChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzY3JpcHRpb25IaW50ID0gJyc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJykge1xuICAgIGRlc2NyaXB0aW9uSGludCA9IFwiIGFuZCBkZXNjcmlwdGlvbiBcXFwiXCIgKyBkZXNjcmlwdGlvbiArIFwiXFxcIlwiO1xuICB9IGVsc2Uge1xuICAgIGRlc2NyaXB0aW9uSGludCA9IFwiIGFuZCBkZXNjcmlwdGlvbiBgXCIgKyBkZXNjcmlwdGlvbiArIFwiYFwiO1xuICB9XG4gIHJldHVybiAoXCJcXG5VbmFibGUgdG8gZmluZCBhbiBcIiArIChoaWRkZW4gPT09IGZhbHNlID8gJ2FjY2Vzc2libGUgJyA6ICcnKSArIFwiZWxlbWVudCB3aXRoIHRoZSByb2xlIFxcXCJcIiArIHJvbGUgKyBcIlxcXCJcIiArIG5hbWVIaW50ICsgZGVzY3JpcHRpb25IaW50ICsgXCJcXG5cXG5cIiArIHJvbGVNZXNzYWdlKS50cmltKCk7XG59O1xuY29uc3QgcXVlcnlBbGxCeVJvbGVXaXRoU3VnZ2VzdGlvbnMgPSB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uKHF1ZXJ5QWxsQnlSb2xlLCBxdWVyeUFsbEJ5Um9sZS5uYW1lLCAncXVlcnlBbGwnKTtcbmNvbnN0IFtxdWVyeUJ5Um9sZSwgZ2V0QWxsQnlSb2xlLCBnZXRCeVJvbGUsIGZpbmRBbGxCeVJvbGUsIGZpbmRCeVJvbGVdID0gYnVpbGRRdWVyaWVzKHF1ZXJ5QWxsQnlSb2xlLCBnZXRNdWx0aXBsZUVycm9yJDEsIGdldE1pc3NpbmdFcnJvciQxKTtcblxuY29uc3QgZ2V0VGVzdElkQXR0cmlidXRlID0gKCkgPT4gZ2V0Q29uZmlnKCkudGVzdElkQXR0cmlidXRlO1xuY29uc3QgcXVlcnlBbGxCeVRlc3RJZCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBjaGVja0NvbnRhaW5lclR5cGUoYXJnc1swXSk7XG4gIHJldHVybiBxdWVyeUFsbEJ5QXR0cmlidXRlKGdldFRlc3RJZEF0dHJpYnV0ZSgpLCAuLi5hcmdzKTtcbn07XG5jb25zdCBnZXRNdWx0aXBsZUVycm9yID0gKGMsIGlkKSA9PiBcIkZvdW5kIG11bHRpcGxlIGVsZW1lbnRzIGJ5OiBbXCIgKyBnZXRUZXN0SWRBdHRyaWJ1dGUoKSArIFwiPVxcXCJcIiArIGlkICsgXCJcXFwiXVwiO1xuY29uc3QgZ2V0TWlzc2luZ0Vycm9yID0gKGMsIGlkKSA9PiBcIlVuYWJsZSB0byBmaW5kIGFuIGVsZW1lbnQgYnk6IFtcIiArIGdldFRlc3RJZEF0dHJpYnV0ZSgpICsgXCI9XFxcIlwiICsgaWQgKyBcIlxcXCJdXCI7XG5jb25zdCBxdWVyeUFsbEJ5VGVzdElkV2l0aFN1Z2dlc3Rpb25zID0gd3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbihxdWVyeUFsbEJ5VGVzdElkLCBxdWVyeUFsbEJ5VGVzdElkLm5hbWUsICdxdWVyeUFsbCcpO1xuY29uc3QgW3F1ZXJ5QnlUZXN0SWQsIGdldEFsbEJ5VGVzdElkLCBnZXRCeVRlc3RJZCwgZmluZEFsbEJ5VGVzdElkLCBmaW5kQnlUZXN0SWRdID0gYnVpbGRRdWVyaWVzKHF1ZXJ5QWxsQnlUZXN0SWQsIGdldE11bHRpcGxlRXJyb3IsIGdldE1pc3NpbmdFcnJvcik7XG5cbnZhciBxdWVyaWVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHF1ZXJ5QWxsQnlMYWJlbFRleHQ6IHF1ZXJ5QWxsQnlMYWJlbFRleHRXaXRoU3VnZ2VzdGlvbnMsXG4gIHF1ZXJ5QnlMYWJlbFRleHQ6IHF1ZXJ5QnlMYWJlbFRleHQsXG4gIGdldEFsbEJ5TGFiZWxUZXh0OiBnZXRBbGxCeUxhYmVsVGV4dFdpdGhTdWdnZXN0aW9ucyxcbiAgZ2V0QnlMYWJlbFRleHQ6IGdldEJ5TGFiZWxUZXh0V2l0aFN1Z2dlc3Rpb25zLFxuICBmaW5kQWxsQnlMYWJlbFRleHQ6IGZpbmRBbGxCeUxhYmVsVGV4dCxcbiAgZmluZEJ5TGFiZWxUZXh0OiBmaW5kQnlMYWJlbFRleHQsXG4gIHF1ZXJ5QnlQbGFjZWhvbGRlclRleHQ6IHF1ZXJ5QnlQbGFjZWhvbGRlclRleHQsXG4gIHF1ZXJ5QWxsQnlQbGFjZWhvbGRlclRleHQ6IHF1ZXJ5QWxsQnlQbGFjZWhvbGRlclRleHRXaXRoU3VnZ2VzdGlvbnMsXG4gIGdldEJ5UGxhY2Vob2xkZXJUZXh0OiBnZXRCeVBsYWNlaG9sZGVyVGV4dCxcbiAgZ2V0QWxsQnlQbGFjZWhvbGRlclRleHQ6IGdldEFsbEJ5UGxhY2Vob2xkZXJUZXh0LFxuICBmaW5kQWxsQnlQbGFjZWhvbGRlclRleHQ6IGZpbmRBbGxCeVBsYWNlaG9sZGVyVGV4dCxcbiAgZmluZEJ5UGxhY2Vob2xkZXJUZXh0OiBmaW5kQnlQbGFjZWhvbGRlclRleHQsXG4gIHF1ZXJ5QnlUZXh0OiBxdWVyeUJ5VGV4dCxcbiAgcXVlcnlBbGxCeVRleHQ6IHF1ZXJ5QWxsQnlUZXh0V2l0aFN1Z2dlc3Rpb25zLFxuICBnZXRCeVRleHQ6IGdldEJ5VGV4dCxcbiAgZ2V0QWxsQnlUZXh0OiBnZXRBbGxCeVRleHQsXG4gIGZpbmRBbGxCeVRleHQ6IGZpbmRBbGxCeVRleHQsXG4gIGZpbmRCeVRleHQ6IGZpbmRCeVRleHQsXG4gIHF1ZXJ5QnlEaXNwbGF5VmFsdWU6IHF1ZXJ5QnlEaXNwbGF5VmFsdWUsXG4gIHF1ZXJ5QWxsQnlEaXNwbGF5VmFsdWU6IHF1ZXJ5QWxsQnlEaXNwbGF5VmFsdWVXaXRoU3VnZ2VzdGlvbnMsXG4gIGdldEJ5RGlzcGxheVZhbHVlOiBnZXRCeURpc3BsYXlWYWx1ZSxcbiAgZ2V0QWxsQnlEaXNwbGF5VmFsdWU6IGdldEFsbEJ5RGlzcGxheVZhbHVlLFxuICBmaW5kQWxsQnlEaXNwbGF5VmFsdWU6IGZpbmRBbGxCeURpc3BsYXlWYWx1ZSxcbiAgZmluZEJ5RGlzcGxheVZhbHVlOiBmaW5kQnlEaXNwbGF5VmFsdWUsXG4gIHF1ZXJ5QnlBbHRUZXh0OiBxdWVyeUJ5QWx0VGV4dCxcbiAgcXVlcnlBbGxCeUFsdFRleHQ6IHF1ZXJ5QWxsQnlBbHRUZXh0V2l0aFN1Z2dlc3Rpb25zLFxuICBnZXRCeUFsdFRleHQ6IGdldEJ5QWx0VGV4dCxcbiAgZ2V0QWxsQnlBbHRUZXh0OiBnZXRBbGxCeUFsdFRleHQsXG4gIGZpbmRBbGxCeUFsdFRleHQ6IGZpbmRBbGxCeUFsdFRleHQsXG4gIGZpbmRCeUFsdFRleHQ6IGZpbmRCeUFsdFRleHQsXG4gIHF1ZXJ5QnlUaXRsZTogcXVlcnlCeVRpdGxlLFxuICBxdWVyeUFsbEJ5VGl0bGU6IHF1ZXJ5QWxsQnlUaXRsZVdpdGhTdWdnZXN0aW9ucyxcbiAgZ2V0QnlUaXRsZTogZ2V0QnlUaXRsZSxcbiAgZ2V0QWxsQnlUaXRsZTogZ2V0QWxsQnlUaXRsZSxcbiAgZmluZEFsbEJ5VGl0bGU6IGZpbmRBbGxCeVRpdGxlLFxuICBmaW5kQnlUaXRsZTogZmluZEJ5VGl0bGUsXG4gIHF1ZXJ5QnlSb2xlOiBxdWVyeUJ5Um9sZSxcbiAgcXVlcnlBbGxCeVJvbGU6IHF1ZXJ5QWxsQnlSb2xlV2l0aFN1Z2dlc3Rpb25zLFxuICBnZXRBbGxCeVJvbGU6IGdldEFsbEJ5Um9sZSxcbiAgZ2V0QnlSb2xlOiBnZXRCeVJvbGUsXG4gIGZpbmRBbGxCeVJvbGU6IGZpbmRBbGxCeVJvbGUsXG4gIGZpbmRCeVJvbGU6IGZpbmRCeVJvbGUsXG4gIHF1ZXJ5QnlUZXN0SWQ6IHF1ZXJ5QnlUZXN0SWQsXG4gIHF1ZXJ5QWxsQnlUZXN0SWQ6IHF1ZXJ5QWxsQnlUZXN0SWRXaXRoU3VnZ2VzdGlvbnMsXG4gIGdldEJ5VGVzdElkOiBnZXRCeVRlc3RJZCxcbiAgZ2V0QWxsQnlUZXN0SWQ6IGdldEFsbEJ5VGVzdElkLFxuICBmaW5kQWxsQnlUZXN0SWQ6IGZpbmRBbGxCeVRlc3RJZCxcbiAgZmluZEJ5VGVzdElkOiBmaW5kQnlUZXN0SWRcbn0pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7W2tleTogc3RyaW5nXTogRnVuY3Rpb259fSBGdW5jTWFwXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGNvbnRhaW5lclxuICogQHBhcmFtIHtGdW5jTWFwfSBxdWVyaWVzIG9iamVjdCBvZiBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbml0aWFsVmFsdWUgZm9yIHJlZHVjZXJcbiAqIEByZXR1cm5zIHtGdW5jTWFwfSByZXR1cm5zIG9iamVjdCBvZiBmdW5jdGlvbnMgYm91bmQgdG8gY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGdldFF1ZXJpZXNGb3JFbGVtZW50KGVsZW1lbnQsIHF1ZXJpZXMkMSwgaW5pdGlhbFZhbHVlKSB7XG4gIGlmIChxdWVyaWVzJDEgPT09IHZvaWQgMCkge1xuICAgIHF1ZXJpZXMkMSA9IHF1ZXJpZXM7XG4gIH1cbiAgaWYgKGluaXRpYWxWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdGlhbFZhbHVlID0ge307XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHF1ZXJpZXMkMSkucmVkdWNlKChoZWxwZXJzLCBrZXkpID0+IHtcbiAgICBjb25zdCBmbiA9IHF1ZXJpZXMkMVtrZXldO1xuICAgIGhlbHBlcnNba2V5XSA9IGZuLmJpbmQobnVsbCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGhlbHBlcnM7XG4gIH0sIGluaXRpYWxWYWx1ZSk7XG59XG5cbmNvbnN0IGlzUmVtb3ZlZCA9IHJlc3VsdCA9PiAhcmVzdWx0IHx8IEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiAhcmVzdWx0Lmxlbmd0aDtcblxuLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgbm90IHByZXNlbnQuXG4vLyBBcyB0aGUgbmFtZSBpbXBsaWVzLCB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkIHNob3VsZCBjaGVjayBgcHJlc2VudGAgLS0+IGByZW1vdmVkYFxuZnVuY3Rpb24gaW5pdGlhbENoZWNrKGVsZW1lbnRzKSB7XG4gIGlmIChpc1JlbW92ZWQoZWxlbWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWxlbWVudChzKSBnaXZlbiB0byB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkIGFyZSBhbHJlYWR5IHJlbW92ZWQuIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgcmVxdWlyZXMgdGhhdCB0aGUgZWxlbWVudChzKSBleGlzdChzKSBiZWZvcmUgd2FpdGluZyBmb3IgcmVtb3ZhbC4nKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZChjYWxsYmFjaywgb3B0aW9ucykge1xuICAvLyBjcmVhdGVkIGhlcmUgc28gd2UgZ2V0IGEgbmljZSBzdGFja3RyYWNlXG4gIGNvbnN0IHRpbWVvdXRFcnJvciA9IG5ldyBFcnJvcignVGltZWQgb3V0IGluIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQuJyk7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpbml0aWFsQ2hlY2soY2FsbGJhY2spO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gQXJyYXkuaXNBcnJheShjYWxsYmFjaykgPyBjYWxsYmFjayA6IFtjYWxsYmFja107XG4gICAgY29uc3QgZ2V0UmVtYWluaW5nRWxlbWVudHMgPSBlbGVtZW50cy5tYXAoZWxlbWVudCA9PiB7XG4gICAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkgcmV0dXJuICgpID0+IG51bGw7XG4gICAgICB3aGlsZSAocGFyZW50LnBhcmVudEVsZW1lbnQpIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgcmV0dXJuICgpID0+IHBhcmVudC5jb250YWlucyhlbGVtZW50KSA/IGVsZW1lbnQgOiBudWxsO1xuICAgIH0pO1xuICAgIGNhbGxiYWNrID0gKCkgPT4gZ2V0UmVtYWluaW5nRWxlbWVudHMubWFwKGMgPT4gYygpKS5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbiAgaW5pdGlhbENoZWNrKGNhbGxiYWNrKCkpO1xuICByZXR1cm4gd2FpdEZvcldyYXBwZXIoKCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVGVzdGluZ0xpYnJhcnlFbGVtZW50RXJyb3InKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKCFpc1JlbW92ZWQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgdGltZW91dEVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBvcHRpb25zKTtcbn1cblxuLypcbmVzbGludFxuICByZXF1aXJlLWF3YWl0OiBcIm9mZlwiXG4qL1xuXG5jb25zdCBldmVudE1hcCA9IHtcbiAgLy8gQ2xpcGJvYXJkIEV2ZW50c1xuICBjb3B5OiB7XG4gICAgRXZlbnRUeXBlOiAnQ2xpcGJvYXJkRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBjdXQ6IHtcbiAgICBFdmVudFR5cGU6ICdDbGlwYm9hcmRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgRXZlbnRUeXBlOiAnQ2xpcGJvYXJkRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICAvLyBDb21wb3NpdGlvbiBFdmVudHNcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBFdmVudFR5cGU6ICdDb21wb3NpdGlvbkV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIEV2ZW50VHlwZTogJ0NvbXBvc2l0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIEV2ZW50VHlwZTogJ0NvbXBvc2l0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICAvLyBLZXlib2FyZCBFdmVudHNcbiAga2V5RG93bjoge1xuICAgIEV2ZW50VHlwZTogJ0tleWJvYXJkRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNoYXJDb2RlOiAwLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGtleVByZXNzOiB7XG4gICAgRXZlbnRUeXBlOiAnS2V5Ym9hcmRFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY2hhckNvZGU6IDAsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAga2V5VXA6IHtcbiAgICBFdmVudFR5cGU6ICdLZXlib2FyZEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjaGFyQ29kZTogMCxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICAvLyBGb2N1cyBFdmVudHNcbiAgZm9jdXM6IHtcbiAgICBFdmVudFR5cGU6ICdGb2N1c0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBibHVyOiB7XG4gICAgRXZlbnRUeXBlOiAnRm9jdXNFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZm9jdXNJbjoge1xuICAgIEV2ZW50VHlwZTogJ0ZvY3VzRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZm9jdXNPdXQ6IHtcbiAgICBFdmVudFR5cGU6ICdGb2N1c0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIEZvcm0gRXZlbnRzXG4gIGNoYW5nZToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIEV2ZW50VHlwZTogJ0lucHV0RXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgaW52YWxpZDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfVxuICB9LFxuICBzdWJtaXQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIE1vdXNlIEV2ZW50c1xuICBjbGljazoge1xuICAgIEV2ZW50VHlwZTogJ01vdXNlRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGJ1dHRvbjogMCxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIEV2ZW50VHlwZTogJ01vdXNlRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkYmxDbGljazoge1xuICAgIEV2ZW50VHlwZTogJ01vdXNlRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgRXZlbnRUeXBlOiAnRHJhZ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBFdmVudFR5cGU6ICdEcmFnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIEV2ZW50VHlwZTogJ0RyYWdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnTGVhdmU6IHtcbiAgICBFdmVudFR5cGU6ICdEcmFnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZHJhZ092ZXI6IHtcbiAgICBFdmVudFR5cGU6ICdEcmFnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBFdmVudFR5cGU6ICdEcmFnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBkcm9wOiB7XG4gICAgRXZlbnRUeXBlOiAnRHJhZ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbW91c2VEb3duOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIG1vdXNlRW50ZXI6IHtcbiAgICBFdmVudFR5cGU6ICdNb3VzZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbW91c2VNb3ZlOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3Zlcjoge1xuICAgIEV2ZW50VHlwZTogJ01vdXNlRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBtb3VzZVVwOiB7XG4gICAgRXZlbnRUeXBlOiAnTW91c2VFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIFNlbGVjdGlvbiBFdmVudHNcbiAgc2VsZWN0OiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIC8vIFRvdWNoIEV2ZW50c1xuICB0b3VjaENhbmNlbDoge1xuICAgIEV2ZW50VHlwZTogJ1RvdWNoRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgdG91Y2hFbmQ6IHtcbiAgICBFdmVudFR5cGU6ICdUb3VjaEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgdG91Y2hNb3ZlOiB7XG4gICAgRXZlbnRUeXBlOiAnVG91Y2hFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHRvdWNoU3RhcnQ6IHtcbiAgICBFdmVudFR5cGU6ICdUb3VjaEV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gVUkgRXZlbnRzXG4gIHJlc2l6ZToge1xuICAgIEV2ZW50VHlwZTogJ1VJRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBFdmVudFR5cGU6ICdVSUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gV2hlZWwgRXZlbnRzXG4gIHdoZWVsOiB7XG4gICAgRXZlbnRUeXBlOiAnV2hlZWxFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIC8vIE1lZGlhIEV2ZW50c1xuICBhYm9ydDoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheVRocm91Z2g6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uQ2hhbmdlOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBlbXB0aWVkOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBlbmNyeXB0ZWQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGVuZGVkOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBsb2FkZWREYXRhOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBsb2FkZWRNZXRhZGF0YToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbG9hZFN0YXJ0OiB7XG4gICAgRXZlbnRUeXBlOiAnUHJvZ3Jlc3NFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHBhdXNlOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBwbGF5OiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBwbGF5aW5nOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBwcm9ncmVzczoge1xuICAgIEV2ZW50VHlwZTogJ1Byb2dyZXNzRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICByYXRlQ2hhbmdlOiB7XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBzZWVrZWQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHNlZWtpbmc6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHN0YWxsZWQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHN1c3BlbmQ6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHRpbWVVcGRhdGU6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHZvbHVtZUNoYW5nZToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gRXZlbnRzXG4gIGxvYWQ6IHtcbiAgICAvLyBUT0RPOiBsb2FkIGV2ZW50cyBjYW4gYmUgVUlFdmVudCBvciBFdmVudCBkZXBlbmRpbmcgb24gd2hhdCBnZW5lcmF0ZWQgdGhlbVxuICAgIC8vIFRoaXMgaXMgd2hlcmUgdGhpcyBhYnN0cmFjdGlvbiBicmVha3MgZG93bi5cbiAgICAvLyBCdXQgdGhlIGNvbW1vbiB0YXJnZXRzIGFyZSA8aW1nIC8+LCA8c2NyaXB0IC8+IGFuZCB3aW5kb3cuXG4gICAgLy8gTmVpdGhlciBvZiB0aGVzZSB0YXJnZXRzIHJlY2VpdmUgYSBVSUV2ZW50XG4gICAgRXZlbnRUeXBlOiAnRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gQW5pbWF0aW9uIEV2ZW50c1xuICBhbmltYXRpb25TdGFydDoge1xuICAgIEV2ZW50VHlwZTogJ0FuaW1hdGlvbkV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25FbmQ6IHtcbiAgICBFdmVudFR5cGU6ICdBbmltYXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgYW5pbWF0aW9uSXRlcmF0aW9uOiB7XG4gICAgRXZlbnRUeXBlOiAnQW5pbWF0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIC8vIFRyYW5zaXRpb24gRXZlbnRzXG4gIHRyYW5zaXRpb25DYW5jZWw6IHtcbiAgICBFdmVudFR5cGU6ICdUcmFuc2l0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHRyYW5zaXRpb25FbmQ6IHtcbiAgICBFdmVudFR5cGU6ICdUcmFuc2l0aW9uRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgdHJhbnNpdGlvblJ1bjoge1xuICAgIEV2ZW50VHlwZTogJ1RyYW5zaXRpb25FdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgdHJhbnNpdGlvblN0YXJ0OiB7XG4gICAgRXZlbnRUeXBlOiAnVHJhbnNpdGlvbkV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvLyBwb2ludGVyIGV2ZW50c1xuICBwb2ludGVyT3Zlcjoge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJFbnRlcjoge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJEb3duOiB7XG4gICAgRXZlbnRUeXBlOiAnUG9pbnRlckV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcG9pbnRlck1vdmU6IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBwb2ludGVyVXA6IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBwb2ludGVyQ2FuY2VsOiB7XG4gICAgRXZlbnRUeXBlOiAnUG9pbnRlckV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJPdXQ6IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBwb2ludGVyTGVhdmU6IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBnb3RQb2ludGVyQ2FwdHVyZToge1xuICAgIEV2ZW50VHlwZTogJ1BvaW50ZXJFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfVxuICB9LFxuICBsb3N0UG9pbnRlckNhcHR1cmU6IHtcbiAgICBFdmVudFR5cGU6ICdQb2ludGVyRXZlbnQnLFxuICAgIGRlZmF1bHRJbml0OiB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gaGlzdG9yeSBldmVudHNcbiAgcG9wU3RhdGU6IHtcbiAgICBFdmVudFR5cGU6ICdQb3BTdGF0ZUV2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvLyB3aW5kb3cgZXZlbnRzXG4gIG9mZmxpbmU6IHtcbiAgICBFdmVudFR5cGU6ICdFdmVudCcsXG4gICAgZGVmYXVsdEluaXQ6IHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG9ubGluZToge1xuICAgIEV2ZW50VHlwZTogJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdDoge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH1cbiAgfVxufTtcbmNvbnN0IGV2ZW50QWxpYXNNYXAgPSB7XG4gIGRvdWJsZUNsaWNrOiAnZGJsQ2xpY2snXG59O1xuXG5mdW5jdGlvbiBmaXJlRXZlbnQoZWxlbWVudCwgZXZlbnQpIHtcbiAgcmV0dXJuIGdldENvbmZpZygpLmV2ZW50V3JhcHBlcigoKSA9PiB7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpcmUgYW4gZXZlbnQgLSBwbGVhc2UgcHJvdmlkZSBhbiBldmVudCBvYmplY3QuXCIpO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaXJlIGEgXFxcIlwiICsgZXZlbnQudHlwZSArIFwiXFxcIiBldmVudCAtIHBsZWFzZSBwcm92aWRlIGEgRE9NIGVsZW1lbnQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudChldmVudE5hbWUsIG5vZGUsIGluaXQsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgRXZlbnRUeXBlID0gJ0V2ZW50JyxcbiAgICBkZWZhdWx0SW5pdCA9IHt9XG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpcmUgYSBcXFwiXCIgKyBldmVudE5hbWUgKyBcIlxcXCIgZXZlbnQgLSBwbGVhc2UgcHJvdmlkZSBhIERPTSBlbGVtZW50LlwiKTtcbiAgfVxuICBjb25zdCBldmVudEluaXQgPSB7XG4gICAgLi4uZGVmYXVsdEluaXQsXG4gICAgLi4uaW5pdFxuICB9O1xuICBjb25zdCB7XG4gICAgdGFyZ2V0OiB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGZpbGVzLFxuICAgICAgLi4udGFyZ2V0UHJvcGVydGllc1xuICAgIH0gPSB7fVxuICB9ID0gZXZlbnRJbml0O1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldE5hdGl2ZVZhbHVlKG5vZGUsIHZhbHVlKTtcbiAgfVxuICBpZiAoZmlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGlucHV0LmZpbGVzIGlzIGEgcmVhZC1vbmx5IHByb3BlcnR5IHNvIHRoaXMgaXMgbm90IGFsbG93ZWQ6XG4gICAgLy8gaW5wdXQuZmlsZXMgPSBbZmlsZV1cbiAgICAvLyBzbyB3ZSBoYXZlIHRvIHVzZSB0aGlzIHdvcmthcm91bmQgdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCAnZmlsZXMnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmlsZXNcbiAgICB9KTtcbiAgfVxuICBPYmplY3QuYXNzaWduKG5vZGUsIHRhcmdldFByb3BlcnRpZXMpO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3dGcm9tTm9kZShub2RlKTtcbiAgY29uc3QgRXZlbnRDb25zdHJ1Y3RvciA9IHdpbmRvd1tFdmVudFR5cGVdIHx8IHdpbmRvdy5FdmVudDtcbiAgbGV0IGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgaWYgKHR5cGVvZiBFdmVudENvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnQgPSBuZXcgRXZlbnRDb25zdHJ1Y3RvcihldmVudE5hbWUsIGV2ZW50SW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSUUxMSBwb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudCNQb2x5ZmlsbFxuICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KEV2ZW50VHlwZSk7XG4gICAgY29uc3Qge1xuICAgICAgYnViYmxlcyxcbiAgICAgIGNhbmNlbGFibGUsXG4gICAgICBkZXRhaWwsXG4gICAgICAuLi5vdGhlckluaXRcbiAgICB9ID0gZXZlbnRJbml0O1xuICAgIGV2ZW50LmluaXRFdmVudChldmVudE5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCk7XG4gICAgT2JqZWN0LmtleXMob3RoZXJJbml0KS5mb3JFYWNoKGV2ZW50S2V5ID0+IHtcbiAgICAgIGV2ZW50W2V2ZW50S2V5XSA9IG90aGVySW5pdFtldmVudEtleV07XG4gICAgfSk7XG4gIH1cblxuICAvLyBEYXRhVHJhbnNmZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBqc2RvbTogaHR0cHM6Ly9naXRodWIuY29tL2pzZG9tL2pzZG9tL2lzc3Vlcy8xNTY4XG4gIGNvbnN0IGRhdGFUcmFuc2ZlclByb3BlcnRpZXMgPSBbJ2RhdGFUcmFuc2ZlcicsICdjbGlwYm9hcmREYXRhJ107XG4gIGRhdGFUcmFuc2ZlclByb3BlcnRpZXMuZm9yRWFjaChkYXRhVHJhbnNmZXJLZXkgPT4ge1xuICAgIGNvbnN0IGRhdGFUcmFuc2ZlclZhbHVlID0gZXZlbnRJbml0W2RhdGFUcmFuc2ZlcktleV07XG4gICAgaWYgKHR5cGVvZiBkYXRhVHJhbnNmZXJWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93LkRhdGFUcmFuc2ZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIGRhdGFUcmFuc2ZlcktleSwge1xuICAgICAgICAgIHZhbHVlOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkYXRhVHJhbnNmZXJWYWx1ZSkucmVkdWNlKChhY2MsIHByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWNjLCBwcm9wTmFtZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogZGF0YVRyYW5zZmVyVmFsdWVbcHJvcE5hbWVdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfSwgbmV3IHdpbmRvdy5EYXRhVHJhbnNmZXIoKSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIGRhdGFUcmFuc2ZlcktleSwge1xuICAgICAgICAgIHZhbHVlOiBkYXRhVHJhbnNmZXJWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXZlbnQ7XG59XG5PYmplY3Qua2V5cyhldmVudE1hcCkuZm9yRWFjaChrZXkgPT4ge1xuICBjb25zdCB7XG4gICAgRXZlbnRUeXBlLFxuICAgIGRlZmF1bHRJbml0XG4gIH0gPSBldmVudE1hcFtrZXldO1xuICBjb25zdCBldmVudE5hbWUgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgY3JlYXRlRXZlbnRba2V5XSA9IChub2RlLCBpbml0KSA9PiBjcmVhdGVFdmVudChldmVudE5hbWUsIG5vZGUsIGluaXQsIHtcbiAgICBFdmVudFR5cGUsXG4gICAgZGVmYXVsdEluaXRcbiAgfSk7XG4gIGZpcmVFdmVudFtrZXldID0gKG5vZGUsIGluaXQpID0+IGZpcmVFdmVudChub2RlLCBjcmVhdGVFdmVudFtrZXldKG5vZGUsIGluaXQpKTtcbn0pO1xuXG4vLyBmdW5jdGlvbiB3cml0dGVuIGFmdGVyIHNvbWUgaW52ZXN0aWdhdGlvbiBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMDEzNSNpc3N1ZWNvbW1lbnQtNDAxNDk2Nzc2XG5mdW5jdGlvbiBzZXROYXRpdmVWYWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuICBjb25zdCB7XG4gICAgc2V0OiB2YWx1ZVNldHRlclxuICB9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlbGVtZW50LCAndmFsdWUnKSB8fCB7fTtcbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVsZW1lbnQpO1xuICBjb25zdCB7XG4gICAgc2V0OiBwcm90b3R5cGVWYWx1ZVNldHRlclxuICB9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsICd2YWx1ZScpIHx8IHt9O1xuICBpZiAocHJvdG90eXBlVmFsdWVTZXR0ZXIgJiYgdmFsdWVTZXR0ZXIgIT09IHByb3RvdHlwZVZhbHVlU2V0dGVyKSB7XG4gICAgcHJvdG90eXBlVmFsdWVTZXR0ZXIuY2FsbChlbGVtZW50LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZiAtLSBDYW4ndCBiZSBpZ25vcmVkIGJ5IGlzdGFuYnVsIG90aGVyd2lzZVxuICAgIGlmICh2YWx1ZVNldHRlcikge1xuICAgICAgdmFsdWVTZXR0ZXIuY2FsbChlbGVtZW50LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhIHZhbHVlIHNldHRlcicpO1xuICAgIH1cbiAgfVxufVxuT2JqZWN0LmtleXMoZXZlbnRBbGlhc01hcCkuZm9yRWFjaChhbGlhc0tleSA9PiB7XG4gIGNvbnN0IGtleSA9IGV2ZW50QWxpYXNNYXBbYWxpYXNLZXldO1xuICBmaXJlRXZlbnRbYWxpYXNLZXldID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmaXJlRXZlbnRba2V5XSguLi5hcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OltcImVycm9yXCIsIDldICovXG5cbi8vIFdBUk5JTkc6IGBsei1zdHJpbmdgIG9ubHkgaGFzIGEgZGVmYXVsdCBleHBvcnQgYnV0IHN0YXRpY2FsbHkgd2UgYXNzdW1lIG5hbWVkIGV4cG9ydHMgYXJlIGFsbG93ZFxuZnVuY3Rpb24gdW5pbmRlbnQoc3RyaW5nKSB7XG4gIC8vIHJlbW92ZSB3aGl0ZSBzcGFjZXMgZmlyc3QsIHRvIHNhdmUgYSBmZXcgYnl0ZXMuXG4gIC8vIHRlc3RpbmctcGxheWdyb3VuZCB3aWxsIHJlZm9ybWF0IG9uIGxvYWQgYW55IHdheXMuXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWyBcXHRdKltcXG5dWyBcXHRdKi9nLCAnXFxuJyk7XG59XG5mdW5jdGlvbiBlbmNvZGUodmFsdWUpIHtcbiAgcmV0dXJuIGx6U3RyaW5nLmNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50KHVuaW5kZW50KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBnZXRQbGF5Z3JvdW5kVXJsKG1hcmt1cCkge1xuICByZXR1cm4gXCJodHRwczovL3Rlc3RpbmctcGxheWdyb3VuZC5jb20vI21hcmt1cD1cIiArIGVuY29kZShtYXJrdXApO1xufVxuY29uc3QgZGVidWcgPSAoZWxlbWVudCwgbWF4TGVuZ3RoLCBvcHRpb25zKSA9PiBBcnJheS5pc0FycmF5KGVsZW1lbnQpID8gZWxlbWVudC5mb3JFYWNoKGVsID0+IGxvZ0RPTShlbCwgbWF4TGVuZ3RoLCBvcHRpb25zKSkgOiBsb2dET00oZWxlbWVudCwgbWF4TGVuZ3RoLCBvcHRpb25zKTtcbmNvbnN0IGxvZ1Rlc3RpbmdQbGF5Z3JvdW5kVVJMID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IHZvaWQgMCkge1xuICAgIGVsZW1lbnQgPSBnZXREb2N1bWVudCgpLmJvZHk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgaWYgKCFlbGVtZW50IHx8ICEoJ2lubmVySFRNTCcgaW4gZWxlbWVudCkpIHtcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBlbGVtZW50IHlvdSdyZSBwcm92aWRpbmcgaXNuJ3QgYSB2YWxpZCBET00gZWxlbWVudC5cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gIGlmICghZWxlbWVudC5pbm5lckhUTUwpIHtcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBwcm92aWRlZCBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGRyZW4uXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwbGF5Z3JvdW5kVXJsID0gZ2V0UGxheWdyb3VuZFVybChlbGVtZW50LmlubmVySFRNTCk7XG4gIGNvbnNvbGUubG9nKFwiT3BlbiB0aGlzIFVSTCBpbiB5b3VyIGJyb3dzZXJcXG5cXG5cIiArIHBsYXlncm91bmRVcmwpO1xuICByZXR1cm4gcGxheWdyb3VuZFVybDtcbn07XG5jb25zdCBpbml0aWFsVmFsdWUgPSB7XG4gIGRlYnVnLFxuICBsb2dUZXN0aW5nUGxheWdyb3VuZFVSTFxufTtcbmNvbnN0IHNjcmVlbiA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuYm9keSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbj8gZ2V0UXVlcmllc0ZvckVsZW1lbnQoZG9jdW1lbnQuYm9keSwgcXVlcmllcywgaW5pdGlhbFZhbHVlKSA6IE9iamVjdC5rZXlzKHF1ZXJpZXMpLnJlZHVjZSgoaGVscGVycywga2V5KSA9PiB7XG4gIC8vIGBrZXlgIGlzIGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXMgdGhlIHR5cGUgb2Yga2V5b2YgYGhlbHBlcnNgLCB3aGljaCBpdHNlbGYgaXMgdGhlIHR5cGUgb2YgYGluaXRpYWxWYWx1ZWAgcGx1cyBpbmNvbWluZyBwcm9wZXJ0aWVzIGZyb20gYHF1ZXJpZXNgXG4gIC8vIGlmIGBPYmplY3Qua2V5cyhzb21ldGhpbmcpYCByZXR1cm5lZCBBcnJheTxrZXlvZiB0eXBlb2Ygc29tZXRoaW5nPiB0aGlzIGV4cGxpY2l0IHR5cGUgYXNzZXJ0aW9uIHdvdWxkIG5vdCBiZSBuZWNlc3NhcnlcbiAgLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1MDEyMTc0L3doeS1kb2VzbnQtb2JqZWN0LWtleXMtcmV0dXJuLWEta2V5b2YtdHlwZS1pbi10eXBlc2NyaXB0XG4gIGhlbHBlcnNba2V5XSA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGb3IgcXVlcmllcyBib3VuZCB0byBkb2N1bWVudC5ib2R5IGEgZ2xvYmFsIGRvY3VtZW50IGhhcyB0byBiZSBhdmFpbGFibGUuLi4gTGVhcm4gbW9yZTogaHR0cHM6Ly90ZXN0aW5nLWxpYnJhcnkuY29tL3Mvc2NyZWVuLWdsb2JhbC1lcnJvcicpO1xuICB9O1xuICByZXR1cm4gaGVscGVycztcbn0sIGluaXRpYWxWYWx1ZSk7XG5cbmV4cG9ydCB7IGJ1aWxkUXVlcmllcywgY29uZmlndXJlLCBjcmVhdGVFdmVudCwgZmluZEFsbEJ5QWx0VGV4dCwgZmluZEFsbEJ5RGlzcGxheVZhbHVlLCBmaW5kQWxsQnlMYWJlbFRleHQsIGZpbmRBbGxCeVBsYWNlaG9sZGVyVGV4dCwgZmluZEFsbEJ5Um9sZSwgZmluZEFsbEJ5VGVzdElkLCBmaW5kQWxsQnlUZXh0LCBmaW5kQWxsQnlUaXRsZSwgZmluZEJ5QWx0VGV4dCwgZmluZEJ5RGlzcGxheVZhbHVlLCBmaW5kQnlMYWJlbFRleHQsIGZpbmRCeVBsYWNlaG9sZGVyVGV4dCwgZmluZEJ5Um9sZSwgZmluZEJ5VGVzdElkLCBmaW5kQnlUZXh0LCBmaW5kQnlUaXRsZSwgZmlyZUV2ZW50LCBnZXRBbGxCeUFsdFRleHQsIGdldEFsbEJ5RGlzcGxheVZhbHVlLCBnZXRBbGxCeUxhYmVsVGV4dFdpdGhTdWdnZXN0aW9ucyBhcyBnZXRBbGxCeUxhYmVsVGV4dCwgZ2V0QWxsQnlQbGFjZWhvbGRlclRleHQsIGdldEFsbEJ5Um9sZSwgZ2V0QWxsQnlUZXN0SWQsIGdldEFsbEJ5VGV4dCwgZ2V0QWxsQnlUaXRsZSwgZ2V0QnlBbHRUZXh0LCBnZXRCeURpc3BsYXlWYWx1ZSwgZ2V0QnlMYWJlbFRleHRXaXRoU3VnZ2VzdGlvbnMgYXMgZ2V0QnlMYWJlbFRleHQsIGdldEJ5UGxhY2Vob2xkZXJUZXh0LCBnZXRCeVJvbGUsIGdldEJ5VGVzdElkLCBnZXRCeVRleHQsIGdldEJ5VGl0bGUsIGdldENvbmZpZywgZ2V0RGVmYXVsdE5vcm1hbGl6ZXIsIGdldEVsZW1lbnRFcnJvciwgZ2V0TXVsdGlwbGVFbGVtZW50c0ZvdW5kRXJyb3IsIGdldE5vZGVUZXh0LCBnZXRRdWVyaWVzRm9yRWxlbWVudCwgZ2V0Um9sZXMsIGdldFN1Z2dlc3RlZFF1ZXJ5LCBpc0luYWNjZXNzaWJsZSwgbG9nRE9NLCBsb2dSb2xlcywgbWFrZUZpbmRRdWVyeSwgbWFrZUdldEFsbFF1ZXJ5LCBtYWtlU2luZ2xlUXVlcnksIHByZXR0eURPTSwgcXVlcmllcywgcXVlcnlBbGxCeUFsdFRleHRXaXRoU3VnZ2VzdGlvbnMgYXMgcXVlcnlBbGxCeUFsdFRleHQsIHF1ZXJ5QWxsQnlBdHRyaWJ1dGUsIHF1ZXJ5QWxsQnlEaXNwbGF5VmFsdWVXaXRoU3VnZ2VzdGlvbnMgYXMgcXVlcnlBbGxCeURpc3BsYXlWYWx1ZSwgcXVlcnlBbGxCeUxhYmVsVGV4dFdpdGhTdWdnZXN0aW9ucyBhcyBxdWVyeUFsbEJ5TGFiZWxUZXh0LCBxdWVyeUFsbEJ5UGxhY2Vob2xkZXJUZXh0V2l0aFN1Z2dlc3Rpb25zIGFzIHF1ZXJ5QWxsQnlQbGFjZWhvbGRlclRleHQsIHF1ZXJ5QWxsQnlSb2xlV2l0aFN1Z2dlc3Rpb25zIGFzIHF1ZXJ5QWxsQnlSb2xlLCBxdWVyeUFsbEJ5VGVzdElkV2l0aFN1Z2dlc3Rpb25zIGFzIHF1ZXJ5QWxsQnlUZXN0SWQsIHF1ZXJ5QWxsQnlUZXh0V2l0aFN1Z2dlc3Rpb25zIGFzIHF1ZXJ5QWxsQnlUZXh0LCBxdWVyeUFsbEJ5VGl0bGVXaXRoU3VnZ2VzdGlvbnMgYXMgcXVlcnlBbGxCeVRpdGxlLCBxdWVyeUJ5QWx0VGV4dCwgcXVlcnlCeUF0dHJpYnV0ZSwgcXVlcnlCeURpc3BsYXlWYWx1ZSwgcXVlcnlCeUxhYmVsVGV4dCwgcXVlcnlCeVBsYWNlaG9sZGVyVGV4dCwgcXVlcnlCeVJvbGUsIHF1ZXJ5QnlUZXN0SWQsIHF1ZXJ5QnlUZXh0LCBxdWVyeUJ5VGl0bGUsIHF1ZXJ5SGVscGVycywgc2NyZWVuLCB3YWl0Rm9yV3JhcHBlciBhcyB3YWl0Rm9yLCB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkLCBnZXRRdWVyaWVzRm9yRWxlbWVudCBhcyB3aXRoaW4sIHdyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24sIHdyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@testing-library/dom/dist/@testing-library/dom.esm.js\n");

/***/ })

};
;